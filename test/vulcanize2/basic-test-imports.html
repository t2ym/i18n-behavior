<html><head><!--
@license https://github.com/t2ym/i18n-format/blob/master/LICENSE.md
Copyright (c) 2016, Tetsuya Mori <t2y3141592@gmail.com>. All rights reserved.
--><!--
@license https://github.com/t2ym/i18n-number/blob/master/LICENSE.md
Copyright (c) 2016, Tetsuya Mori <t2y3141592@gmail.com>. All rights reserved.
--><!--
@license
Copyright (c) 2015 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
--><!--
@license
Copyright (c) 2016 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
--><!--
@license
Copyright (c) 2014 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
--><!--
@license
Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
--><!--
@license https://github.com/t2ym/i18n-behavior/blob/master/LICENSE.md
Copyright (c) 2016, Tetsuya Mori <t2y3141592@gmail.com>. All rights reserved.
--><meta charset="UTF-8">
</head><body><div hidden="" by-vulcanize=""><script>"use strict";
var fakeServerContents =
{
  "/commented-simple-text-element/commented-simple-text-element.json": "{\n  \"meta\": {},\n  \"model\": {},\n  \"text\": \" outermost text at the beginning \",\n  \"h1_3\": \"outermost header 1\",\n  \"text_4\": \" outermost text in the middle \",\n  \"span_5\": \"simple text without id\",\n  \"span_6\": \"simple text without id 2\",\n  \"label-1\": \"simple text with id\",\n  \"label-2\": \"simple text with id 2\",\n  \"div_9:span\": \"simple text within div\",\n  \"div_9:span_1\": \"simple text within div 2\",\n  \"div_9:div_2:div\": \"great grandchild text within div\",\n  \"div_10:text\": \" simple text as the first element in div \",\n  \"div_10:span_1\": \"simple text within div\",\n  \"div_10:text_2\": \" simple text in the middle of div \",\n  \"div_10:span_3\": \"simple text within div 2\",\n  \"div_10:div_4:div\": \"great grandchild text within div\",\n  \"div_10:text_5\": \" simple text at the last element in div \",\n  \"toplevel-div:span\": \"simple text within div\",\n  \"toplevel-div:span_1\": \"simple text within div 2\",\n  \"third-level-div\": \"great grandchild text within div\",\n  \"second-level-div:div_1\": \"great grandchild text within div without id\",\n  \"div_12:ul:li\": \"line item without id 1\",\n  \"div_12:ul:li_1\": \"line item without id 2\",\n  \"div_12:ul:li_2\": \"line item without id 3\",\n  \"line-items:li\": \"line item with id 1\",\n  \"line-items:li_1\": \"line item with id 2\",\n  \"line-items:li_2\": \"line item with id 3\",\n  \"p_13\": [\n    \"A paragraph with {1} is converted to {2}.\",\n    \"parameters\",\n    \"<i18n-format>\"\n  ],\n  \"paragraph\": [\n    \"A paragraph with {1} is converted to {2}.\",\n    \"id\",\n    \"<i18n-format>\"\n  ],\n  \"text_15\": \" outermost text at the end \"\n}",
  "/commented-simple-text-element/locales/commented-simple-text-element.fr.json": "{\n  \"model\": {},\n  \"text\": \" fr outermost text at the beginning \",\n  \"h1_3\": \"fr outermost header 1\",\n  \"text_4\": \" fr outermost text in the middle \",\n  \"span_5\": \"fr simple text without id\",\n  \"span_6\": \"fr simple text without id 2\",\n  \"label-1\": \"fr simple text with id\",\n  \"label-2\": \"fr simple text with id 2\",\n  \"div_9:span\": \"fr simple text within div\",\n  \"div_9:span_1\": \"fr simple text within div 2\",\n  \"div_9:div_2:div\": \"fr great grandchild text within div\",\n  \"div_10:text\": \" fr simple text as the first element in div \",\n  \"div_10:span_1\": \"fr simple text within div\",\n  \"div_10:text_2\": \" fr simple text in the middle of div \",\n  \"div_10:span_3\": \"fr simple text within div 2\",\n  \"div_10:div_4:div\": \"fr great grandchild text within div\",\n  \"div_10:text_5\": \" fr simple text at the last element in div \",\n  \"toplevel-div:span\": \"fr simple text within div\",\n  \"toplevel-div:span_1\": \"fr simple text within div 2\",\n  \"third-level-div\": \"fr great grandchild text within div\",\n  \"second-level-div:div_1\": \"fr great grandchild text within div without id\",\n  \"div_12:ul:li\": \"fr line item without id 1\",\n  \"div_12:ul:li_1\": \"fr line item without id 2\",\n  \"div_12:ul:li_2\": \"fr line item without id 3\",\n  \"line-items:li\": \"fr line item with id 1\",\n  \"line-items:li_1\": \"fr line item with id 2\",\n  \"line-items:li_2\": \"fr line item with id 3\",\n  \"p_13\": [\n    \"fr A paragraph with {1} is converted to {2}.\",\n    \"fr parameters\",\n    \"fr <i18n-format>\"\n  ],\n  \"paragraph\": [\n    \"fr A paragraph with {1} is converted to {2}.\",\n    \"fr id\",\n    \"fr <i18n-format>\"\n  ],\n  \"text_15\": \" fr outermost text at the end \"\n}\n",
  "/compound-binding-dom-bind.json": "{\n  \"meta\": {},\n  \"model\": {},\n  \"text\": [\n    \" outermost text at the beginning with compound {1} and {2} variables \",\n    \"{{param1}}\",\n    \"{{param2}}\"\n  ],\n  \"h1_3\": [\n    \"outermost header 1 with {1} and {2} variables\",\n    \"{{param1}}\",\n    \"{{param2}}\"\n  ],\n  \"text_4\": [\n    \" outermost text in the middle with {1} and {2} variables \",\n    \"{{param1}}\",\n    \"{{param2}}\"\n  ],\n  \"span_5\": [\n    \"simple text without id with {1} and {2} variables\",\n    \"{{param1}}\",\n    \"{{param2}}\"\n  ],\n  \"span_6\": [\n    \"simple text without id 2 with {1} and {2} variables\",\n    \"{{param1}}\",\n    \"{{param2}}\"\n  ],\n  \"label-1\": [\n    \"simple text with id and {1} and {2} variables\",\n    \"{{param1}}\",\n    \"{{param2}}\"\n  ],\n  \"label-2\": [\n    \"simple text with id and {1} and {2} variables 2\",\n    \"{{param1}}\",\n    \"{{param2}}\"\n  ],\n  \"div_9:span\": [\n    \"simple text within div with {1} and {2} variables\",\n    \"{{param1}}\",\n    \"{{param2}}\"\n  ],\n  \"div_9:span_1\": [\n    \"simple text within div with {1} and {2} variables 2\",\n    \"{{param1}}\",\n    \"{{param2}}\"\n  ],\n  \"div_9:div_2:div\": [\n    \"great grandchild text within div with {1} and {2} variables\",\n    \"{{param1}}\",\n    \"{{param2}}\"\n  ],\n  \"div_10:text\": [\n    \" simple text as the first element in div with {1} and {2} variables \",\n    \"{{param1}}\",\n    \"{{param2}}\"\n  ],\n  \"div_10:span_1\": [\n    \"simple text within div with {1} and {2} variables\",\n    \"{{param1}}\",\n    \"{{param2}}\"\n  ],\n  \"div_10:text_2\": [\n    \" simple text in the middle of div with {1} and {2} variables \",\n    \"{{param1}}\",\n    \"{{param2}}\"\n  ],\n  \"div_10:span_3\": [\n    \"simple text within div with {1} and {2} variables 2\",\n    \"{{param1}}\",\n    \"{{param2}}\"\n  ],\n  \"div_10:div_4:div\": [\n    \"great grandchild text within div with {1} and {2} variables\",\n    \"{{param1}}\",\n    \"{{param2}}\"\n  ],\n  \"div_10:text_5\": [\n    \" simple text at the last element in div with {1} and {2} variables \",\n    \"{{param1}}\",\n    \"{{param2}}\"\n  ],\n  \"toplevel-div:span\": [\n    \"simple text within div with {1} and {2} variables\",\n    \"{{param1}}\",\n    \"{{param2}}\"\n  ],\n  \"toplevel-div:span_1\": [\n    \"simple text within div 2 with {1} and {2} variables\",\n    \"{{param1}}\",\n    \"{{param2}}\"\n  ],\n  \"third-level-div\": [\n    \"great grandchild text within div with {1} and {2} variables\",\n    \"{{param1}}\",\n    \"{{param2}}\"\n  ],\n  \"second-level-div:div_1\": [\n    \"great grandchild text within div without id with {1} and {2} variables\",\n    \"{{param1}}\",\n    \"{{param2}}\"\n  ],\n  \"div_12:ul:li\": [\n    \"line item without id 1 with {1} and {2} variables\",\n    \"{{param1}}\",\n    \"{{param2}}\"\n  ],\n  \"div_12:ul:li_1\": [\n    \"line item without id 2 with {1} and {2} variables\",\n    \"{{param1}}\",\n    \"{{param2}}\"\n  ],\n  \"div_12:ul:li_2\": [\n    \"line item without id 3 with {1} and {2} variables\",\n    \"{{param1}}\",\n    \"{{param2}}\"\n  ],\n  \"line-items:li\": [\n    \"line item with id 1 with {1} and {2} variables\",\n    \"{{param1}}\",\n    \"{{param2}}\"\n  ],\n  \"line-items:li_1\": [\n    \"line item with id 2 with {1} and {2} variables\",\n    \"{{param1}}\",\n    \"{{param2}}\"\n  ],\n  \"line-items:li_2\": [\n    \"line item with id 3 with {1} and {2} variables\",\n    \"{{param1}}\",\n    \"{{param2}}\"\n  ],\n  \"p_13\": [\n    \"A paragraph with {1} is converted to {2}.\",\n    \"{{param1}}\",\n    \"{{param2}}\"\n  ],\n  \"paragraph\": [\n    \"A paragraph with {1}, {2}, and {3} is converted to {4}.\",\n    \"id\",\n    \"{{param1}}\",\n    \"{{param2}}\",\n    \"<i18n-format>\"\n  ],\n  \"text_15\": [\n    \" outermost text at the end with {1} and {2} variables \",\n    \"{{param1}}\",\n    \"{{param2}}\"\n  ]\n}",
  "/compound-binding-element/compound-binding-element.json": "{\n  \"meta\": {},\n  \"model\": {},\n  \"text\": [\n    \" outermost text at the beginning with compound {1} and {2} variables \",\n    \"{{param1}}\",\n    \"{{param2}}\"\n  ],\n  \"h1_3\": [\n    \"outermost header 1 with {1} and {2} variables\",\n    \"{{param1}}\",\n    \"{{param2}}\"\n  ],\n  \"text_4\": [\n    \" outermost text in the middle with {1} and {2} variables \",\n    \"{{param1}}\",\n    \"{{param2}}\"\n  ],\n  \"span_5\": [\n    \"simple text without id with {1} and {2} variables\",\n    \"{{param1}}\",\n    \"{{param2}}\"\n  ],\n  \"span_6\": [\n    \"simple text without id 2 with {1} and {2} variables\",\n    \"{{param1}}\",\n    \"{{param2}}\"\n  ],\n  \"label-1\": [\n    \"simple text with id and {1} and {2} variables\",\n    \"{{param1}}\",\n    \"{{param2}}\"\n  ],\n  \"label-2\": [\n    \"simple text with id and {1} and {2} variables 2\",\n    \"{{param1}}\",\n    \"{{param2}}\"\n  ],\n  \"div_9:span\": [\n    \"simple text within div with {1} and {2} variables\",\n    \"{{param1}}\",\n    \"{{param2}}\"\n  ],\n  \"div_9:span_1\": [\n    \"simple text within div with {1} and {2} variables 2\",\n    \"{{param1}}\",\n    \"{{param2}}\"\n  ],\n  \"div_9:div_2:div\": [\n    \"great grandchild text within div with {1} and {2} variables\",\n    \"{{param1}}\",\n    \"{{param2}}\"\n  ],\n  \"div_10:text\": [\n    \" simple text as the first element in div with {1} and {2} variables \",\n    \"{{param1}}\",\n    \"{{param2}}\"\n  ],\n  \"div_10:span_1\": [\n    \"simple text within div with {1} and {2} variables\",\n    \"{{param1}}\",\n    \"{{param2}}\"\n  ],\n  \"div_10:text_2\": [\n    \" simple text in the middle of div with {1} and {2} variables \",\n    \"{{param1}}\",\n    \"{{param2}}\"\n  ],\n  \"div_10:span_3\": [\n    \"simple text within div with {1} and {2} variables 2\",\n    \"{{param1}}\",\n    \"{{param2}}\"\n  ],\n  \"div_10:div_4:div\": [\n    \"great grandchild text within div with {1} and {2} variables\",\n    \"{{param1}}\",\n    \"{{param2}}\"\n  ],\n  \"div_10:text_5\": [\n    \" simple text at the last element in div with {1} and {2} variables \",\n    \"{{param1}}\",\n    \"{{param2}}\"\n  ],\n  \"toplevel-div:span\": [\n    \"simple text within div with {1} and {2} variables\",\n    \"{{param1}}\",\n    \"{{param2}}\"\n  ],\n  \"toplevel-div:span_1\": [\n    \"simple text within div 2 with {1} and {2} variables\",\n    \"{{param1}}\",\n    \"{{param2}}\"\n  ],\n  \"third-level-div\": [\n    \"great grandchild text within div with {1} and {2} variables\",\n    \"{{param1}}\",\n    \"{{param2}}\"\n  ],\n  \"second-level-div:div_1\": [\n    \"great grandchild text within div without id with {1} and {2} variables\",\n    \"{{param1}}\",\n    \"{{param2}}\"\n  ],\n  \"div_12:ul:li\": [\n    \"line item without id 1 with {1} and {2} variables\",\n    \"{{param1}}\",\n    \"{{param2}}\"\n  ],\n  \"div_12:ul:li_1\": [\n    \"line item without id 2 with {1} and {2} variables\",\n    \"{{param1}}\",\n    \"{{param2}}\"\n  ],\n  \"div_12:ul:li_2\": [\n    \"line item without id 3 with {1} and {2} variables\",\n    \"{{param1}}\",\n    \"{{param2}}\"\n  ],\n  \"line-items:li\": [\n    \"line item with id 1 with {1} and {2} variables\",\n    \"{{param1}}\",\n    \"{{param2}}\"\n  ],\n  \"line-items:li_1\": [\n    \"line item with id 2 with {1} and {2} variables\",\n    \"{{param1}}\",\n    \"{{param2}}\"\n  ],\n  \"line-items:li_2\": [\n    \"line item with id 3 with {1} and {2} variables\",\n    \"{{param1}}\",\n    \"{{param2}}\"\n  ],\n  \"p_13\": [\n    \"A paragraph with {1} is converted to {2}.\",\n    \"{{param1}}\",\n    \"{{param2}}\"\n  ],\n  \"paragraph\": [\n    \"A paragraph with {1}, {2}, and {3} is converted to {4}.\",\n    \"id\",\n    \"{{param1}}\",\n    \"{{param2}}\",\n    \"<i18n-format>\"\n  ],\n  \"text_15\": [\n    \" outermost text at the end with {1} and {2} variables \",\n    \"{{param1}}\",\n    \"{{param2}}\"\n  ]\n}",
  "/compound-binding-element/locales/compound-binding-element.fr.json": "{\n  \"model\": {},\n  \"text\": [\n    \" fr outermost text at the beginning with compound {1} and {2} variables \",\n    \"{{param1}}\",\n    \"{{param2}}\"\n  ],\n  \"h1_3\": [\n    \"fr outermost header 1 with {1} and {2} variables\",\n    \"{{param1}}\",\n    \"{{param2}}\"\n  ],\n  \"text_4\": [\n    \" fr outermost text in the middle with {1} and {2} variables \",\n    \"{{param1}}\",\n    \"{{param2}}\"\n  ],\n  \"span_5\": [\n    \"fr simple text without id with {1} and {2} variables\",\n    \"{{param1}}\",\n    \"{{param2}}\"\n  ],\n  \"span_6\": [\n    \"fr simple text without id 2 with {1} and {2} variables\",\n    \"{{param1}}\",\n    \"{{param2}}\"\n  ],\n  \"label-1\": [\n    \"fr simple text with id and {1} and {2} variables\",\n    \"{{param1}}\",\n    \"{{param2}}\"\n  ],\n  \"label-2\": [\n    \"fr simple text with id and {1} and {2} variables 2\",\n    \"{{param1}}\",\n    \"{{param2}}\"\n  ],\n  \"div_9:span\": [\n    \"fr simple text within div with {1} and {2} variables\",\n    \"{{param1}}\",\n    \"{{param2}}\"\n  ],\n  \"div_9:span_1\": [\n    \"fr simple text within div with {1} and {2} variables 2\",\n    \"{{param1}}\",\n    \"{{param2}}\"\n  ],\n  \"div_9:div_2:div\": [\n    \"fr great grandchild text within div with {1} and {2} variables\",\n    \"{{param1}}\",\n    \"{{param2}}\"\n  ],\n  \"div_10:text\": [\n    \" fr simple text as the first element in div with {1} and {2} variables \",\n    \"{{param1}}\",\n    \"{{param2}}\"\n  ],\n  \"div_10:span_1\": [\n    \"fr simple text within div with {1} and {2} variables\",\n    \"{{param1}}\",\n    \"{{param2}}\"\n  ],\n  \"div_10:text_2\": [\n    \" fr simple text in the middle of div with {1} and {2} variables \",\n    \"{{param1}}\",\n    \"{{param2}}\"\n  ],\n  \"div_10:span_3\": [\n    \"fr simple text within div with {1} and {2} variables 2\",\n    \"{{param1}}\",\n    \"{{param2}}\"\n  ],\n  \"div_10:div_4:div\": [\n    \"fr great grandchild text within div with {1} and {2} variables\",\n    \"{{param1}}\",\n    \"{{param2}}\"\n  ],\n  \"div_10:text_5\": [\n    \" fr simple text at the last element in div with {1} and {2} variables \",\n    \"{{param1}}\",\n    \"{{param2}}\"\n  ],\n  \"toplevel-div:span\": [\n    \"fr simple text within div with {1} and {2} variables\",\n    \"{{param1}}\",\n    \"{{param2}}\"\n  ],\n  \"toplevel-div:span_1\": [\n    \"fr simple text within div 2 with {1} and {2} variables\",\n    \"{{param1}}\",\n    \"{{param2}}\"\n  ],\n  \"third-level-div\": [\n    \"fr great grandchild text within div with {1} and {2} variables\",\n    \"{{param1}}\",\n    \"{{param2}}\"\n  ],\n  \"second-level-div:div_1\": [\n    \"fr great grandchild text within div without id with {1} and {2} variables\",\n    \"{{param1}}\",\n    \"{{param2}}\"\n  ],\n  \"div_12:ul:li\": [\n    \"fr line item without id 1 with {1} and {2} variables\",\n    \"{{param1}}\",\n    \"{{param2}}\"\n  ],\n  \"div_12:ul:li_1\": [\n    \"fr line item without id 2 with {1} and {2} variables\",\n    \"{{param1}}\",\n    \"{{param2}}\"\n  ],\n  \"div_12:ul:li_2\": [\n    \"fr line item without id 3 with {1} and {2} variables\",\n    \"{{param1}}\",\n    \"{{param2}}\"\n  ],\n  \"line-items:li\": [\n    \"fr line item with id 1 with {1} and {2} variables\",\n    \"{{param1}}\",\n    \"{{param2}}\"\n  ],\n  \"line-items:li_1\": [\n    \"fr line item with id 2 with {1} and {2} variables\",\n    \"{{param1}}\",\n    \"{{param2}}\"\n  ],\n  \"line-items:li_2\": [\n    \"fr line item with id 3 with {1} and {2} variables\",\n    \"{{param1}}\",\n    \"{{param2}}\"\n  ],\n  \"p_13\": [\n    \"fr A paragraph with {1} is converted to {2}.\",\n    \"{{param1}}\",\n    \"{{param2}}\"\n  ],\n  \"paragraph\": [\n    \"fr A paragraph with {1}, {2}, and {3} is converted to {4}.\",\n    \"fr id\",\n    \"{{param1}}\",\n    \"{{param2}}\",\n    \"fr <i18n-format>\"\n  ],\n  \"text_15\": [\n    \" fr outermost text at the end with {1} and {2} variables \",\n    \"{{param1}}\",\n    \"{{param2}}\"\n  ]\n}\n",
  "/edge-case-dom-bind.json": "{\n  \"meta\": {},\n  \"model\": {},\n  \"text\": [\n    \" name = {1} \",\n    \"{{text.name}}\"\n  ],\n  \"i18n-number_1\": \"1\",\n  \"i18n-format_2\": [\n    \"{{text.format}}\",\n    \"1\"\n  ],\n  \"i18n-format_3\": [\n    \"format\",\n    \"\"\n  ],\n  \"p_8\": [\n    \"hello {1}{2} {3} world\",\n    \"<br>\",\n    \"<span>\",\n    \"<span>\"\n  ],\n  \"p_9\": [\n    \"hello{1}world\",\n    \"<br>\"\n  ],\n  \"text_10\": \" hello \",\n  \"text_14\": \" world \"\n}",
  "/edge-case/advanced-binding-element.json": "{\n  \"meta\": {},\n  \"model\": {\n    \"aria-attributes\": {\n      \"title\": \"tooltip text\",\n      \"aria-label\": \"aria label text\",\n      \"aria-valuetext\": \"aria value text\"\n    }\n  },\n  \"annotated-format\": [\n    \"{{tr(status,text.statusMessageFormats)}}\",\n    \"{{parameter}}\",\n    \"string parameter\"\n  ],\n  \"span_5\": [\n    \"{1} {2}\",\n    \"{{text.defaultValue}}\",\n    \"{{text.defaultValue}}\"\n  ],\n  \"statusMessages\": {\n    \"ok\": \"healthy status\",\n    \"busy\": \"busy status\",\n    \"error\": \"error status\",\n    \"default\": \"unknown status\"\n  },\n  \"defaultValue\": \"default value\",\n  \"statusMessageFormats\": {\n    \"ok\": \"healthy status\",\n    \"busy\": \"busy status with {2}\",\n    \"error\": \"error status with {1} and {2}\",\n    \"default\": \"unknown status\"\n  },\n  \"nodefault\": {\n    \"ok\": \"ok status\"\n  }\n}",
  "/edge-case/complex-compound-binding-element.json": "{\n  \"meta\": {},\n  \"model\": {},\n  \"item-update2:text\": [\n    \"updated: {1}, by: \",\n    \"{{text.updated}}\"\n  ],\n  \"item-update2:text_2\": \" xxx \",\n  \"item-update2:dom-if_3:template:span:b\": \"IF CONTENT\",\n  \"item-update2:b_4\": \"abc\",\n  \"item-update2:dom-if_5:template:text\": \"IF CONTENT 2\",\n  \"item-update2:text_6\": \" hello \",\n  \"item-update:text\": [\n    \"updated: {1}, by: \",\n    \"{{text.updated}}\"\n  ],\n  \"item-update:text_2\": \" xxx \",\n  \"item-update:dom-if_3:template:b\": \"IF CONTENT\",\n  \"item-update:b_4\": \"abc\",\n  \"item-update:dom-if_5:template:text\": \"IF CONTENT 2\",\n  \"item-update:text_6\": \" hello \",\n  \"item-update3:text\": [\n    \"updated: {1}, by: \",\n    \"{{text.updated}}\"\n  ],\n  \"item-update3:text_2\": \" xxx \",\n  \"item-update3:dom-if_3:template:b\": \"IF\",\n  \"item-update3:dom-if_3:template:b_1\": \"CONTENT\",\n  \"item-update3:b_4\": \"abc\",\n  \"item-update3:dom-if_5:template:text\": \"IF CONTENT 2\",\n  \"item-update3:text_6\": \" hello \",\n  \"item-update4:text\": [\n    \"updated: {1}, by: \",\n    \"{{text.updated}}\"\n  ],\n  \"item-update4:dom-repeat_1:template:text\": [\n    \" {1} = {2} \",\n    \"{{item.name}}\",\n    \"{{text.updated}}\"\n  ],\n  \"item-update4:text_2\": \" xxx \",\n  \"item-update4:dom-if_3:template:b\": \"IF CONTENT\",\n  \"item-update4:b_4\": \"abc\",\n  \"item-update4:dom-if_5:template:text\": \"IF CONTENT 2\",\n  \"item-update4:text_6\": \" hello \",\n  \"paragraph:text\": \"A paragraph with \",\n  \"paragraph:text_2\": \" is converted to \",\n  \"paragraph:code_3\": \"<i18n-format>\",\n  \"paragraph:text_4\": \". \",\n  \"paragraph2:text\": \"A paragraph with deep \",\n  \"paragraph2:text_2\": \" is \",\n  \"paragraph2:b_3\": \"not\",\n  \"paragraph2:text_4\": \" converted to \",\n  \"paragraph2:code_5\": \"<i18n-format>\",\n  \"paragraph2:text_6\": \". \",\n  \"authors\": [\n    {\n      \"name\": \"Joe\"\n    },\n    {\n      \"name\": \"Alice\"\n    }\n  ],\n  \"updated\": \"Jan 1st, 2016\",\n  \"parameters\": [\n    \"parameter 1\",\n    \"parameter 2\"\n  ]\n}",
  "/edge-case/empty-element.json": "{}",
  "/edge-case/locales/advanced-binding-element.fr.json": "{\n  \"meta\": {},\n  \"model\": {\n    \"aria-attributes\": {\n      \"title\": \"fr tooltip text\",\n      \"aria-label\": \"fr aria label text\",\n      \"aria-valuetext\": \"fr aria value text\"\n    }\n  },\n  \"annotated-format\": [\n    \"{{tr(status,text.statusMessageFormats)}}\",\n    \"{{parameter}}\",\n    \"fr string parameter\"\n  ],\n  \"span_5\": [\n    \"fr {1} {2}\",\n    \"{{text.defaultValue}}\",\n    \"{{text.defaultValue}}\"\n  ],\n  \"statusMessages\": {\n    \"ok\": \"fr healthy status\",\n    \"busy\": \"fr busy status\",\n    \"error\": \"fr error status\",\n    \"default\": \"fr unknown status\"\n  },\n  \"defaultValue\": \"fr default value\",\n  \"statusMessageFormats\": {\n    \"ok\": \"fr healthy status\",\n    \"busy\": \"fr busy status with {2}\",\n    \"error\": \"fr error status with {1} and {2}\",\n    \"default\": \"fr unknown status\"\n  },\n  \"nodefault\": {\n    \"ok\": \"fr ok status\"\n  }\n}",
  "/edge-case/locales/complex-compound-binding-element.fr.json": "{\n  \"meta\": {},\n  \"model\": {},\n  \"item-update2:text\": [\n    \"fr updated: {1}, by: \",\n    \"{{text.updated}}\"\n  ],\n  \"item-update2:text_2\": \" fr xxx \",\n  \"item-update2:dom-if_3:template:span:b\": \"fr IF CONTENT\",\n  \"item-update2:b_4\": \"fr abc\",\n  \"item-update2:dom-if_5:template:text\": \"fr IF CONTENT 2\",\n  \"item-update2:text_6\": \" fr hello \",\n  \"item-update:text\": [\n    \"fr updated: {1}, by: \",\n    \"{{text.updated}}\"\n  ],\n  \"item-update:text_2\": \" fr xxx \",\n  \"item-update:dom-if_3:template:b\": \"fr IF CONTENT\",\n  \"item-update:b_4\": \"fr abc\",\n  \"item-update:dom-if_5:template:text\": \"fr IF CONTENT 2\",\n  \"item-update:text_6\": \" fr hello \",\n  \"item-update3:text\": [\n    \"fr updated: {1}, by: \",\n    \"{{text.updated}}\"\n  ],\n  \"item-update3:text_2\": \" fr xxx \",\n  \"item-update3:dom-if_3:template:b\": \"fr IF\",\n  \"item-update3:dom-if_3:template:b_1\": \"fr CONTENT\",\n  \"item-update3:b_4\": \"fr abc\",\n  \"item-update3:dom-if_5:template:text\": \"fr IF CONTENT 2\",\n  \"item-update3:text_6\": \" fr hello \",\n  \"item-update4:text\": [\n    \"fr updated: {1}, by: \",\n    \"{{text.updated}}\"\n  ],\n  \"item-update4:dom-repeat_1:template:text\": [\n    \" fr {1} = {2} \",\n    \"{{item.name}}\",\n    \"{{text.updated}}\"\n  ],\n  \"item-update4:text_2\": \" fr xxx \",\n  \"item-update4:dom-if_3:template:b\": \"fr IF CONTENT\",\n  \"item-update4:b_4\": \"fr abc\",\n  \"item-update4:dom-if_5:template:text\": \"fr IF CONTENT 2\",\n  \"item-update4:text_6\": \" fr hello \",\n  \"paragraph:text\": \"fr A paragraph with \",\n  \"paragraph:text_2\": \" fr is converted to \",\n  \"paragraph:code_3\": \"fr <i18n-format>\",\n  \"paragraph:text_4\": \"fr . \",\n  \"paragraph2:text\": \"fr A paragraph with deep \",\n  \"paragraph2:text_2\": \" fr is \",\n  \"paragraph2:b_3\": \"fr not\",\n  \"paragraph2:text_4\": \" fr converted to \",\n  \"paragraph2:code_5\": \"fr <i18n-format>\",\n  \"paragraph2:text_6\": \"fr . \",\n  \"authors\": [\n    {\n      \"name\": \"fr Joe\"\n    },\n    {\n      \"name\": \"fr Alice\"\n    }\n  ],\n  \"updated\": \"fr Jan 1st, 2016\",\n  \"parameters\": [\n    \"fr parameter 1\",\n    \"fr parameter 2\"\n  ]\n}",
  "/edge-case/locales/empty-element.fr.json": "{}",
  "/fallback-text-element/fallback-text-element.json": "{\n  \"meta\": {},\n  \"model\": {},\n  \"text\": \" outermost text at the beginning \",\n  \"h1_3\": \"outermost header 1\",\n  \"text_4\": \" outermost text in the middle \",\n  \"span_5\": \"simple text without id\",\n  \"span_6\": \"simple text without id 2\",\n  \"label-1\": \"simple text with id\",\n  \"label-2\": \"simple text with id 2\",\n  \"div_9:span\": \"simple text within div\",\n  \"div_9:span_1\": \"simple text within div 2\",\n  \"div_9:div_2:div\": \"great grandchild text within div\",\n  \"div_10:text\": \" simple text as the first element in div \",\n  \"div_10:span_1\": \"simple text within div\",\n  \"div_10:text_2\": \" simple text in the middle of div \",\n  \"div_10:span_3\": \"simple text within div 2\",\n  \"div_10:div_4:div\": \"great grandchild text within div\",\n  \"div_10:text_5\": \" simple text at the last element in div \",\n  \"toplevel-div:span\": \"simple text within div\",\n  \"toplevel-div:span_1\": \"simple text within div 2\",\n  \"third-level-div\": \"great grandchild text within div\",\n  \"second-level-div:div_1\": \"great grandchild text within div without id\",\n  \"div_12:ul:li\": \"line item without id 1\",\n  \"div_12:ul:li_1\": \"line item without id 2\",\n  \"div_12:ul:li_2\": \"line item without id 3\",\n  \"line-items:li\": \"line item with id 1\",\n  \"line-items:li_1\": \"line item with id 2\",\n  \"line-items:li_2\": \"line item with id 3\",\n  \"p_13\": [\n    \"A paragraph with {1} is converted to {2}.\",\n    \"parameters\",\n    \"<i18n-format>\"\n  ],\n  \"paragraph\": [\n    \"A paragraph with {1} is converted to {2}.\",\n    \"id\",\n    \"<i18n-format>\"\n  ],\n  \"text_15\": \" outermost text at the end \"\n}",
  "/fallback-text-element/locales/fallback-text-element.fr-CA.json": "{\n  \"model\": {},\n  \"text\": \"fr-CA  outermost text at the beginning \",\n  \"h1_3\": \"fr-CA outermost header 1\",\n  \"text_4\": \"fr-CA  outermost text in the middle \",\n  \"span_5\": \"fr-CA simple text without id\",\n  \"span_6\": \"fr-CA simple text without id 2\",\n  \"label-1\": \"fr-CA simple text with id\",\n  \"label-2\": \"fr-CA simple text with id 2\",\n  \"div_10:span_1\": \"fr-CA simple text within div\",\n  \"toplevel-div:span\": \"fr-CA simple text within div\",\n  \"toplevel-div:span_1\": \"fr-CA simple text within div 2\",\n  \"third-level-div\": \"fr-CA great grandchild text within div\",\n  \"second-level-div:div_1\": \"fr-CA great grandchild text within div without id\",\n  \"p_13\": [\n    \"fr-CA A paragraph with {1} is converted to {2}.\",\n    \"fr-CA parameters\",\n    \"fr-CA <i18n-format>\"\n  ],\n  \"paragraph\": [\n    \"fr-CA A paragraph with {1} is converted to {2}.\",\n    \"fr-CA id\",\n    \"fr-CA <i18n-format>\"\n  ],\n  \"text_15\": \"fr-CA  outermost text at the end \"\n}\n",
  "/fallback-text-element/locales/fallback-text-element.fr.json": "{\n  \"model\": {},\n  \"text\": \"fr  outermost text at the beginning \",\n  \"h1_3\": \"fr outermost header 1\",\n  \"text_4\": \"fr  outermost text in the middle \",\n  \"span_5\": \"fr simple text without id\",\n  \"span_6\": \"fr simple text without id 2\",\n  \"label-1\": \"fr simple text with id\",\n  \"label-2\": \"fr simple text with id 2\",\n  \"toplevel-div:span\": \"fr simple text within div\",\n  \"toplevel-div:span_1\": \"fr simple text within div 2\",\n  \"third-level-div\": \"fr great grandchild text within div\",\n  \"second-level-div:div_1\": \"fr great grandchild text within div without id\",\n  \"div_12:ul:li\": \"fr line item without id 1\",\n  \"div_12:ul:li_1\": \"fr line item without id 2\",\n  \"div_12:ul:li_2\": \"fr line item without id 3\",\n  \"line-items:li\": \"fr line item with id 1\",\n  \"line-items:li_1\": \"fr line item with id 2\",\n  \"line-items:li_2\": \"fr line item with id 3\",\n  \"p_13\": [\n    \"fr A paragraph with {1} is converted to {2}.\",\n    \"fr parameters\",\n    \"fr <i18n-format>\"\n  ],\n  \"paragraph\": [\n    \"fr A paragraph with {1} is converted to {2}.\",\n    \"fr id\",\n    \"fr <i18n-format>\"\n  ],\n  \"text_15\": \"fr  outermost text at the end \"\n}\n",
  "/locales/compound-binding-dom-bind.fr.json": "{\n  \"model\": {},\n  \"text\": [\n    \" fr outermost text at the beginning with compound {1} and {2} variables \",\n    \"{{param1}}\",\n    \"{{param2}}\"\n  ],\n  \"h1_3\": [\n    \"fr outermost header 1 with {1} and {2} variables\",\n    \"{{param1}}\",\n    \"{{param2}}\"\n  ],\n  \"text_4\": [\n    \" fr outermost text in the middle with {1} and {2} variables \",\n    \"{{param1}}\",\n    \"{{param2}}\"\n  ],\n  \"span_5\": [\n    \"fr simple text without id with {1} and {2} variables\",\n    \"{{param1}}\",\n    \"{{param2}}\"\n  ],\n  \"span_6\": [\n    \"fr simple text without id 2 with {1} and {2} variables\",\n    \"{{param1}}\",\n    \"{{param2}}\"\n  ],\n  \"label-1\": [\n    \"fr simple text with id and {1} and {2} variables\",\n    \"{{param1}}\",\n    \"{{param2}}\"\n  ],\n  \"label-2\": [\n    \"fr simple text with id and {1} and {2} variables 2\",\n    \"{{param1}}\",\n    \"{{param2}}\"\n  ],\n  \"div_9:span\": [\n    \"fr simple text within div with {1} and {2} variables\",\n    \"{{param1}}\",\n    \"{{param2}}\"\n  ],\n  \"div_9:span_1\": [\n    \"fr simple text within div with {1} and {2} variables 2\",\n    \"{{param1}}\",\n    \"{{param2}}\"\n  ],\n  \"div_9:div_2:div\": [\n    \"fr great grandchild text within div with {1} and {2} variables\",\n    \"{{param1}}\",\n    \"{{param2}}\"\n  ],\n  \"div_10:text\": [\n    \" fr simple text as the first element in div with {1} and {2} variables \",\n    \"{{param1}}\",\n    \"{{param2}}\"\n  ],\n  \"div_10:span_1\": [\n    \"fr simple text within div with {1} and {2} variables\",\n    \"{{param1}}\",\n    \"{{param2}}\"\n  ],\n  \"div_10:text_2\": [\n    \" fr simple text in the middle of div with {1} and {2} variables \",\n    \"{{param1}}\",\n    \"{{param2}}\"\n  ],\n  \"div_10:span_3\": [\n    \"fr simple text within div with {1} and {2} variables 2\",\n    \"{{param1}}\",\n    \"{{param2}}\"\n  ],\n  \"div_10:div_4:div\": [\n    \"fr great grandchild text within div with {1} and {2} variables\",\n    \"{{param1}}\",\n    \"{{param2}}\"\n  ],\n  \"div_10:text_5\": [\n    \" fr simple text at the last element in div with {1} and {2} variables \",\n    \"{{param1}}\",\n    \"{{param2}}\"\n  ],\n  \"toplevel-div:span\": [\n    \"fr simple text within div with {1} and {2} variables\",\n    \"{{param1}}\",\n    \"{{param2}}\"\n  ],\n  \"toplevel-div:span_1\": [\n    \"fr simple text within div 2 with {1} and {2} variables\",\n    \"{{param1}}\",\n    \"{{param2}}\"\n  ],\n  \"third-level-div\": [\n    \"fr great grandchild text within div with {1} and {2} variables\",\n    \"{{param1}}\",\n    \"{{param2}}\"\n  ],\n  \"second-level-div:div_1\": [\n    \"fr great grandchild text within div without id with {1} and {2} variables\",\n    \"{{param1}}\",\n    \"{{param2}}\"\n  ],\n  \"div_12:ul:li\": [\n    \"fr line item without id 1 with {1} and {2} variables\",\n    \"{{param1}}\",\n    \"{{param2}}\"\n  ],\n  \"div_12:ul:li_1\": [\n    \"fr line item without id 2 with {1} and {2} variables\",\n    \"{{param1}}\",\n    \"{{param2}}\"\n  ],\n  \"div_12:ul:li_2\": [\n    \"fr line item without id 3 with {1} and {2} variables\",\n    \"{{param1}}\",\n    \"{{param2}}\"\n  ],\n  \"line-items:li\": [\n    \"fr line item with id 1 with {1} and {2} variables\",\n    \"{{param1}}\",\n    \"{{param2}}\"\n  ],\n  \"line-items:li_1\": [\n    \"fr line item with id 2 with {1} and {2} variables\",\n    \"{{param1}}\",\n    \"{{param2}}\"\n  ],\n  \"line-items:li_2\": [\n    \"fr line item with id 3 with {1} and {2} variables\",\n    \"{{param1}}\",\n    \"{{param2}}\"\n  ],\n  \"p_13\": [\n    \"fr A paragraph with {1} is converted to {2}.\",\n    \"{{param1}}\",\n    \"{{param2}}\"\n  ],\n  \"paragraph\": [\n    \"fr A paragraph with {1}, {2}, and {3} is converted to {4}.\",\n    \"fr id\",\n    \"{{param1}}\",\n    \"{{param2}}\",\n    \"fr <i18n-format>\"\n  ],\n  \"text_15\": [\n    \" fr outermost text at the end with {1} and {2} variables \",\n    \"{{param1}}\",\n    \"{{param2}}\"\n  ]\n}\n",
  "/locales/simple-attribute-dom-bind.fr.json": "{\n  \"model\": {\n    \"standard-input\": {\n      \"placeholder\": \"fr standard HTML5 attribute\"\n    },\n    \"outer-div:input_2\": {\n      \"placeholder\": \"fr standard HTML5 attribute without id\"\n    },\n    \"paper-input-element\": {\n      \"label\": \"fr paper-input label\",\n      \"error-message\": \"fr paper-input error message\",\n      \"placeholder\": \"fr paper-input placeholder\"\n    },\n    \"outer-div:paper-input_4\": {\n      \"label\": \"fr paper-input label without id\",\n      \"error-message\": \"fr paper-input error message without id\",\n      \"placeholder\": \"fr paper-input placeholder without id\"\n    },\n    \"pie-chart\": {\n      \"options\": {\n        \"title\": \"fr Distribution of days in 2001H1\"\n      },\n      \"cols\": [\n        {\n          \"label\": \"fr Month\",\n          \"type\": \"string\"\n        },\n        {\n          \"label\": \"fr Days\",\n          \"type\": \"number\"\n        }\n      ],\n      \"rows\": [\n        [\n          \"fr Jan\",\n          31\n        ],\n        [\n          \"fr Feb\",\n          28\n        ],\n        [\n          \"fr Mar\",\n          31\n        ],\n        [\n          \"fr Apr\",\n          30\n        ],\n        [\n          \"fr May\",\n          31\n        ],\n        [\n          \"fr Jun\",\n          30\n        ]\n      ]\n    },\n    \"column-chart\": {\n      \"options\": {\n        \"title\": \"fr Inventory\"\n      },\n      \"data\": [\n        [\n          \"fr Year\",\n          \"fr Things\",\n          \"fr Stuff\"\n        ],\n        [\n          \"2004\",\n          1000,\n          400\n        ],\n        [\n          \"2005\",\n          1170,\n          460\n        ],\n        [\n          \"2006\",\n          660,\n          1120\n        ],\n        [\n          \"2007\",\n          1030,\n          540\n        ]\n      ]\n    },\n    \"custom-attr\": {\n      \"custom-text-attr1\": \"fr custom text attribute 1\",\n      \"custom-text-attr2\": \"fr custom text attribute 2\",\n      \"custom-text-attr3\": \"fr custom text attribute 3\"\n    },\n    \"selective-attr\": {\n      \"custom-text-attr4\": [\n        \"fr {1} custom-text-attr4 attribute with param {2} and param {3} {4}\",\n        \"{{text.ordinary-div}}\",\n        \"{{text.ordinary-div}}\",\n        \"[[text.ordinary-div]]\",\n        \"{{text.ordinary-div}}\"\n      ],\n      \"custom-text-attr5\": [\n        \"[[text.ordinary-div]]\",\n        \" fr custom-text-attr5 attribute with param \",\n        \"{{or('',text.ordinary-div)}}\",\n        \" fr and param \",\n        \"[[text.ordinary-div]]\"\n      ],\n      \"i18n-target\": [\n        \"fr i18n-target attribute with param {1} and param {2}\",\n        \"{{text.ordinary-div}}\",\n        \"[[text.ordinary-div]]\"\n      ],\n      \"i18n-target2\": [\n        \"fr i18n-target2 attribute with param \",\n        \"{{or('',text.ordinary-div)}}\",\n        \" fr and param \",\n        \"[[text.ordinary-div]]\"\n      ]\n    },\n    \"selective-attr2\": {\n      \"i18n-target\": \"fr i18n-target attribute 2\"\n    },\n    \"selective-attr3\": {\n      \"i18n-target6\": \"fr i18n-target6 attribute 2\"\n    },\n    \"selective-attr4\": {\n      \"i18n-target6\": \"fr i18n-target6 attribute 3\"\n    },\n    \"json-data-id\": {\n      \"attr1\": \"fr this attr1 is extracted\",\n      \"i18n-target-attr\": \"fr this attribute is also extracted\"\n    },\n    \"template_2:json-data_1\": {\n      \"attr1\": \"fr this attr1 without id is extracted\",\n      \"i18n-target-attr\": \"fr this attribute without id is also extracted\"\n    }\n  },\n  \"ordinary-div\": \"fr text 1\"\n}\n",
  "/locales/simple-text-dom-bind.fr.json": "{\n  \"model\": {},\n  \"text\": \" fr outermost text at the beginning \",\n  \"h1_3\": \"fr outermost header 1\",\n  \"text_4\": \" fr outermost text in the middle \",\n  \"span_5\": \"fr simple text without id\",\n  \"span_6\": \"fr simple text without id 2\",\n  \"label-1\": \"fr simple text with id\",\n  \"label-2\": \"fr simple text with id 2\",\n  \"div_9:span\": \"fr simple text within div\",\n  \"div_9:span_1\": \"fr simple text within div 2\",\n  \"div_9:div_2:div\": \"fr great grandchild text within div\",\n  \"div_10:text\": \" fr simple text as the first element in div \",\n  \"div_10:span_1\": \"fr simple text within div\",\n  \"div_10:text_2\": \" fr simple text in the middle of div \",\n  \"div_10:span_3\": \"fr simple text within div 2\",\n  \"div_10:div_4:div\": \"fr great grandchild text within div\",\n  \"div_10:text_5\": \" fr simple text at the last element in div \",\n  \"toplevel-div:span\": \"fr simple text within div\",\n  \"toplevel-div:span_1\": \"fr simple text within div 2\",\n  \"third-level-div\": \"fr great grandchild text within div\",\n  \"second-level-div:div_1\": \"fr great grandchild text within div without id\",\n  \"div_12:ul:li\": \"fr line item without id 1\",\n  \"div_12:ul:li_1\": \"fr line item without id 2\",\n  \"div_12:ul:li_2\": \"fr line item without id 3\",\n  \"line-items:li\": \"fr line item with id 1\",\n  \"line-items:li_1\": \"fr line item with id 2\",\n  \"line-items:li_2\": \"fr line item with id 3\",\n  \"p_13\": [\n    \"fr A paragraph with {1} is converted to {2}.\",\n    \"fr parameters\",\n    \"fr <i18n-format>\"\n  ],\n  \"paragraph\": [\n    \"fr A paragraph with {1} is converted to {2}.\",\n    \"fr id\",\n    \"fr <i18n-format>\"\n  ],\n  \"text_15\": \" fr outermost text at the end \"\n}\n",
  "/multiple-case/item-element.json": "{\n  \"meta\": {},\n  \"model\": {},\n  \"label\": \"A\"\n}",
  "/multiple-case/locales/item-element.fr.json": "{\n  \"meta\": {},\n  \"model\": {},\n  \"label\": \"fr A\"\n}",
  "/multiple-case/locales/multiple-element.fr.json": "{\n  \"meta\": {},\n  \"model\": {}\n}",
  "/multiple-case/multiple-element.json": "{\n  \"meta\": {},\n  \"model\": {}\n}",
  "/plural-gender-element/locales/plural-gender-element.fr.json": "{\n  \"model\": {},\n  \"compound-format-text\": [\n    {\n      \"0\": \"fr You ({3}) gave no gifts.\",\n      \"1\": {\n        \"male\": \"fr You ({3}) gave him ({4}) {5}.\",\n        \"female\": \"fr You ({3}) gave her ({4}) {5}.\",\n        \"other\": \"fr You ({3}) gave them ({4}) {5}.\"\n      },\n      \"one\": {\n        \"male\": \"fr You ({3}) gave him ({4}) and one other person {5}.\",\n        \"female\": \"fr You ({3}) gave her ({4}) and one other person {5}.\",\n        \"other\": \"fr You ({3}) gave them ({4}) and one other person {5}.\"\n      },\n      \"other\": \"fr You ({3}) gave them ({4}) and {1} other people gifts.\"\n    },\n    \"{{recipients.length - 1}}\",\n    \"{{recipients.0.gender}}\",\n    \"{{sender.name}}\",\n    \"{{recipients.0.name}}\",\n    \"fr a gift\"\n  ]\n}\n",
  "/plural-gender-element/plural-gender-element.json": "{\n  \"meta\": {},\n  \"model\": {},\n  \"compound-format-text\": [\n    {\n      \"0\": \"You ({3}) gave no gifts.\",\n      \"1\": {\n        \"male\": \"You ({3}) gave him ({4}) {5}.\",\n        \"female\": \"You ({3}) gave her ({4}) {5}.\",\n        \"other\": \"You ({3}) gave them ({4}) {5}.\"\n      },\n      \"one\": {\n        \"male\": \"You ({3}) gave him ({4}) and one other person {5}.\",\n        \"female\": \"You ({3}) gave her ({4}) and one other person {5}.\",\n        \"other\": \"You ({3}) gave them ({4}) and one other person {5}.\"\n      },\n      \"other\": \"You ({3}) gave them ({4}) and {1} other people gifts.\"\n    },\n    \"{{recipients.length - 1}}\",\n    \"{{recipients.0.gender}}\",\n    \"{{sender.name}}\",\n    \"{{recipients.0.name}}\",\n    \"a gift\"\n  ]\n}",
  "/preference/preference-element.json": "{\n  \"meta\": {},\n  \"model\": {}\n}",
  "/simple-attribute-dom-bind.json": "{\n  \"meta\": {},\n  \"model\": {\n    \"standard-input\": {\n      \"placeholder\": \"standard HTML5 attribute\"\n    },\n    \"outer-div:input_2\": {\n      \"placeholder\": \"standard HTML5 attribute without id\"\n    },\n    \"paper-input-element\": {\n      \"label\": \"paper-input label\",\n      \"error-message\": \"paper-input error message\",\n      \"placeholder\": \"paper-input placeholder\"\n    },\n    \"outer-div:paper-input_4\": {\n      \"label\": \"paper-input label without id\",\n      \"error-message\": \"paper-input error message without id\",\n      \"placeholder\": \"paper-input placeholder without id\"\n    },\n    \"pie-chart\": {\n      \"options\": {\n        \"title\": \"Distribution of days in 2001H1\"\n      },\n      \"cols\": [\n        {\n          \"label\": \"Month\",\n          \"type\": \"string\"\n        },\n        {\n          \"label\": \"Days\",\n          \"type\": \"number\"\n        }\n      ],\n      \"rows\": [\n        [\n          \"Jan\",\n          31\n        ],\n        [\n          \"Feb\",\n          28\n        ],\n        [\n          \"Mar\",\n          31\n        ],\n        [\n          \"Apr\",\n          30\n        ],\n        [\n          \"May\",\n          31\n        ],\n        [\n          \"Jun\",\n          30\n        ]\n      ]\n    },\n    \"column-chart\": {\n      \"options\": {\n        \"title\": \"Inventory\"\n      },\n      \"data\": [\n        [\n          \"Year\",\n          \"Things\",\n          \"Stuff\"\n        ],\n        [\n          \"2004\",\n          1000,\n          400\n        ],\n        [\n          \"2005\",\n          1170,\n          460\n        ],\n        [\n          \"2006\",\n          660,\n          1120\n        ],\n        [\n          \"2007\",\n          1030,\n          540\n        ]\n      ]\n    },\n    \"custom-attr\": {\n      \"custom-text-attr1\": \"custom text attribute 1\",\n      \"custom-text-attr2\": \"custom text attribute 2\",\n      \"custom-text-attr3\": \"custom text attribute 3\"\n    },\n    \"selective-attr\": {\n      \"custom-text-attr4\": [\n        \"{1} custom-text-attr4 attribute with param {2} and param {3} {4}\",\n        \"{{text.ordinary-div}}\",\n        \"{{text.ordinary-div}}\",\n        \"[[text.ordinary-div]]\",\n        \"{{text.ordinary-div}}\"\n      ],\n      \"custom-text-attr5\": [\n        \"[[text.ordinary-div]]\",\n        \" custom-text-attr5 attribute with param \",\n        \"{{or('',text.ordinary-div)}}\",\n        \" and param \",\n        \"[[text.ordinary-div]]\"\n      ],\n      \"i18n-target\": [\n        \"i18n-target attribute with param {1} and param {2}\",\n        \"{{text.ordinary-div}}\",\n        \"[[text.ordinary-div]]\"\n      ],\n      \"i18n-target2\": [\n        \"i18n-target2 attribute with param \",\n        \"{{or('',text.ordinary-div)}}\",\n        \" and param \",\n        \"[[text.ordinary-div]]\"\n      ]\n    },\n    \"selective-attr2\": {\n      \"i18n-target\": \"i18n-target attribute 2\"\n    },\n    \"selective-attr3\": {\n      \"i18n-target6\": \"i18n-target6 attribute 2\"\n    },\n    \"selective-attr4\": {\n      \"i18n-target6\": \"i18n-target6 attribute 3\"\n    },\n    \"json-data-id\": {\n      \"attr1\": \"this attr1 is extracted\",\n      \"i18n-target-attr\": \"this attribute is also extracted\"\n    },\n    \"template_2:json-data_1\": {\n      \"attr1\": \"this attr1 without id is extracted\",\n      \"i18n-target-attr\": \"this attribute without id is also extracted\"\n    }\n  },\n  \"ordinary-div\": \"text 1\"\n}",
  "/simple-attribute-element/locales/simple-attribute-element.fr.json": "{\n  \"model\": {\n    \"standard-input\": {\n      \"placeholder\": \"fr standard HTML5 attribute\"\n    },\n    \"outer-div:input_2\": {\n      \"placeholder\": \"fr standard HTML5 attribute without id\"\n    },\n    \"paper-input-element\": {\n      \"label\": \"fr paper-input label\",\n      \"error-message\": \"fr paper-input error message\",\n      \"placeholder\": \"fr paper-input placeholder\"\n    },\n    \"outer-div:paper-input_4\": {\n      \"label\": \"fr paper-input label without id\",\n      \"error-message\": \"fr paper-input error message without id\",\n      \"placeholder\": \"fr paper-input placeholder without id\"\n    },\n    \"pie-chart\": {\n      \"options\": {\n        \"title\": \"fr Distribution of days in 2001H1\"\n      },\n      \"cols\": [\n        {\n          \"label\": \"fr Month\",\n          \"type\": \"string\"\n        },\n        {\n          \"label\": \"fr Days\",\n          \"type\": \"number\"\n        }\n      ],\n      \"rows\": [\n        [\n          \"fr Jan\",\n          31\n        ],\n        [\n          \"fr Feb\",\n          28\n        ],\n        [\n          \"fr Mar\",\n          31\n        ],\n        [\n          \"fr Apr\",\n          30\n        ],\n        [\n          \"fr May\",\n          31\n        ],\n        [\n          \"fr Jun\",\n          30\n        ]\n      ]\n    },\n    \"column-chart\": {\n      \"options\": {\n        \"title\": \"fr Inventory\"\n      },\n      \"data\": [\n        [\n          \"fr Year\",\n          \"fr Things\",\n          \"fr Stuff\"\n        ],\n        [\n          \"2004\",\n          1000,\n          400\n        ],\n        [\n          \"2005\",\n          1170,\n          460\n        ],\n        [\n          \"2006\",\n          660,\n          1120\n        ],\n        [\n          \"2007\",\n          1030,\n          540\n        ]\n      ]\n    },\n    \"custom-attr\": {\n      \"custom-text-attr1\": \"fr custom text attribute 1\",\n      \"custom-text-attr2\": \"fr custom text attribute 2\",\n      \"custom-text-attr3\": \"fr custom text attribute 3\"\n    },\n    \"selective-attr\": {\n      \"custom-text-attr4\": [\n        \"fr {1} custom-text-attr4 attribute with param {2} and param {3} {4}\",\n        \"{{text.ordinary-div}}\",\n        \"{{text.ordinary-div}}\",\n        \"[[text.ordinary-div]]\",\n        \"{{text.ordinary-div}}\"\n      ],\n      \"custom-text-attr5\": [\n        \"[[text.ordinary-div]]\",\n        \" fr custom-text-attr5 attribute with param \",\n        \"{{or('',text.ordinary-div)}}\",\n        \" fr and param \",\n        \"[[text.ordinary-div]]\"\n      ],\n      \"i18n-target\": [\n        \"fr i18n-target attribute with param {1} and param {2}\",\n        \"{{text.ordinary-div}}\",\n        \"[[text.ordinary-div]]\"\n      ],\n      \"i18n-target2\": [\n        \"fr i18n-target2 attribute with param \",\n        \"{{or('',text.ordinary-div)}}\",\n        \" fr and param \",\n        \"[[text.ordinary-div]]\"\n      ]\n    },\n    \"selective-attr2\": {\n      \"i18n-target\": \"fr i18n-target attribute 2\"\n    },\n    \"selective-attr3\": {\n      \"i18n-target6\": \"fr i18n-target6 attribute 2\"\n    },\n    \"selective-attr4\": {\n      \"i18n-target6\": \"fr i18n-target6 attribute 3\"\n    },\n    \"json-data-id\": {\n      \"attr1\": \"fr this attr1 is extracted\",\n      \"i18n-target-attr\": \"fr this attribute is also extracted\"\n    },\n    \"template_2:json-data_1\": {\n      \"attr1\": \"fr this attr1 without id is extracted\",\n      \"i18n-target-attr\": \"fr this attribute without id is also extracted\"\n    }\n  },\n  \"ordinary-div\": \"fr text 1\"\n}\n",
  "/simple-attribute-element/locales/text-attribute-element.fr.json": "{\n  \"meta\": {},\n  \"model\": {},\n  \"span_4\": \"fr text\"\n}\n",
  "/simple-attribute-element/simple-attribute-element.json": "{\n  \"meta\": {},\n  \"model\": {\n    \"standard-input\": {\n      \"placeholder\": \"standard HTML5 attribute\"\n    },\n    \"outer-div:input_2\": {\n      \"placeholder\": \"standard HTML5 attribute without id\"\n    },\n    \"paper-input-element\": {\n      \"label\": \"paper-input label\",\n      \"error-message\": \"paper-input error message\",\n      \"placeholder\": \"paper-input placeholder\"\n    },\n    \"outer-div:paper-input_4\": {\n      \"label\": \"paper-input label without id\",\n      \"error-message\": \"paper-input error message without id\",\n      \"placeholder\": \"paper-input placeholder without id\"\n    },\n    \"pie-chart\": {\n      \"options\": {\n        \"title\": \"Distribution of days in 2001H1\"\n      },\n      \"cols\": [\n        {\n          \"label\": \"Month\",\n          \"type\": \"string\"\n        },\n        {\n          \"label\": \"Days\",\n          \"type\": \"number\"\n        }\n      ],\n      \"rows\": [\n        [\n          \"Jan\",\n          31\n        ],\n        [\n          \"Feb\",\n          28\n        ],\n        [\n          \"Mar\",\n          31\n        ],\n        [\n          \"Apr\",\n          30\n        ],\n        [\n          \"May\",\n          31\n        ],\n        [\n          \"Jun\",\n          30\n        ]\n      ]\n    },\n    \"column-chart\": {\n      \"options\": {\n        \"title\": \"Inventory\"\n      },\n      \"data\": [\n        [\n          \"Year\",\n          \"Things\",\n          \"Stuff\"\n        ],\n        [\n          \"2004\",\n          1000,\n          400\n        ],\n        [\n          \"2005\",\n          1170,\n          460\n        ],\n        [\n          \"2006\",\n          660,\n          1120\n        ],\n        [\n          \"2007\",\n          1030,\n          540\n        ]\n      ]\n    },\n    \"custom-attr\": {\n      \"custom-text-attr1\": \"custom text attribute 1\",\n      \"custom-text-attr2\": \"custom text attribute 2\",\n      \"custom-text-attr3\": \"custom text attribute 3\"\n    },\n    \"selective-attr\": {\n      \"custom-text-attr4\": [\n        \"{1} custom-text-attr4 attribute with param {2} and param {3} {4}\",\n        \"{{text.ordinary-div}}\",\n        \"{{text.ordinary-div}}\",\n        \"[[text.ordinary-div]]\",\n        \"{{text.ordinary-div}}\"\n      ],\n      \"custom-text-attr5\": [\n        \"[[text.ordinary-div]]\",\n        \" custom-text-attr5 attribute with param \",\n        \"{{or('',text.ordinary-div)}}\",\n        \" and param \",\n        \"[[text.ordinary-div]]\"\n      ],\n      \"i18n-target\": [\n        \"i18n-target attribute with param {1} and param {2}\",\n        \"{{text.ordinary-div}}\",\n        \"[[text.ordinary-div]]\"\n      ],\n      \"i18n-target2\": [\n        \"i18n-target2 attribute with param \",\n        \"{{or('',text.ordinary-div)}}\",\n        \" and param \",\n        \"[[text.ordinary-div]]\"\n      ]\n    },\n    \"selective-attr2\": {\n      \"i18n-target\": \"i18n-target attribute 2\"\n    },\n    \"selective-attr3\": {\n      \"i18n-target6\": \"i18n-target6 attribute 2\"\n    },\n    \"selective-attr4\": {\n      \"i18n-target6\": \"i18n-target6 attribute 3\"\n    },\n    \"json-data-id\": {\n      \"attr1\": \"this attr1 is extracted\",\n      \"i18n-target-attr\": \"this attribute is also extracted\"\n    },\n    \"template_2:json-data_1\": {\n      \"attr1\": \"this attr1 without id is extracted\",\n      \"i18n-target-attr\": \"this attribute without id is also extracted\"\n    }\n  },\n  \"ordinary-div\": \"text 1\"\n}",
  "/simple-attribute-element/text-attribute-element.json": "{\n  \"meta\": {},\n  \"model\": {},\n  \"span_4\": \"text\"\n}",
  "/simple-text-dom-bind.json": "{\n  \"meta\": {},\n  \"model\": {},\n  \"text\": \" outermost text at the beginning \",\n  \"h1_3\": \"outermost header 1\",\n  \"text_4\": \" outermost text in the middle \",\n  \"span_5\": \"simple text without id\",\n  \"span_6\": \"simple text without id 2\",\n  \"label-1\": \"simple text with id\",\n  \"label-2\": \"simple text with id 2\",\n  \"div_9:span\": \"simple text within div\",\n  \"div_9:span_1\": \"simple text within div 2\",\n  \"div_9:div_2:div\": \"great grandchild text within div\",\n  \"div_10:text\": \" simple text as the first element in div \",\n  \"div_10:span_1\": \"simple text within div\",\n  \"div_10:text_2\": \" simple text in the middle of div \",\n  \"div_10:span_3\": \"simple text within div 2\",\n  \"div_10:div_4:div\": \"great grandchild text within div\",\n  \"div_10:text_5\": \" simple text at the last element in div \",\n  \"toplevel-div:span\": \"simple text within div\",\n  \"toplevel-div:span_1\": \"simple text within div 2\",\n  \"third-level-div\": \"great grandchild text within div\",\n  \"second-level-div:div_1\": \"great grandchild text within div without id\",\n  \"div_12:ul:li\": \"line item without id 1\",\n  \"div_12:ul:li_1\": \"line item without id 2\",\n  \"div_12:ul:li_2\": \"line item without id 3\",\n  \"line-items:li\": \"line item with id 1\",\n  \"line-items:li_1\": \"line item with id 2\",\n  \"line-items:li_2\": \"line item with id 3\",\n  \"p_13\": [\n    \"A paragraph with {1} is converted to {2}.\",\n    \"parameters\",\n    \"<i18n-format>\"\n  ],\n  \"paragraph\": [\n    \"A paragraph with {1} is converted to {2}.\",\n    \"id\",\n    \"<i18n-format>\"\n  ],\n  \"text_15\": \" outermost text at the end \"\n}",
  "/simple-text-element/locales/simple-text-element.fr.json": "{\n  \"model\": {},\n  \"text\": \" fr outermost text at the beginning \",\n  \"h1_3\": \"fr outermost header 1\",\n  \"text_4\": \" fr outermost text in the middle \",\n  \"span_5\": \"fr simple text without id\",\n  \"span_6\": \"fr simple text without id 2\",\n  \"label-1\": \"fr simple text with id\",\n  \"label-2\": \"fr simple text with id 2\",\n  \"div_9:span\": \"fr simple text within div\",\n  \"div_9:span_1\": \"fr simple text within div 2\",\n  \"div_9:div_2:div\": \"fr great grandchild text within div\",\n  \"div_10:text\": \" fr simple text as the first element in div \",\n  \"div_10:span_1\": \"fr simple text within div\",\n  \"div_10:text_2\": \" fr simple text in the middle of div \",\n  \"div_10:span_3\": \"fr simple text within div 2\",\n  \"div_10:div_4:div\": \"fr great grandchild text within div\",\n  \"div_10:text_5\": \" fr simple text at the last element in div \",\n  \"toplevel-div:span\": \"fr simple text within div\",\n  \"toplevel-div:span_1\": \"fr simple text within div 2\",\n  \"third-level-div\": \"fr great grandchild text within div\",\n  \"second-level-div:div_1\": \"fr great grandchild text within div without id\",\n  \"div_12:ul:li\": \"fr line item without id 1\",\n  \"div_12:ul:li_1\": \"fr line item without id 2\",\n  \"div_12:ul:li_2\": \"fr line item without id 3\",\n  \"line-items:li\": \"fr line item with id 1\",\n  \"line-items:li_1\": \"fr line item with id 2\",\n  \"line-items:li_2\": \"fr line item with id 3\",\n  \"p_13\": [\n    \"fr A paragraph with {1} is converted to {2}.\",\n    \"fr parameters\",\n    \"fr <i18n-format>\"\n  ],\n  \"paragraph\": [\n    \"fr A paragraph with {1} is converted to {2}.\",\n    \"fr id\",\n    \"fr <i18n-format>\"\n  ],\n  \"text_15\": \" fr outermost text at the end \"\n}\n",
  "/simple-text-element/locales/simple-text-element.ru.json": "{\n  \"model\": {},\n  \"text\": \" ru outermost text at the beginning \",\n  \"h1_3\": \"ru outermost header 1\",\n  \"text_4\": \" ru outermost text in the middle \",\n  \"span_5\": \"ru simple text without id\",\n  \"span_6\": \"ru simple text without id 2\",\n  \"label-1\": \"ru simple text with id\",\n  \"label-2\": \"ru simple text with id 2\",\n  \"div_9:span\": \"ru simple text within div\",\n  \"div_9:span_1\": \"ru simple text within div 2\",\n  \"div_9:div_2:div\": \"ru great grandchild text within div\",\n  \"div_10:text\": \" ru simple text as the first element in div \",\n  \"div_10:span_1\": \"ru simple text within div\",\n  \"div_10:text_2\": \" ru simple text in the middle of div \",\n  \"div_10:span_3\": \"ru simple text within div 2\",\n  \"div_10:div_4:div\": \"ru great grandchild text within div\",\n  \"div_10:text_5\": \" ru simple text at the last element in div \",\n  \"toplevel-div:span\": \"ru simple text within div\",\n  \"toplevel-div:span_1\": \"ru simple text within div 2\",\n  \"third-level-div\": \"ru great grandchild text within div\",\n  \"second-level-div:div_1\": \"ru great grandchild text within div without id\",\n  \"div_12:ul:li\": \"ru line item without id 1\",\n  \"div_12:ul:li_1\": \"ru line item without id 2\",\n  \"div_12:ul:li_2\": \"ru line item without id 3\",\n  \"line-items:li\": \"ru line item with id 1\",\n  \"line-items:li_1\": \"ru line item with id 2\",\n  \"line-items:li_2\": \"ru line item with id 3\",\n  \"p_13\": [\n    \"ru A paragraph with {1} is converted to {2}.\",\n    \"ru parameters\",\n    \"ru <i18n-format>\"\n  ],\n  \"paragraph\": [\n    \"ru A paragraph with {1} is converted to {2}.\",\n    \"ru id\",\n    \"ru <i18n-format>\"\n  ],\n  \"text_15\": \" ru outermost text at the end \"\n}\n",
  "/simple-text-element/simple-text-element.json": "{\n  \"meta\": {},\n  \"model\": {},\n  \"text\": \" outermost text at the beginning \",\n  \"h1_3\": \"outermost header 1\",\n  \"text_4\": \" outermost text in the middle \",\n  \"span_5\": \"simple text without id\",\n  \"span_6\": \"simple text without id 2\",\n  \"label-1\": \"simple text with id\",\n  \"label-2\": \"simple text with id 2\",\n  \"div_9:span\": \"simple text within div\",\n  \"div_9:span_1\": \"simple text within div 2\",\n  \"div_9:div_2:div\": \"great grandchild text within div\",\n  \"div_10:text\": \" simple text as the first element in div \",\n  \"div_10:span_1\": \"simple text within div\",\n  \"div_10:text_2\": \" simple text in the middle of div \",\n  \"div_10:span_3\": \"simple text within div 2\",\n  \"div_10:div_4:div\": \"great grandchild text within div\",\n  \"div_10:text_5\": \" simple text at the last element in div \",\n  \"toplevel-div:span\": \"simple text within div\",\n  \"toplevel-div:span_1\": \"simple text within div 2\",\n  \"third-level-div\": \"great grandchild text within div\",\n  \"second-level-div:div_1\": \"great grandchild text within div without id\",\n  \"div_12:ul:li\": \"line item without id 1\",\n  \"div_12:ul:li_1\": \"line item without id 2\",\n  \"div_12:ul:li_2\": \"line item without id 3\",\n  \"line-items:li\": \"line item with id 1\",\n  \"line-items:li_1\": \"line item with id 2\",\n  \"line-items:li_2\": \"line item with id 3\",\n  \"p_13\": [\n    \"A paragraph with {1} is converted to {2}.\",\n    \"parameters\",\n    \"<i18n-format>\"\n  ],\n  \"paragraph\": [\n    \"A paragraph with {1} is converted to {2}.\",\n    \"id\",\n    \"<i18n-format>\"\n  ],\n  \"text_15\": \" outermost text at the end \"\n}",
  "/simple-text-id-element/locales/simple-text-id-element.fr.json": "{\n  \"model\": {},\n  \"text\": \" fr outermost text at the beginning \",\n  \"h1_3\": \"fr outermost header 1\",\n  \"text_4\": \" fr outermost text in the middle \",\n  \"span_5\": \"fr simple text without id\",\n  \"span_6\": \"fr simple text without id 2\",\n  \"label-1\": \"fr simple text with id\",\n  \"label-2\": \"fr simple text with id 2\",\n  \"div_9:span\": \"fr simple text within div\",\n  \"div_9:span_1\": \"fr simple text within div 2\",\n  \"div_9:div_2:div\": \"fr great grandchild text within div\",\n  \"div_10:text\": \" fr simple text as the first element in div \",\n  \"div_10:span_1\": \"fr simple text within div\",\n  \"div_10:text_2\": \" fr simple text in the middle of div \",\n  \"div_10:span_3\": \"fr simple text within div 2\",\n  \"div_10:div_4:div\": \"fr great grandchild text within div\",\n  \"div_10:text_5\": \" fr simple text at the last element in div \",\n  \"toplevel-div:span\": \"fr simple text within div\",\n  \"toplevel-div:span_1\": \"fr simple text within div 2\",\n  \"second-level-div\": [\n    \" fr {1}\\n        {2} \",\n    \"fr great grandchild text within div\",\n    \"fr great grandchild text within div without id\"\n  ],\n  \"div_12:ul:li\": \"fr line item without id 1\",\n  \"div_12:ul:li_1\": \"fr line item without id 2\",\n  \"div_12:ul:li_2\": \"fr line item without id 3\",\n  \"line-items\": [\n    \" fr {1}\\n        {2}\\n        {3} \",\n    \"fr line item with id 1\",\n    \"fr line item with id 2\",\n    \"fr line item with id 3\"\n  ],\n  \"p_13\": [\n    \"fr A paragraph with {1} is converted to {2}.\",\n    \"fr parameters\",\n    \"fr <i18n-format>\"\n  ],\n  \"paragraph\": [\n    \"fr A paragraph with {1} is converted to {2}.\",\n    \"fr id\",\n    \"fr <i18n-format>\"\n  ],\n  \"text_15\": \" fr outermost text at the end \"\n}\n",
  "/simple-text-id-element/simple-text-id-element.json": "{\n  \"meta\": {},\n  \"model\": {},\n  \"text\": \" outermost text at the beginning \",\n  \"h1_3\": \"outermost header 1\",\n  \"text_4\": \" outermost text in the middle \",\n  \"span_5\": \"simple text without id\",\n  \"span_6\": \"simple text without id 2\",\n  \"label-1\": \"simple text with id\",\n  \"label-2\": \"simple text with id 2\",\n  \"div_9:span\": \"simple text within div\",\n  \"div_9:span_1\": \"simple text within div 2\",\n  \"div_9:div_2:div\": \"great grandchild text within div\",\n  \"div_10:text\": \" simple text as the first element in div \",\n  \"div_10:span_1\": \"simple text within div\",\n  \"div_10:text_2\": \" simple text in the middle of div \",\n  \"div_10:span_3\": \"simple text within div 2\",\n  \"div_10:div_4:div\": \"great grandchild text within div\",\n  \"div_10:text_5\": \" simple text at the last element in div \",\n  \"toplevel-div:span\": \"simple text within div\",\n  \"toplevel-div:span_1\": \"simple text within div 2\",\n  \"second-level-div\": [\n    \" {1}\\n        {2} \",\n    \"great grandchild text within div\",\n    \"great grandchild text within div without id\"\n  ],\n  \"div_12:ul:li\": \"line item without id 1\",\n  \"div_12:ul:li_1\": \"line item without id 2\",\n  \"div_12:ul:li_2\": \"line item without id 3\",\n  \"line-items\": [\n    \" {1}\\n        {2}\\n        {3} \",\n    \"line item with id 1\",\n    \"line item with id 2\",\n    \"line item with id 3\"\n  ],\n  \"p_13\": [\n    \"A paragraph with {1} is converted to {2}.\",\n    \"parameters\",\n    \"<i18n-format>\"\n  ],\n  \"paragraph\": [\n    \"A paragraph with {1} is converted to {2}.\",\n    \"id\",\n    \"<i18n-format>\"\n  ],\n  \"text_15\": \" outermost text at the end \"\n}",
  "/template-default-lang/locales/null-template-default-lang-element.ja.json": "",
  "/template-default-lang/locales/null-template-default-lang-element.zh-Hans-CN.json": "{\n  \"meta\": {},\n  \"model\": {},\n  \"text\": \" zh-Hans-CN outermost text at the beginning \",\n  \"h1_3\": \"zh-Hans-CN outermost header 1\",\n  \"text_4\": \" zh-Hans-CN outermost text in the middle \",\n  \"span_5\": \"zh-Hans-CN simple text without id\",\n  \"span_6\": \"zh-Hans-CN simple text without id 2\",\n  \"label-1\": \"zh-Hans-CN simple text with id\",\n  \"label-2\": \"zh-Hans-CN simple text with id 2\",\n  \"div_9:span\": \"zh-Hans-CN simple text within div\",\n  \"div_9:span_1\": \"zh-Hans-CN simple text within div 2\",\n  \"div_9:div_2:div\": \"zh-Hans-CN great grandchild text within div\",\n  \"div_10:text\": \" zh-Hans-CN simple text as the first element in div \",\n  \"div_10:span_1\": \"zh-Hans-CN simple text within div\",\n  \"div_10:text_2\": \" zh-Hans-CN simple text in the middle of div \",\n  \"div_10:span_3\": \"zh-Hans-CN simple text within div 2\",\n  \"div_10:div_4:div\": \"zh-Hans-CN great grandchild text within div\",\n  \"div_10:text_5\": \" zh-Hans-CN simple text at the last element in div \",\n  \"toplevel-div:span\": \"zh-Hans-CN simple text within div\",\n  \"toplevel-div:span_1\": \"zh-Hans-CN simple text within div 2\",\n  \"third-level-div\": \"zh-Hans-CN great grandchild text within div\",\n  \"second-level-div:div_1\": \"zh-Hans-CN great grandchild text within div without id\",\n  \"div_12:ul:li\": \"zh-Hans-CN line item without id 1\",\n  \"div_12:ul:li_1\": \"zh-Hans-CN line item without id 2\",\n  \"div_12:ul:li_2\": \"zh-Hans-CN line item without id 3\",\n  \"line-items:li\": \"zh-Hans-CN line item with id 1\",\n  \"line-items:li_1\": \"zh-Hans-CN line item with id 2\",\n  \"line-items:li_2\": \"zh-Hans-CN line item with id 3\",\n  \"p_13\": [\n    \"zh-Hans-CN A paragraph with {1} is converted to {2}.\",\n    \"zh-Hans-CN parameters\",\n    \"zh-Hans-CN <i18n-format>\"\n  ],\n  \"paragraph\": [\n    \"zh-Hans-CN A paragraph with {1} is converted to {2}.\",\n    \"zh-Hans-CN id\",\n    \"zh-Hans-CN <i18n-format>\"\n  ],\n  \"text_15\": \" zh-Hans-CN outermost text at the end \"\n}",
  "/template-default-lang/locales/template-default-lang-element.zh-Hans-CN.json": "{\n  \"meta\": {},\n  \"model\": {},\n  \"text\": \" zh-Hans-CN outermost text at the beginning \",\n  \"h1_3\": \"zh-Hans-CN outermost header 1\",\n  \"text_4\": \" zh-Hans-CN outermost text in the middle \",\n  \"span_5\": \"zh-Hans-CN simple text without id\",\n  \"span_6\": \"zh-Hans-CN simple text without id 2\",\n  \"label-1\": \"zh-Hans-CN simple text with id\",\n  \"label-2\": \"zh-Hans-CN simple text with id 2\",\n  \"div_9:span\": \"zh-Hans-CN simple text within div\",\n  \"div_9:span_1\": \"zh-Hans-CN simple text within div 2\",\n  \"div_9:div_2:div\": \"zh-Hans-CN great grandchild text within div\",\n  \"div_10:text\": \" zh-Hans-CN simple text as the first element in div \",\n  \"div_10:span_1\": \"zh-Hans-CN simple text within div\",\n  \"div_10:text_2\": \" zh-Hans-CN simple text in the middle of div \",\n  \"div_10:span_3\": \"zh-Hans-CN simple text within div 2\",\n  \"div_10:div_4:div\": \"zh-Hans-CN great grandchild text within div\",\n  \"div_10:text_5\": \" zh-Hans-CN simple text at the last element in div \",\n  \"toplevel-div:span\": \"zh-Hans-CN simple text within div\",\n  \"toplevel-div:span_1\": \"zh-Hans-CN simple text within div 2\",\n  \"third-level-div\": \"zh-Hans-CN great grandchild text within div\",\n  \"second-level-div:div_1\": \"zh-Hans-CN great grandchild text within div without id\",\n  \"div_12:ul:li\": \"zh-Hans-CN line item without id 1\",\n  \"div_12:ul:li_1\": \"zh-Hans-CN line item without id 2\",\n  \"div_12:ul:li_2\": \"zh-Hans-CN line item without id 3\",\n  \"line-items:li\": \"zh-Hans-CN line item with id 1\",\n  \"line-items:li_1\": \"zh-Hans-CN line item with id 2\",\n  \"line-items:li_2\": \"zh-Hans-CN line item with id 3\",\n  \"p_13\": [\n    \"zh-Hans-CN A paragraph with {1} is converted to {2}.\",\n    \"zh-Hans-CN parameters\",\n    \"zh-Hans-CN <i18n-format>\"\n  ],\n  \"paragraph\": [\n    \"zh-Hans-CN A paragraph with {1} is converted to {2}.\",\n    \"zh-Hans-CN id\",\n    \"zh-Hans-CN <i18n-format>\"\n  ],\n  \"text_15\": \" zh-Hans-CN outermost text at the end \"\n}",
  "/template-default-lang/null-template-default-lang-element.json": "{\n  \"meta\": {},\n  \"model\": {},\n  \"text\": \" outermost text at the beginning \",\n  \"h1_3\": \"outermost header 1\",\n  \"text_4\": \" outermost text in the middle \",\n  \"span_5\": \"simple text without id\",\n  \"span_6\": \"simple text without id 2\",\n  \"label-1\": \"simple text with id\",\n  \"label-2\": \"simple text with id 2\",\n  \"div_9:span\": \"simple text within div\",\n  \"div_9:span_1\": \"simple text within div 2\",\n  \"div_9:div_2:div\": \"great grandchild text within div\",\n  \"div_10:text\": \" simple text as the first element in div \",\n  \"div_10:span_1\": \"simple text within div\",\n  \"div_10:text_2\": \" simple text in the middle of div \",\n  \"div_10:span_3\": \"simple text within div 2\",\n  \"div_10:div_4:div\": \"great grandchild text within div\",\n  \"div_10:text_5\": \" simple text at the last element in div \",\n  \"toplevel-div:span\": \"simple text within div\",\n  \"toplevel-div:span_1\": \"simple text within div 2\",\n  \"third-level-div\": \"great grandchild text within div\",\n  \"second-level-div:div_1\": \"great grandchild text within div without id\",\n  \"div_12:ul:li\": \"line item without id 1\",\n  \"div_12:ul:li_1\": \"line item without id 2\",\n  \"div_12:ul:li_2\": \"line item without id 3\",\n  \"line-items:li\": \"line item with id 1\",\n  \"line-items:li_1\": \"line item with id 2\",\n  \"line-items:li_2\": \"line item with id 3\",\n  \"p_13\": [\n    \"A paragraph with {1} is converted to {2}.\",\n    \"parameters\",\n    \"<i18n-format>\"\n  ],\n  \"paragraph\": [\n    \"A paragraph with {1} is converted to {2}.\",\n    \"id\",\n    \"<i18n-format>\"\n  ],\n  \"text_15\": \" outermost text at the end \"\n}",
  "/template-default-lang/template-default-lang-element.json": "{\n  \"meta\": {},\n  \"model\": {},\n  \"text\": \" fr outermost text at the beginning \",\n  \"h1_3\": \"fr outermost header 1\",\n  \"text_4\": \" fr outermost text in the middle \",\n  \"span_5\": \"fr simple text without id\",\n  \"span_6\": \"fr simple text without id 2\",\n  \"label-1\": \"fr simple text with id\",\n  \"label-2\": \"fr simple text with id 2\",\n  \"div_9:span\": \"fr simple text within div\",\n  \"div_9:span_1\": \"fr simple text within div 2\",\n  \"div_9:div_2:div\": \"fr great grandchild text within div\",\n  \"div_10:text\": \" fr simple text as the first element in div \",\n  \"div_10:span_1\": \"fr simple text within div\",\n  \"div_10:text_2\": \" fr simple text in the middle of div \",\n  \"div_10:span_3\": \"fr simple text within div 2\",\n  \"div_10:div_4:div\": \"fr great grandchild text within div\",\n  \"div_10:text_5\": \" fr simple text at the last element in div \",\n  \"toplevel-div:span\": \"fr simple text within div\",\n  \"toplevel-div:span_1\": \"fr simple text within div 2\",\n  \"third-level-div\": \"fr great grandchild text within div\",\n  \"second-level-div:div_1\": \"fr great grandchild text within div without id\",\n  \"div_12:ul:li\": \"fr line item without id 1\",\n  \"div_12:ul:li_1\": \"fr line item without id 2\",\n  \"div_12:ul:li_2\": \"fr line item without id 3\",\n  \"line-items:li\": \"fr line item with id 1\",\n  \"line-items:li_1\": \"fr line item with id 2\",\n  \"line-items:li_2\": \"fr line item with id 3\",\n  \"p_13\": [\n    \"fr A paragraph with {1} is converted to {2}.\",\n    \"fr parameters\",\n    \"fr <i18n-format>\"\n  ],\n  \"paragraph\": [\n    \"fr A paragraph with {1} is converted to {2}.\",\n    \"fr id\",\n    \"fr <i18n-format>\"\n  ],\n  \"text_15\": \" fr outermost text at the end \"\n}"
};
</script>
<script>/*!
 * @license https://github.com/t2ym/i18n-behavior/blob/master/LICENSE.md
 * Copyright (c) 2016, Tetsuya Mori <t2y3141592@gmail.com>. All rights reserved.
 */

if (!Number.isNaN) {
  // polyfill Number.isNaN for IE11
  Number.isNaN = function (value) {
    return typeof value === 'number' && isNaN(value);
  };
}

// Inheritance of test parameters
var p = Object.setPrototypeOf || function (target, base) { 
  var obj = Object.create(base);
  for (var p in target) {
    obj[p] = target[p];
  }
  return obj;
};
var g = Object.getPrototypeOf;
var _name = 'suite';
var suiteMap = { null: {} };
var s = function (name, baseName, extension) {
  if (suiteMap[name]) {
    throw new Error('duplicate suite name ' + name);
  }
  if (!suiteMap[baseName]) {
    throw new Error('inexistent base suite name ' + baseName);
  }
  extension[_name] = name;
  extension = p(extension, suiteMap[baseName]);
  suiteMap[name] = extension;
  return extension;
};

// Utility functions

function updateProperty (element, properties) {
  for (var name in properties) {
    var path = name.split(/[.]/);
    if (path.length === 1) {
      element[name] = properties[name];
    }
    else {
      var cursor = element;
      var p = path.shift();
      while (p) {
        if (path.length < 1) {
          cursor[p] = properties[name];
          element.notifyPath(name, properties[name], true);
          break;
        }
        else if (p === 'PolymerDom') {
          cursor = Polymer.dom(cursor);
        }
        else if (p === 'html') {
          cursor = document.querySelector('html');
        }
        else {
          cursor = cursor[p];
        }
        p = path.shift();
      }
    }
  }
}

function getProperty (target, name) {
  var path = name.split(/[.]/);
  if (path.length === 1) {
    return target[name];
  }
  else {
    var cursor = target;
    var p = path.shift();
    while (p) {
      //console.log(p, cursor);
      if (path.length < 1) {
        if (p === 'raw' ||
            p === 'text') {
          return cursor;
        }
        else if (p === 'trim') {
          return cursor.trim();
        }
        if (p === 'data') {
          cursor = cursor[p];
          cursor = cursor.replace(/^[\s]{1,}/g, ' ').replace(/[\s]{1,}$/g, ' ');
          return cursor;
        }
        else {
          return cursor[p];
        }
      }
      else if (p === 'PolymerDom') {
        cursor = Polymer.dom(cursor);
      }
      else if (p === 'previousTextSibling') {
        do {
          cursor = cursor.previousSibling;
        } while (cursor.nodeType === cursor.COMMENT_NODE ||
                 (cursor.nodeType === cursor.TEXT_NODE && cursor.data.match(/^[\s]*$/)));
      }
      else if (p === 'nextTextSibling') {
        do {
          cursor = cursor.nextSibling;
        } while (cursor.nodeType === cursor.COMMENT_NODE ||
                 (cursor.nodeType === cursor.TEXT_NODE && cursor.data.match(/^[\s]*$/)));
      }
      else if (p === 'effectiveChildNodes') {
        cursor = cursor.getEffectiveChildNodes();
      }
      else if (p === 'nonWS') {
        cursor = Array.prototype.filter.call(cursor, function (item) {
          return (item.nodeType !== item.TEXT_NODE &&
                  item.nodeType !== item.COMMENT_NODE) ||
                 (item.nodeType === item.TEXT_NODE &&
                  !item.data.match(/^[\s]*$/));
        });
      }
      else {
        cursor = cursor[p];
      }
      p = path.shift();
    }
  }
}

function deepMap (target, source, map) {
  var value;
  for (var prop in source) {
    value = source[prop];
    switch (typeof value) {
    case 'string':
    case 'number':
    case 'boolean':
      if (typeof target === 'object') {
        target[prop] = map(value, prop);
      }
      break;
    case 'object':
      if (typeof target === 'object') {
        if (Array.isArray(value)) {
          target[prop] = target[prop] || [];
          deepMap(target[prop], value, map);
        }
        else {
          target[prop] = target[prop] || {};
          deepMap(target[prop], value, map);
        }
      }
      break;
    case 'function':
    case 'symbol':
    case 'undefined':
      if (typeof target === 'object') {
        target[prop] = value;
      }
      break;
    default:
      if (typeof target === 'object') {
        target[prop] = value;
      }
      break;
    }
  }
  return target;
}

function translate (lang, path, text) {
  var result;
  switch (lang) {
  case '':
  case 'en':
  case null:
  case undefined:
    result = text;
    break;
  default:
    if (!path || path.match(/(textContent|[.]data|[.]text|[.]trim)$/)) {
      result = {};
      deepMap(result, { text: text }, function (value, prop) {
        if (typeof value === 'string' &&
            !value.match(/^({{[^{}]*}}|\[\[[^\[\]]*\]\])$/) &&
            !value.match(/^[0-9]{1,}$/) &&
            prop !== 'type') {
          if (path && path.match(/[.]trim$/)) {
            return minifyText((lang + ' ' + value).trim());
          }
          else {
            if (value.match(/^ /)) {
              return minifyText(' ' + lang + ' ' + value);
            }
            else {
              return minifyText(lang + ' ' + value);
            }
          }
        }
        return minifyText(value);
      });
      result = result.text;
    }
    else {
      result = text;
    }
  }
  //console.log('translate (' + lang + ', ' + path + ', ' + JSON.stringify(text, null, 2) + ') = ' + JSON.stringify(result, null, 2));
  return result;
}

function minifyText (text) {
  if (text && typeof text === 'string') {
    text = text.replace(/[\s]{1,}/g, ' ');
  }
  return text;
}

var isFakeServer = typeof window === 'object' &&
  typeof window.location.href === 'string' &&
  window.location.href.indexOf('xhr=fake') > 0 &&
  typeof window.fakeServerContents === 'object';

var isSuppressingSuiteParams = typeof window === 'object' &&
  typeof window.location.href === 'string' &&
  window.location.href.indexOf('suppress=true') > 0;

var syntax = 'mixin';
(function () {
  var href = typeof window === 'object' && typeof window.location.href === 'string'
    ? window.location.href : ''
  if (href) {
    [ 'mixin', 'base-element', 'thin', 'legacy', 'modified-legacy' ].forEach(function (_syntax) {
      if (href.indexOf('syntax=' + _syntax) > 0) {
        syntax = _syntax;
      }
    });
  }
})();

function setupFakeServer (e) {
  if (isFakeServer) {
    e.server = sinon.fakeServer.create();
    e.server.autoRespond = true;
    //e.server.autoRespondAfter = 100;
    e.server.respondImmediately = true;
    e.server.respondWith(/\/test\/[-\w]+(\/.*[.]json)$/, function (xhr, urlPath) {
      if (fakeServerContents.hasOwnProperty(urlPath)) {
        //console.log('fake-server: 200 ' + urlPath);
        xhr.respond(200, { 'Content-Type': 'application/json' }, fakeServerContents[urlPath])
      }
      else {
        //console.log('fake-server: 404 ' + urlPath);
        xhr.respond(404, {}, '');
      }
    });
  }
}

function teardownFakeServer (e) {
  if (isFakeServer) {
    e.server.restore();
  }
}

function setupFixture (params, fixtureModel) {
  var fixtureName = params.fixture;
  var e = document.querySelector('#' + fixtureName);
  var runningTest = document.querySelectorAll('.running-test');
  var title = document.querySelector('#test-name');
  var currentPath = window.location.pathname.split('/');
  if (!e) {
    throw new Error('Fixture element with id = ' + fixtureName + ' not found');
  }
  if (title) {
    title.textContent =
      (currentPath.length >= 2 ? currentPath[currentPath.length - 2] : '') +
      (currentPath.length >= 1 ? '/' + currentPath[currentPath.length - 1].replace(/-test[.]html$/, '') + '/': '') +
      params.suite;
  }
  //console.log('setupFixture: suite = ' + params.suite);
  if (e.is === 'i18n-dom-bind') {
    e.parentElement.classList.add('running-test');
    Array.prototype.forEach.call(runningTest, function (node) {
      if (node !== e.parentElement) {
        node.classList.remove('running-test');
      }
    });
    return new Promise(function (resolve, reject) {
      e.addEventListener('dom-change', function setupFixtureDomChange (ev) {
        if (Polymer.dom(ev).rootTarget === e) {
          //console.log('setupFixture dom-change');
          e.removeEventListener('dom-change', setupFixtureDomChange);
          try {
            if (fixtureModel &&
                typeof fixtureModel.lang === 'string' &&
                fixtureModel.lang !== 'en') {
              //console.log('setupFixture: waiting for lang-updated');
              e.addEventListener('lang-updated', function setupFixtureLangDomChange (event) {
                //console.log('setupFixtureLangDomChange');
                if (event.target === e &&
                    e.effectiveLang === fixtureModel.lang) {
                  //console.log('setupFixtureLangDomChange lang = ' + event.detail.lang + ' effectiveLang = ' + e.effectiveLang);
                  e.removeEventListener('lang-updated', setupFixtureLangDomChange);
                  e.render();
                  resolve(e);
                }
              });
              for (var p in fixtureModel) {
                e[p] = fixtureModel[p];
              }
              e.params = params;
            }
            else {
              for (var p in fixtureModel) {
                e[p] = fixtureModel[p];
              }
              e.params = params;
              //console.log('setupFixture: resolving');
              e.render();
              resolve(e);
            }
          }
          catch (ex) {
            reject(ex);
          }
        }
      });
      if (e._children) {
        e.render();
      }
    });
  }
  else {
    e.classList.add('running-test');
    Array.prototype.forEach.call(runningTest, function (node) {
      if (node !== e) {
        node.classList.remove('running-test');
      }
    });
    setupFakeServer(e);
    return new Promise(function (resolve, reject) {
      //console.log('setupFixture: name = ' + fixtureName + ' model = ' + JSON.stringify(fixtureModel, null, 2));
      if (fixtureModel) {
        var f = document.querySelector('test-fixture[id=' + fixtureName + ']');
        var t = f.querySelector('template[is=dom-template]');
        if (t) {
          var instanceProps = {};
          var p;
          for (p in fixtureModel) {
            instanceProps[p] = true;
          }
          var self = t;
          t.__templatizeOwner = undefined;
          t._ctor = Polymer.Templatize.templatize(t, self, {
            instanceProps: instanceProps,
            forwardHostProp: function(prop, value) {
              if (self._instance) {
                self._instance.forwardHostProp(prop, value);
              }
            }
          });
          t.stamp = function (model) {
            var _instance = new this._ctor(model);
            return _instance.root;
          }.bind(t);
        }
      }
      var element = fixture(fixtureName, fixtureModel);
      //console.log('setupFixture: name = ' + fixtureName +
      //            ' element.lang = ' + element.lang +
      //            ' getAttribute("lang") = ' + element.getAttribute('lang') +
      //            ' element._lang = ' + element._lang);
      if (element) {
        if (fixtureModel &&
            typeof fixtureModel.lang === 'string' &&
            fixtureModel.lang !== 'en' &&
            fixtureModel.lang !== element.effectiveLang && element.effectiveLang !== 'en') {
          //console.log('setupFixture: waiting for lang-updated');
          element.addEventListener('lang-updated', function setupFixtureLangUpdated (event) {
            //console.log('setupFixtureLangUpdated');
            if (event.target === element &&
                element.effectiveLang === fixtureModel.lang) {
              //console.log('setupFixtureLangUpdated lang = ' + event.detail.lang + ' effectiveLang = ' + element.effectiveLang);
              element.removeEventListener('lang-updated', setupFixtureLangUpdated);
              resolve(element);
            }
          });
        }
        else {
          //console.log('setupFixture: element ready without lang-updated');
          setTimeout(function () {
            if (params.lang === '' || params.lang === 'en') {
              element.fire('lang-updated');
            }
          }, 500);
          resolve(element);
        }
      }
      else {
        reject(new Error('setupFixture returns null for ' +
                          fixtureName + ' ' + JSON.stringify(fixtureModel,null,2)));
      }
    });
  }
}

function restoreFixture (fixtureName) {
  var e = document.querySelector('#' + fixtureName);
  if (!e) {
    throw new Error('Fixture element with id = ' + fixtureName + ' not found');
  }
  if (e.is === 'i18n-dom-bind') {
    if (e._intervalId) {
      clearInterval(e._intervalId);
    }
    Array.prototype.forEach.call(document.querySelectorAll('i18n-dom-bind'),
      function (node) {
        node.observeHtmlLang = true;
      }
    );
  }
  else {
    teardownFakeServer(e);
    e.restore();
  }
}

function getLocalDomRoot (e) {
  if (e.is === 'i18n-dom-bind') {
    return e.parentElement;
  }
  else if (e) {
    return e.root;
  }
  else {
    return null;
  }
}

function suitesRunner (suites) {

  suites.forEach(function (params) {

    suite(params.suite, function () {
      var el;
      var p;
      var n;
      var i, j;
      var expected;
      var results;
      var node;
      var rawValue = params.rawValue;
      var fixtureElement;
      var noProperties;
      var lang = params.assign && params.assign.lang ? params.assign.lang : 'en';
      var event = params.event ? params.event : 'lang-updated';
      var defTimeout = 300000;
      var timeout = params.timeout ? (params.timeout < defTimeout ? defTimeout : params.timeout) : defTimeout;
      this.timeout(timeout);

      (params.setup ? setup : suiteSetup)(function () {
        return setupFixture(params, params.fixtureModel)
          .then(function (element) {
            el = element;
            //console.log('setup: element.lang = ' + element.lang);
            return new Promise(function (resolve, reject) {
              //console.log(params.suite, 'waiting for ' + event);
              if (params &&
                  (params.event ||
                  params.assign && (params.assign.lang || params.assign['html.lang']))) {
                el.addEventListener(event, function fixtureSetup (e) {
                  if (el === Polymer.dom(e).rootTarget &&
                      el.lang === params.lang &&
                      el.effectiveLang === params.effectiveLang) {
                    el.removeEventListener(event, fixtureSetup);
                    //console.log('setup: updateProperty resolving on ' + event);
                    resolve(el);
                  }
                  else {
                    console.log(params.suite + ' skipping uninteresting event ' + event +
                      ' "' + el.lang + '" "' + params.lang + '" "' + el.effectiveLang + '" "' + params.effectiveLang + '"');
                  }
                });
                //console.log('setup: updateProperty ' + JSON.stringify(params.assign, null, 2));
                updateProperty(el, params.assign);
              }
              else {
                //console.log('setup: updateProperty ' + JSON.stringify(params.assign, null, 2));
                //console.log('setup: updateProperty resolving without ' + event);
                updateProperty(el, params.assign);
                resolve(el);
              }
            });
          }, function (error) {
            throw new Error(error);
          });
      });

      test('{lang, effectiveLang, templateDefaultLang, observeHtmlLang' +
            (params.text ? ', text' : '') +
            (params.model ? ', model' : '') +
            (params.localDOM ? ', local DOM' : '') +
            '} properties are set as {' + 
            (isSuppressingSuiteParams ? '' :
            [ params.lang, params.effectiveLang, params.templateDefaultLang, params.observeHtmlLang].join(', ') +
            (params.text ? ', ' + JSON.stringify(params.text, null, 2) : '') +
            (params.model ? ', ' + JSON.stringify(params.model, null, 2) : '') +
            (!params.setup && params.localDOM ? ', ' + JSON.stringify(params.localDOM, null, 2) : '')) +
            '}' +
            (params.assign && params.assign.lang ? ' for ' + params.assign.lang : ''), function () {
        assert.isString(el.lang, 'lang property is a string');
        assert.equal(el.lang, params.lang, 'lang property is set');
        assert.isString(el.effectiveLang, 'effectiveLang property is a string');
        assert.equal(el.effectiveLang, params.effectiveLang, 'effectiveLang property is set');
        assert.isString(el.templateDefaultLang, 'templateDefaultLang property is a string');
        assert.equal(el.templateDefaultLang, params.templateDefaultLang, 'templateDefaultLang property is set');
        assert.isBoolean(el.observeHtmlLang, 'observeHtmlLang property is a Boolean');
        assert.equal(el.observeHtmlLang, params.observeHtmlLang, 'observeHtmlLang property is set');
        if (params.text) {
          var actual;
          expected = deepMap(deepcopy(params.text), params.text, minifyText);
          actual = deepMap(deepcopy(el.text), el.text, minifyText);
          noProperties = true;
          assert.isObject(el.text, 'text property is an object');
          //console.log(JSON.stringify(e.detail, null, 2));
          //console.log(JSON.stringify(el.text, null, 2));
          for (p in expected) {
            if (p === 'meta') {
              continue;
            }
            noProperties = false;
            assert.deepEqual(actual[p],
              params.rawText ? expected[p] : translate(params.effectiveLang, null, expected[p]),
              'text.' + p + ' property is set for ' + params.effectiveLang);
          }
          if (noProperties) {
            assert.deepEqual(deepMap(deepcopy(el.text), el.text, minifyText),
              expected,
              'text property is set');
          }
        }
        if (params.model) {
          noProperties = true;
          assert.isObject(el.model, 'model property is an object');
          for (p in expected) {
            noProperties = false;
            //console.log('model.' + p + ' = ' + JSON.stringify(el.model[p]));
            //console.log('expected model.' + p + ' = ' + JSON.stringify(translate(el.effectiveLang, null, params.model[p])));
            assert.deepEqual(minifyText(el.model[p]),
              params.rawText ? params.model[p] : translate(params.effectiveLang, null, params.model[p]),
              'model.' + p + ' property is set for ' + params.effectiveLang);
          }
          if (noProperties) {
            assert.deepEqual(el.model, params.model, 'model property is set');
          }
        }
        if (!params.setup && params.localDOM) {
          params.localDOM.forEach(function (childPath) {
            var completeStatus;
            var nodes = Polymer.dom(getLocalDomRoot(el)).querySelectorAll(childPath.select);
            assert.ok(nodes.length > 0, childPath.select + ' is defined');
            for (var p in childPath) {
              if (p === 'select') {
                continue;
              }
              //console.log(p + ' is set as ' + childPath[p]);
              if (Array.isArray(childPath[p])) {
                //console.log(nodes);
                Array.prototype.forEach.call(childPath[p], function (path, i, a) {
                  assert.equal(minifyText(getProperty(nodes[i], p)),
                    minifyText(params.rawText ? path : translate(params.effectiveLang, p, path)),
                    p + ' is set as ' + minifyText(params.rawText ? path : translate(params.effectiveLang, p, path)));
                });
              }
              else {
                //console.log(nodes[0]);
                assert.equal(minifyText(getProperty(nodes[0], p)),
                  minifyText(params.rawText ? childPath[p] : translate(params.effectiveLang, p, childPath[p])),
                  p + ' is set as ' + translate(params.rawText ? childPath[p] : params.effectiveLang, p, childPath[p]));
              }
            }
            //console.log(childPath);
          });
        }
      });

/*
      if (params.text) {
        test('text' + ' property is set as ' + JSON.stringify(params.text,null,2) + 
          (params.assign && params.assign.lang ? ' for ' + params.assign.lang : ''), function () {
          expected = deepMap(deepcopy(params.text), params.text, minifyText);
          noProperties = true;
          assert.isObject(el.text, 'text property is an object');
          //console.log(JSON.stringify(e.detail, null, 2));
          //console.log(JSON.stringify(el.text, null, 2));
          for (p in expected) {
            noProperties = false;
            assert.deepEqual(deepMap(deepcopy(el.text[p]), el.text[p], minifyText),
              params.rawText ? expected[p] : translate(params.effectiveLang, null, expected[p]),
              'text.' + p + ' property is set for ' + params.effectiveLang);
          }
          if (noProperties) {
            assert.deepEqual(deepMap(deepcopy(el.text), el.text, minifyText),
              expected,
              'text property is set');
          }
        });
      }

      if (params.model) {
        test('model' + ' property is set as ' + JSON.stringify(params.model,null,2) + 
          (params.assign && params.assign.lang ? ' for ' + params.assign.lang : ''), function () {
          noProperties = true;
          assert.isObject(el.model, 'model property is an object');
          for (p in params.model) {
            noProperties = false;
            //console.log('model.' + p + ' = ' + JSON.stringify(el.model[p]));
            //console.log('expected model.' + p + ' = ' + JSON.stringify(translate(el.effectiveLang, null, params.model[p])));
            assert.deepEqual(el.model[p],
              params.rawText ? params.model[p] : translate(params.effectiveLang, null, params.model[p]),
              'model.' + p + ' property is set for ' + params.effectiveLang);
          }
          if (noProperties) {
            assert.deepEqual(el.model, params.model, 'model property is set');
          }
        });
      }
*/

      if (params.setup && params.localDOM) {
        test('local DOM ' + (isSuppressingSuiteParams ? '{}' : JSON.stringify(params.localDOM, null, 2)) + ' is set' + 
              (params.assign && params.assign.lang ? ' for ' + params.assign.lang : ''), function () {
          params.localDOM.forEach(function (childPath) {
            var completeStatus;
            var nodes = Polymer.dom(getLocalDomRoot(el)).querySelectorAll(childPath.select);
            assert.ok(nodes.length > 0, childPath.select + ' is defined');
            for (var p in childPath) {
              if (p === 'select') {
                continue;
              }
              //console.log(p + ' is set as ' + childPath[p]);
              if (Array.isArray(childPath[p])) {
                //console.log(nodes);
                Array.prototype.forEach.call(childPath[p], function (path, i, a) {
                  assert.equal(minifyText(getProperty(nodes[i], p)),
                    minifyText(params.rawText ? path : translate(params.effectiveLang, p, path)),
                    p + ' is set as ' + minifyText(params.rawText ? path : translate(params.effectiveLang, p, path)));
                });
              }
              else {
                //console.log(nodes[0]);
                assert.equal(minifyText(getProperty(nodes[0], p)),
                  minifyText(params.rawText ? childPath[p] : translate(params.effectiveLang, p, childPath[p])),
                  p + ' is set as ' + translate(params.rawText ? childPath[p] : params.effectiveLang, p, childPath[p]));
              }
            }
            //console.log(childPath);
          });
        });
      }

      if (params.lightDOM) {
        test('light DOM ' + (isSuppressingSuiteParams ? '{}' : JSON.stringify(params.lightDOM, null, 2)) + ' is set' + 
              (params.assign && params.assign.lang ? ' for ' + params.assign.lang : ''), function () {
          params.lightDOM.forEach(function (childPath) {
            var completeStatus;
            var nodes = Polymer.dom(el).querySelectorAll(childPath.select);
            assert.ok(nodes.length > 0, childPath.select + ' is defined');
            for (var p in childPath) {
              if (p === 'select') {
                continue;
              }
              //console.log(p + ' is set as ' + childPath[p]);
              if (Array.isArray(childPath[p])) {
                //console.log(nodes);
                Array.prototype.forEach.call(childPath[p], function (path, i, a) {
                  assert.equal(getProperty(nodes[i], p), translate(params.effectiveLang, p, path), p + ' is set as ' + translate(params.effectiveLang, p, path));
                });
              }
              else {
                //console.log(nodes[0]);
                assert.equal(getProperty(nodes[0], p), translate(params.effectiveLang, p, childPath[p]), p + ' is set as ' + translate(params.effectiveLang, p, childPath[p]));
              }
            }
            //console.log(childPath);
          });
        });
      }

      (params.setup ? teardown : suiteTeardown)(function () {
        restoreFixture(params.fixture);
      });
    });
  });
}
</script>
<script>(function(){
/*

Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
*/
'use strict';var l={};function m(){this.end=this.start=0;this.rules=this.parent=this.previous=null;this.cssText=this.parsedCssText="";this.atRule=!1;this.type=0;this.parsedSelector=this.selector=this.keyframesName=""}
function p(a){a=a.replace(aa,"").replace(ba,"");var c=q,b=a,d=new m;d.start=0;d.end=b.length;for(var e=d,f=0,h=b.length;f<h;f++)if("{"===b[f]){e.rules||(e.rules=[]);var g=e,k=g.rules[g.rules.length-1]||null,e=new m;e.start=f+1;e.parent=g;e.previous=k;g.rules.push(e)}else"}"===b[f]&&(e.end=f+1,e=e.parent||d);return c(d,a)}
function q(a,c){var b=c.substring(a.start,a.end-1);a.parsedCssText=a.cssText=b.trim();a.parent&&((b=c.substring(a.previous?a.previous.end:a.parent.start,a.start-1),b=ca(b),b=b.replace(r," "),b=b.substring(b.lastIndexOf(";")+1),b=a.parsedSelector=a.selector=b.trim(),a.atRule=!b.indexOf("@"),a.atRule)?b.indexOf("@media")?b.match(da)&&(a.type=u,a.keyframesName=a.selector.split(r).pop()):a.type=t:a.type=b.indexOf("--")?v:y);if(b=a.rules)for(var d=0,e=b.length,f;d<e&&(f=b[d]);d++)q(f,c);return a}
function ca(a){return a.replace(/\\([0-9a-f]{1,6})\s/gi,function(a,b){a=b;for(b=6-a.length;b--;)a="0"+a;return"\\"+a})}
function z(a,c,b){b=void 0===b?"":b;var d="";if(a.cssText||a.rules){var e=a.rules,f;if(f=e)f=e[0],f=!(f&&f.selector&&0===f.selector.indexOf("--"));if(f){f=0;for(var h=e.length,g;f<h&&(g=e[f]);f++)d=z(g,c,d)}else c?c=a.cssText:(c=a.cssText,c=c.replace(ea,"").replace(fa,""),c=c.replace(ga,"").replace(ha,"")),(d=c.trim())&&(d="  "+d+"\n")}d&&(a.selector&&(b+=a.selector+" {\n"),b+=d,a.selector&&(b+="}\n\n"));return b}
var v=1,u=7,t=4,y=1E3,aa=/\/\*[^*]*\*+([^/*][^*]*\*+)*\//gim,ba=/@import[^;]*;/gim,ea=/(?:^[^;\-\s}]+)?--[^;{}]*?:[^{};]*?(?:[;\n]|$)/gim,fa=/(?:^[^;\-\s}]+)?--[^;{}]*?:[^{};]*?{[^}]*?}(?:[;\n]|$)?/gim,ga=/@apply\s*\(?[^);]*\)?\s*(?:[;\n]|$)?/gim,ha=/[^;:]*?:[^;]*?var\([^;]*\)(?:[;\n]|$)?/gim,da=/^@[^\s]*keyframes/,r=/\s+/g;var ia=Promise.resolve();function ja(a){(a=l[a])&&(a._applyShimInvalid=!0)}function ka(a){a.a||(a.a=!0,ia.then(function(){a._applyShimInvalid=!1;a.a=!1}))};var A=/(?:^|[;\s{]\s*)(--[\w-]*?)\s*:\s*(?:([^;{]*)|{([^}]*)})(?:(?=[;\s}])|$)/gi,B=/(?:^|\W+)@apply\s*\(?([^);\n]*)\)?/gi,la=/@media[^(]*(\([^)]*\))/;var C=!(window.ShadyDOM&&window.ShadyDOM.inUse),D=!navigator.userAgent.match("AppleWebKit/601")&&window.CSS&&CSS.supports&&CSS.supports("box-shadow","0 0 0 var(--foo)");function E(a){a&&(D=D&&!a.nativeCss&&!a.shimcssproperties,C=C&&!a.nativeShadow&&!a.shimshadow)}window.ShadyCSS?E(window.ShadyCSS):window.WebComponents&&E(window.WebComponents.flags);var ma=C,F=D;function G(a){if(!a)return"";"string"===typeof a&&(a=p(a));return z(a,F)}function H(a){!a.__cssRules&&a.textContent&&(a.__cssRules=p(a.textContent));return a.__cssRules||null}function I(a,c,b,d){if(a){var e=!1,f=a.type;if(d&&f===t){var h=a.selector.match(la);h&&(window.matchMedia(h[1]).matches||(e=!0))}f===v?c(a):b&&f===u?b(a):f===y&&(e=!0);if((a=a.rules)&&!e)for(var e=0,f=a.length,g;e<f&&(g=a[e]);e++)I(g,c,b,d)}}
function J(a,c){var b=a.indexOf("var(");if(-1===b)return c(a,"","","");var d;a:{var e=0;d=b+3;for(var f=a.length;d<f;d++)if("("===a[d])e++;else if(")"===a[d]&&!--e)break a;d=-1}e=a.substring(b+4,d);b=a.substring(0,b);a=J(a.substring(d+1),c);d=e.indexOf(",");return-1===d?c(b,e.trim(),"",a):c(b,e.substring(0,d).trim(),e.substring(d+1).trim(),a)};var na=/;\s*/m,oa=/^\s*(initial)|(inherit)\s*$/;function K(){this.a={}}K.prototype.set=function(a,c){a=a.trim();this.a[a]={h:c,i:{}}};K.prototype.get=function(a){a=a.trim();return this.a[a]||null};var L=null;function M(){this.b=this.c=null;this.a=new K}M.prototype.o=function(a){a=B.test(a)||A.test(a);B.lastIndex=0;A.lastIndex=0;return a};M.prototype.m=function(a,c){a=a.content.querySelector("style");var b=null;a&&(b=this.j(a,c));return b};
M.prototype.j=function(a,c){c=void 0===c?"":c;var b=H(a);this.l(b,c);a.textContent=G(b);return b};M.prototype.f=function(a){var c=this,b=H(a);I(b,function(a){":root"===a.selector&&(a.selector="html");c.g(a)});a.textContent=G(b);return b};M.prototype.l=function(a,c){var b=this;this.c=c;I(a,function(a){b.g(a)});this.c=null};M.prototype.g=function(a){a.cssText=pa(this,a.parsedCssText);":root"===a.selector&&(a.selector=":host > *")};
function pa(a,c){c=c.replace(A,function(c,d,e,f){return qa(a,c,d,e,f)});return N(a,c)}function N(a,c){for(var b;b=B.exec(c);){var d=b[0],e=b[1];b=b.index;var f=c.slice(0,b+d.indexOf("@apply"));c=c.slice(b+d.length);var h=O(a,f),g,k,d=void 0;g=a;var e=e.replace(na,""),n=[];k=g.a.get(e);k||(g.a.set(e,{}),k=g.a.get(e));if(k)for(d in g.c&&(k.i[g.c]=!0),k.h)g=h&&h[d],k=[d,": var(",e,"_-_",d],g&&k.push(",",g),k.push(")"),n.push(k.join(""));d=n.join("; ");c=""+f+d+c;B.lastIndex=b+d.length}return c}
function O(a,c){c=c.split(";");for(var b,d,e={},f=0,h;f<c.length;f++)if(b=c[f])if(h=b.split(":"),1<h.length){b=h[0].trim();var g=a;d=b;h=h.slice(1).join(":");var k=oa.exec(h);k&&(k[1]?(g.b||(g.b=document.createElement("meta"),g.b.setAttribute("apply-shim-measure",""),g.b.style.all="initial",document.head.appendChild(g.b)),d=window.getComputedStyle(g.b).getPropertyValue(d)):d="apply-shim-inherit",h=d);d=h;e[b]=d}return e}function ra(a,c){if(L)for(var b in c.i)b!==a.c&&L(b)}
function qa(a,c,b,d,e){d&&J(d,function(c,b){b&&a.a.get(b)&&(e="@apply "+b+";")});if(!e)return c;var f=N(a,e),h=c.slice(0,c.indexOf("--")),g=f=O(a,f),k=a.a.get(b),n=k&&k.h;n?g=Object.assign(Object.create(n),f):a.a.set(b,g);var W=[],w,x,X=!1;for(w in g)x=f[w],void 0===x&&(x="initial"),!n||w in n||(X=!0),W.push(""+b+"_-_"+w+": "+x);X&&ra(a,k);k&&(k.h=g);d&&(h=c+";"+h);return""+h+W.join("; ")+";"}M.prototype.detectMixin=M.prototype.o;M.prototype.transformStyle=M.prototype.j;
M.prototype.transformCustomStyle=M.prototype.f;M.prototype.transformRules=M.prototype.l;M.prototype.transformRule=M.prototype.g;M.prototype.transformTemplate=M.prototype.m;M.prototype._separator="_-_";Object.defineProperty(M.prototype,"invalidCallback",{get:function(){return L},set:function(a){L=a}});var P=null,Q=window.HTMLImports&&window.HTMLImports.whenReady||null,R;function sa(a){Q?Q(a):(P||(P=new Promise(function(a){R=a}),"complete"===document.readyState?R():document.addEventListener("readystatechange",function(){"complete"===document.readyState&&R()})),P.then(function(){a&&a()}))};var S=new M;function T(){var a=this;this.a=null;this.b=!1;sa(function(){U(a)});S.invalidCallback=ja}function U(a){a.b||(a.a=window.ShadyCSS.CustomStyleInterface,a.a&&(a.a.transformCallback=function(a){S.f(a)},a.a.validateCallback=function(){requestAnimationFrame(function(){a.a.enqueued&&V(a)})}),a.b=!0)}T.prototype.prepareTemplate=function(a,c){U(this);l[c]=a;c=S.m(a,c);a._styleAst=c};
function V(a){U(a);if(a.a){for(var c=a.a.processStyles(),b=0;b<c.length;b++){var d=a.a.getStyleForCustomStyle(c[b]);d&&S.f(d)}a.a.enqueued=!1}}T.prototype.styleSubtree=function(a,c){U(this);if(c)for(var b in c)null===b?a.style.removeProperty(b):a.style.setProperty(b,c[b]);if(a.shadowRoot)for(this.styleElement(a),a=a.shadowRoot.children||a.shadowRoot.childNodes,c=0;c<a.length;c++)this.styleSubtree(a[c]);else for(a=a.children||a.childNodes,c=0;c<a.length;c++)this.styleSubtree(a[c])};
T.prototype.styleElement=function(a){U(this);var c=a.localName,b;c?-1<c.indexOf("-")?b=c:b=a.getAttribute&&a.getAttribute("is")||"":b=a.is;(c=l[b])&&c._applyShimInvalid&&(c.a||(this.prepareTemplate(c,b),ka(c)),a=a.shadowRoot)&&(a=a.querySelector("style"))&&(a.__cssRules=c._styleAst,a.textContent=G(c._styleAst))};T.prototype.styleDocument=function(a){U(this);this.styleSubtree(document.body,a)};
if(!window.ShadyCSS||!window.ShadyCSS.ScopingShim){var Y=new T,Z=window.ShadyCSS&&window.ShadyCSS.CustomStyleInterface;window.ShadyCSS={prepareTemplate:function(a,c){V(Y);Y.prepareTemplate(a,c)},styleSubtree:function(a,c){V(Y);Y.styleSubtree(a,c)},styleElement:function(a){V(Y);Y.styleElement(a)},styleDocument:function(a){V(Y);Y.styleDocument(a)},getComputedStyleValue:function(a,c){return(a=window.getComputedStyle(a).getPropertyValue(c))?a.trim():""},nativeCss:F,nativeShadow:ma};Z&&(window.ShadyCSS.CustomStyleInterface=
Z)}window.ShadyCSS.ApplyShim=S;
}).call(self)

//# sourceMappingURL=apply-shim.min.js.map
</script>
<script>

  window.Polymer = function(info) {
    return window.Polymer._polymerFn(info);
  }
  // To be plugged by legacy implementation if loaded
  window.Polymer._polymerFn = function() {
    throw new Error('Load polymer.html to use the Polymer() function.');
  }
  window.Polymer.version = '2.0-preview';

  /* eslint-disable no-unused-vars */
  /*
  When using Closure Compiler, goog.reflect.objectProperty(property, object) is replaced by the munged name for object[property]
  We cannot alias this function, so we have to use a small shim that has the same behavior when not compiling.
  */
  var goog = {
    reflect: {
      objectProperty(s, o) {
        return s;
      }
    }
  }
  /* eslint-enable */
</script>
<script>

(function() {

  'use strict';

  // unique global id for deduping mixins.
  let dedupeId = 0;

  /**
   * Given a mixin producing function, memoize applications of mixin to base
   * @private
   */
  function cachingMixin(mixin) {
    return function(base) {
      if (!mixin.__mixinApplications) {
        mixin.__mixinApplications = new WeakMap();
      }
      let map = mixin.__mixinApplications;
      let application = map.get(base);
      if (!application) {
        application = mixin(base);
        map.set(base, application);
      }
      return application;
    };
  }

  /**
   * Copies props from a source object to a target object.
   *
   * Note, this method uses a simple `for...in` strategy for enumerating
   * properties.  To ensure only `ownProperties` are copied from source
   * to target and that accessor implementations are copied, use `extend`.
   *
   * @method mixin
   * @param {Object} target Target object to copy properties to.
   * @param {Object} source Source object to copy properties from.
   * @return {Object} Target object that was passed as first argument.
   */
  Polymer.mixin = function(target, source) {
    for (let i in source) {
      target[i] = source[i];
    }
    return target;
  };

  /**
   * Given a mixin producing function, only apply mixin if has not already been applied to base
   * Also memoize mixin applications
   */
  Polymer.dedupingMixin = function(mixin) {
    mixin = cachingMixin(mixin);
    // maintain a unique id for each mixin
    if (!mixin.__id) {
      mixin.__dedupeId = ++dedupeId;
    }
    return function(base) {
      let baseSet = base.__mixinSet;
      if (baseSet && baseSet[mixin.__dedupeId]) {
        return base;
      }
      let extended = mixin(base);
      // copy inherited mixin set from the extended class, or the base class
      // NOTE: we avoid use of Set here because some browser (IE11)
      // cannot extend a base Set via the constructor.
      extended.__mixinSet =
        Object.create(extended.__mixinSet || baseSet || null);
      extended.__mixinSet[mixin.__dedupeId] = true;
      return extended;
    }
  };

})();

</script>
<script>
(function() {

  const CaseMap = {

    _caseMap: {},
    _rx: {
      dashToCamel: /-[a-z]/g,
      camelToDash: /([A-Z])/g
    },

    dashToCamelCase: function(dash) {
      return this._caseMap[dash] || (
        this._caseMap[dash] = dash.indexOf('-') < 0 ? dash : dash.replace(this._rx.dashToCamel,
          function(m) {
            return m[1].toUpperCase();
          }
        )
      );
    },

    camelToDashCase: function(camel) {
      return this._caseMap[camel] || (
        this._caseMap[camel] = camel.replace(this._rx.camelToDash, '-$1').toLowerCase()
      );
    }

  };

  Polymer.CaseMap = CaseMap;
})();
</script>
<script>

  (function() {

    // path fixup for urls in cssText that's expected to
    // come from a given ownerDocument
    function resolveCss(cssText, ownerDocument) {
      return cssText.replace(CSS_URL_RX, function(m, pre, url, post) {
        return pre + '\'' +
          resolve(url.replace(/["']/g, ''), ownerDocument) +
          '\'' + post;
      });
    }

    // url fixup for urls in an element's attributes made relative to
    // ownerDoc's base url
    function resolveAttrs(element, ownerDocument) {
      for (var name in URL_ATTRS) {
        var a$ = URL_ATTRS[name];
        for (var i=0, l=a$.length, a, at, v; (i<l) && (a=a$[i]); i++) {
          if (name === '*' || element.localName === name) {
            at = element.attributes[a];
            v = at && at.value;
            if (v && (v.search(BINDING_RX) < 0)) {
              at.value = (a === 'style') ?
                resolveCss(v, ownerDocument) :
                resolve(v, ownerDocument);
            }
          }
        }
      }
    }

    function resolve(url, ownerDocument) {
      // do not resolve '#' links, they are used for routing
      if (url && ABS_URL.test(url)) {
        return url;
      }
      var resolver = getUrlResolver(ownerDocument);
      resolver.href = url;
      return resolver.href || url;
    }

    var tempDoc;
    var tempDocBase;
    function resolveUrl(url, baseUri) {
      if (!tempDoc) {
        tempDoc = document.implementation.createHTMLDocument('temp');
        tempDocBase = tempDoc.createElement('base');
        tempDoc.head.appendChild(tempDocBase);
      }
      tempDocBase.href = baseUri;
      return resolve(url, tempDoc);
    }

    function getUrlResolver(ownerDocument) {
      return ownerDocument.__urlResolver ||
        (ownerDocument.__urlResolver = ownerDocument.createElement('a'));
    }

    var CSS_URL_RX = /(url\()([^)]*)(\))/g;
    var URL_ATTRS = {
      '*': ['href', 'src', 'style', 'url'],
      form: ['action']
    };
    var ABS_URL = /(^\/)|(^#)|(^[\w-\d]*:)/;
    var BINDING_RX = /\{\{|\[\[/;

    // exports
    Polymer.ResolveUrl = {
      resolveCss: resolveCss,
      resolveAttrs: resolveAttrs,
      resolveUrl: resolveUrl
    };

  })();

</script>
<script>
(function() {
  'use strict';

  let MODULE_STYLES_SELECTOR = 'style, link[rel=import][type~=css], template';
  let INCLUDE_ATTR = 'include';

  function importModule(moduleId) {
    if (!Polymer.DomModule) {
      return null;
    }
    return Polymer.DomModule.import(moduleId);
  }

  let StyleGather = {

    /**
     * @param {string} moduleIds
     * @param {boolean=} warnIfNotFound
     * @return {string}
     */
    cssFromModules(moduleIds, warnIfNotFound) {
      let modules = moduleIds.trim().split(' ');
      let cssText = '';
      for (let i=0; i < modules.length; i++) {
        cssText += this.cssFromModule(modules[i], warnIfNotFound);
      }
      return cssText;
    },

    // returns cssText of styles in a given module; also un-applies any
    // styles that apply to the document.
    cssFromModule(moduleId, warnIfNotFound) {
      let m = importModule(moduleId);
      if (m && !m._cssText) {
        m._cssText = this.cssFromElement(m);
      }
      if (!m && warnIfNotFound) {
        console.warn('Could not find style data in module named', moduleId);
      }
      return m && m._cssText || '';
    },

    // support lots of ways to discover css...
    cssFromElement(element) {
      let cssText = '';
      // if element is a template, get content from its .content
      let content = element.content || element;
      let e$ = content.querySelectorAll(MODULE_STYLES_SELECTOR);
      for (let i=0, e; i < e$.length; i++) {
        e = e$[i];
        // look inside templates for elements
        if (e.localName === 'template') {
          cssText += this.cssFromElement(e);
        } else {
          // style elements inside dom-modules will apply to the main document
          // we don't want this, so we remove them here.
          if (e.localName === 'style') {
            let include = e.getAttribute(INCLUDE_ATTR);
            // now support module refs on 'styling' elements
            if (include) {
              cssText += this.cssFromModules(include, true);
            }
            // get style element applied to main doc via HTMLImports polyfill
            e = e.__appliedElement || e;
            e.parentNode.removeChild(e);
            cssText += Polymer.ResolveUrl.resolveCss(e.textContent, element.ownerDocument);
            // it's an import, assume this is a text file of css content.
            // TODO(sorvell): plan is to deprecate this way to get styles;
            // remember to add deprecation warning when this is done.
          } else if (e.import && e.import.body) {
            cssText += Polymer.ResolveUrl.resolveCss(e.import.body.textContent, e.import);
          }
        }
      }
      return cssText;
    }
  };

  Polymer.StyleGather = StyleGather;
})();
</script>
<script>

(function() {

  let modules = {};
  let lcModules = {};
  function findModule(id) {
    return modules[id] || lcModules[id.toLowerCase()];
  }

  function styleOutsideTemplateCheck(inst) {
    if (inst.querySelector('style')) {
      console.warn('dom-module %s has style outside template', inst.id);
    }
  }

  /**
   * The `dom-module` element registers the dom it contains to the name given
   * by the module's id attribute. It provides a unified database of dom
   * accessible via any dom-module element. Use the `import(id, selector)`
   * method to locate dom within this database. For example,
   *
   * <dom-module id="foo">
   *   <img src="stuff.png">
   * </dom-module>
   *
   * Then in code in some other location that cannot access the dom-module above
   *
   * let img = document.createElement('dom-module').import('foo', 'img');
   *
   */
  class DomModule extends HTMLElement {

    static get observedAttributes() { return ['id'] }

    attributeChangedCallback(name, old, value) {
      if (old !== value) {
        this.register();
      }
    }

    get assetpath() {
      // Don't override existing assetpath.
      if (!this.__assetpath) {
        // note: assetpath set via an attribute must be relative to this
        // element's location; accomodate polyfilled HTMLImports
        const owner = window.HTMLImports && HTMLImports.importForElement ?
          HTMLImports.importForElement(this) || document : this.ownerDocument;
        this.__assetpath = Polymer.ResolveUrl.resolveUrl(
          this.getAttribute('assetpath') || '', owner.baseURI);
      }
      return this.__assetpath;
    }

    /**
     * Registers the dom-module at a given id. This method should only be called
     * when a dom-module is imperatively created. For
     * example, `document.createElement('dom-module').register('foo')`.
     * @method register
     * @param {string=} id The id at which to register the dom-module.
     */
    register(id) {
      id = id || this.id;
      if (id) {
        this.id = id;
        // store id separate from lowercased id so that
        // in all cases mixedCase id will stored distinctly
        // and lowercase version is a fallback
        modules[id] = this;
        lcModules[id.toLowerCase()] = this;
        styleOutsideTemplateCheck(this);
      }
    }

    /**
     * Retrieves the dom specified by `selector` in the module specified by
     * `id`. For example, this.import('foo', 'img');
     * @method register
     * @param {string} id
     * @param {string=} selector
     * @return {Element} Returns the dom which matches `selector` in the module
     * at the specified `id`.
     */
    import(id, selector) {
      if (id) {
        let m = findModule(id);
        if (m && selector) {
          return m.querySelector(selector);
        }
        return m;
      }
      return null;
    }

  }

  DomModule.prototype['modules'] = modules;

  customElements.define('dom-module', DomModule);

  // export
  Polymer.DomModule = new DomModule();

})();

</script>
<script>
(function() {

  const Path = {

    isPath: function(path) {
      return path.indexOf('.') >= 0;
    },

    root: function(path) {
      var dotIndex = path.indexOf('.');
      if (dotIndex === -1) {
        return path;
      }
      return path.slice(0, dotIndex);
    },

    // Given `base` is `foo.bar`, `foo` is an ancestor, `foo.bar` is not
    isAncestor: function(base, path) {
      //     base.startsWith(path + '.');
      return base.indexOf(path + '.') === 0;
    },

    // Given `base` is `foo.bar`, `foo.bar.baz` is an descendant
    isDescendant: function(base, path) {
      //     path.startsWith(base + '.');
      return path.indexOf(base + '.') === 0;
    },

    // can be read as:  from  to       path
    translate: function(base, newBase, path) {
      // Defense?
      return newBase + path.slice(base.length);
    },

    matches: function(base, path) {
      return (base === path) ||
             this.isAncestor(base, path) ||
             this.isDescendant(base, path);
    },

    /**
     * Converts array-based paths to flattened path
     * @param {string | !Array<string|number>} path
     * @return {string}
     */
    normalize: function(path) {
      if (Array.isArray(path)) {
        var parts = [];
        for (var i=0; i<path.length; i++) {
          var args = path[i].toString().split('.');
          for (var j=0; j<args.length; j++) {
            parts.push(args[j]);
          }
        }
        return parts.join('.');
      } else {
        return path;
      }
    },

    /**
     * Split a path into an array
     * @param {string | !Array<string|number>} path
     * @return {!Array<string>}
     */
    split: function(path) {
      if (Array.isArray(path)) {
        return this.normalize(path).split('.');
      }
      return path.toString().split('.');
    },

    /**
     * @param {Object} root
     * @param {string | !Array<string|number>} path
     * @param {Object=} info
     * @return {*}
     */
    get: function(root, path, info) {
      var prop = root;
      var parts = this.split(path);
      // Loop over path parts[0..n-1] and dereference
      for (var i=0; i<parts.length; i++) {
        if (!prop) {
          return;
        }
        var part = parts[i];
        prop = prop[part];
      }
      if (info) {
        info.path = parts.join('.');
      }
      return prop;
    },

    /**
     * @param {Object} root
     * @param {string | !Array<string|number>} path
     * @param {*} value
     * @return {string | undefined}
     */
    set: function(root, path, value) {
      var prop = root;
      var parts = this.split(path);
      var last = parts[parts.length-1];
      if (parts.length > 1) {
        // Loop over path parts[0..n-2] and dereference
        for (var i=0; i<parts.length-1; i++) {
          var part = parts[i];
          prop = prop[part];
          if (!prop) {
            return;
          }
        }
        // Set value to object at end of path
        prop[last] = value;
      } else {
        // Simple property set
        prop[path] = value;
      }
      return parts.join('.');
    }

  };

  // BC API
  Path.isDeep = Path.isPath;

  Polymer.Path = Path;
  
})();
</script>
<script>
(function(global) {

  'use strict';

  Polymer.Async = {};

  /**
   * A timer with the async interface.
   */
  Polymer.Async.timeOut = {
    after: function(delay) {
      return delay === 0 ? Polymer.Async.timeOut :
      {
        run: function(fn) {
          return global.setTimeout(fn, delay);
        },
        cancel: global.clearTimeout.bind(global)
      }
    },
    run: global.setTimeout.bind(global),
    cancel: global.clearTimeout.bind(global)
  };

  /**
   * requestAnimationFrame with the async interface.
   */
  Polymer.Async.animationFrame = {
    run:  global.requestAnimationFrame.bind(global),
    cancel: global.cancelAnimationFrame.bind(global)
  };

  /**
   * requestIdleCallback with the async interface.
   */
  Polymer.Async.idlePeriod = {
    run(fn) {
      return global.requestIdleCallback ? global.requestIdleCallback(fn) : global.setTimeout(fn, 16);
    },
    cancel(timer) {
      return global.cancelIdleCallback ? global.cancelIdleCallback(timer) : global.clearTimeout(timer);
    }
  };

  /**
   * Micro task with the async interface.
   */
  Polymer.Async.microTask = {
    _currVal: 0,
    _lastVal: 0,
    _callbacks: [],
    _twiddleContent: 0,
    _twiddle: document.createTextNode(''),

    run(callback) {
      this._twiddle.textContent = this._twiddleContent++;
      this._callbacks.push(callback);
      return this._currVal++;
    },

    cancel(handle) {
      const idx = handle - this._lastVal;
      if (idx >= 0) {
        if (!this._callbacks[idx]) {
          throw 'invalid async handle: ' + handle;
        }
        this._callbacks[idx] = null;
      }
    },

    _atEndOfMicrotask() {
      const len = this._callbacks.length;
      for (let i=0; i<len; i++) {
        let cb = this._callbacks[i];
        if (cb) {
          try {
            cb();
          } catch(e) {
            // Clear queue up to this point & start over after throwing
            i++;
            this._callbacks.splice(0, i);
            this._lastVal += i;
            this._twiddle.textContent = this._twiddleContent++;
            throw e;
          }
        }
      }
      this._callbacks.splice(0, len);
      this._lastVal += len;
    },

    flush() {
      this._observer.takeRecords();
      this._atEndOfMicrotask();
    }
  };

  Polymer.Async.microTask._observer = new window.MutationObserver(function microTaskObserver() {
    Polymer.Async.microTask._atEndOfMicrotask();
  });
  Polymer.Async.microTask._observer.observe(Polymer.Async.microTask._twiddle, {characterData: true});

})(this);
</script>
<script>
(function() {

  'use strict';

  var caseMap = Polymer.CaseMap;

  var microtask = Polymer.Async.microTask;

  // Save map of native properties; this forms a blacklist or properties
  // that won't have their values "saved" by `saveAccessorValue`, since
  // reading from an HTMLElement accessor from the context of a prototype throws
  const nativeProperties = {};
  let proto = HTMLElement.prototype;
  while (proto) {
    let props = Object.getOwnPropertyNames(proto);
    for (let i=0; i<props.length; i++) {
      nativeProperties[props[i]] = true;
    }
    proto = Object.getPrototypeOf(proto);
  }

  /**
   * Used to save the value of a property that will be overridden with
   * an accessor. If the `model` is a prototype, the values will be saved
   * in `__dataProto`, and it's up to the user (or downstream mixin) to
   * decide how/when to set these values back into the accessors.
   * If `model` is already an instance (it has a `__data` property), then
   * the value will be set as a pending property, meaning the user should
   * call `_invalidateProperties` or `_flushProperties` to take effect
   *
   * @param {Object} model Prototype or instance
   * @param {string} property Name of property
   * @private
   */
  function saveAccessorValue(model, property) {
    // Don't read/store value for any native properties since they could throw
    if (!nativeProperties[property]) {
      let value = model[property];
      if (value !== undefined) {
        if (model.__data) {
          // Adding accessor to instance; update the property
          // It is the user's responsibility to call _flushProperties
          model._setPendingProperty(property, value);
        } else {
          // Adding accessor to proto; save proto's value for instance-time use
          if (!model.__dataProto) {
            model.__dataProto = {};
          } else if (!model.hasOwnProperty(goog.reflect.objectProperty('__dataProto', model))) {
            model.__dataProto = Object.create(model.__dataProto);
          }
          model.__dataProto[property] = value;
        }
      }
    }
  }

  Polymer.PropertyAccessors = Polymer.dedupingMixin(function(superClass) {

    return class PropertyAccessors extends superClass {

      static createPropertiesForAttributes() {
        let a$ = this.observedAttributes;
        for (let i=0; i < a$.length; i++) {
          this.prototype._createPropertyAccessor(caseMap.dashToCamelCase(a$[i]));
        }
      }

      constructor() {
        super();
        this._initializeProperties();
      }

      attributeChangedCallback(name, old, value) {
        if (old !== value) {
          this._attributeToProperty(name, value);
        }
      }

      /**
       * Initializes the local storage for property accessors.
       *
       * Default initialization via initializing
       * local property & pending data storage with any accessor values saved
       * in `__dataProto`.  If instance properties had been set before the
       * element upgraded and gained accessors on its prototype, these values
       * are set into the prototype's accessors after being deleted from the
       * instance.
       *
       * @protected
       */
      _initializeProperties() {
        this.__serializing = false;
        this.__dataCounter = 0;
        this.__dataInvalid = false;
        // initialize data with prototype values saved when creating accessors
        this.__data = {};
        this.__dataPending = null;
        this.__dataOld = null;
        if (this.__dataProto) {
          this._initializeProtoProperties(this.__dataProto);
        }
      }

      _initializeProtoProperties(props) {
        for (let p in props) {
          this._setProperty(p, props[p]);
        }
      }

      /**
       * Ensures the element has the given attribute. If it does not,
       * assigns the given value to the attribute.
       *
       *
       * @method _ensureAttribute
       * @param {string} attribute Name of attribute to ensure is set.
       * @param {string} value of the attribute.
       */
      _ensureAttribute(attribute, value) {
        if (!this.hasAttribute(attribute)) {
          this._valueToNodeAttribute(this, value, attribute);
        }
      }

      /**
       * Deserializes an attribute to its associated property.
       *
       * This method calls the `_deserializeValue` method to convert the string to
       * a typed value.
       *
       * @method _attributeToProperty
       * @param {string} attribute Name of attribute to deserialize.
       * @param {string} value of the attribute.
       * @param {*} type type to deserialize to.
       */
      _attributeToProperty(attribute, value, type) {
        // Don't deserialize back to property if currently reflecting
        if (!this.__serializing) {
          var property = caseMap.dashToCamelCase(attribute);
          this[property] = this._deserializeValue(value, type);
        }
      }

      /**
       * Serializes a property to its associated attribute.
       *
       * @method _propertyToAttribute
       * @param {string} property Property name to reflect.
       * @param {string=} attribute Attribute name to reflect.
       * @param {*=} value Property value to refect.
       */
      _propertyToAttribute(property, attribute, value) {
        this.__serializing = true;
        value = (arguments.length < 3) ? this[property] : value;
        this._valueToNodeAttribute(this, value,
          attribute || caseMap.camelToDashCase(property));
        this.__serializing = false;
      }

      /**
       * Sets a typed value to an HTML attribute on a node.
       *
       * This method calls the `_serializeValue` method to convert the typed
       * value to a string.  If the `_serializeValue` method returns `undefined`,
       * the attribute will be removed (this is the default for boolean
       * type `false`).
       *
       * @method _valueToNodeAttribute
       * @param {Element} node Element to set attribute to.
       * @param {*} value Value to serialize.
       * @param {string} attribute Attribute name to serialize to.
       */
      _valueToNodeAttribute(node, value, attribute) {
        var str = this._serializeValue(value);
        if (str === undefined) {
          node.removeAttribute(attribute);
        } else {
          node.setAttribute(attribute, str);
        }
      }

      /**
       * Converts a typed value to a string.
       *
       * This method is called by Polymer when setting JS property values to
       * HTML attributes.  Users may override this method on Polymer element
       * prototypes to provide serialization for custom types.
       *
       * @method _serializeValue
       * @param {*} value Property value to serialize.
       * @return {string | undefined} String serialized from the provided property value.
       */
      _serializeValue(value) {
        /* eslint-disable no-fallthrough */
        switch (typeof value) {
          case 'boolean':
            return value ? '' : undefined;

          case 'object':
            if (value instanceof Date) {
              return value.toString();
            } else if (value) {
              try {
                return JSON.stringify(value);
              } catch(x) {
                return '';
              }
            }

          default:
            return value != null ? value.toString() : undefined;
        }
      }

      /**
       * Converts a string to a typed value.
       *
       * This method is called by Polymer when reading HTML attribute values to
       * JS properties.  Users may override this method on Polymer element
       * prototypes to provide deserialization for custom `type`s.  Note,
       * the `type` argument is the value of the `type` field provided in the
       * `properties` configuration object for a given property, and is
       * by convention the constructor for the type to deserialize.
       *
       * Note: The return value of `undefined` is used as a sentinel value to
       * indicate the attribute should be removed.
       *
       * @method _deserializeValue
       * @param {string} value Attribute value to deserialize.
       * @param {*} type Type to deserialize the string to.
       * @return {*} Typed value deserialized from the provided string.
       */
      _deserializeValue(value, type) {
        /**
         * @type {*}
         */
        let outValue;
        switch (type) {
          case Number:
            outValue = Number(value);
            break;

          case Boolean:
            outValue = (value !== null);
            break;

          case Object:
            try {
              outValue = JSON.parse(value);
            } catch(x) {
              // allow non-JSON literals like Strings and Numbers
            }
            break;

          case Array:
            try {
              outValue = JSON.parse(value);
            } catch(x) {
              outValue = null;
              console.warn('Polymer::Attributes: couldn`t decode Array as JSON');
            }
            break;

          case Date:
            outValue = new Date(value);
            break;

          case String:
          default:
            outValue = value;
            break;
        }

        return outValue;
      }
      /* eslint-enable no-fallthrough */

      /**
       * Creates a setter/getter pair for the named property with its own
       * local storage.  The getter returns the value in the local storage,
       * and the setter calls `_setProperty`, which updates the local storage
       * for the property and enqueues a `_propertiesChanged` callback.
       *
       * This method may be called on a prototype or an instance.  Calling
       * this method may overwrite a property value that already exists on
       * the prototype/instance by creating the accessor.  When calling on
       * a prototype, any overwritten values are saved in `__dataProto`,
       * and it is up to the subclasser to decide how/when to set those
       * properties back into the accessor.  When calling on an instance,
       * the overwritten value is set via `_setPendingProperty`, and the
       * user should call `_invalidateProperties` or `_flushProperties`
       * for the values to take effect.
       *
       * @param {string} property Name of the property
       * @param {boolean=} readOnly When true, no setter is created; the
       *   protected `_setProperty` function must be used to set the property
       * @protected
       */
      _createPropertyAccessor(property, readOnly) {
        saveAccessorValue(this, property);
        Object.defineProperty(this, property, {
          get: function() {
            return this.__data && this.__data[property];
          },
          set: readOnly ? function() { } : function(value) {
            this._setProperty(property, value);
          }
        });
      }

      /**
       * Updates the local storage for a property (via `_setPendingProperty`)
       * and enqueues a `_proeprtiesChanged` callback.
       *
       * @param {string} property Name of the property
       * @param {*} value Value to set
       * @protected
       */
      _setProperty(property, value) {
        if (this._setPendingProperty(property, value)) {
          this._invalidateProperties();
        }
      }

      /**
       * Updates the local storage for a property, records the previous value,
       * and adds it to the set of "pending changes" that will be passed to the
       * `_propertiesChanged` callback.  This method does not enqueue the
       * `_propertiesChanged` callback.
       *
       * @param {string} property Name of the property
       * @param {*} value Value to set
       * @protected
       */
      _setPendingProperty(property, value) {
        let old = this.__data[property];
        if (this._shouldPropertyChange(property, value, old)) {
          if (!this.__dataPending) {
            this.__dataPending = {};
            this.__dataOld = {};
          }
          // Ensure old is captured from the last turn
          if (!(property in this.__dataOld)) {
            this.__dataOld[property] = old;
          }
          this.__data[property] = value;
          this.__dataPending[property] = value;
          return true;
        }
      }

      /**
       * Returns true if the specified property has a pending change.
       *
       * @param {string} prop Property name
       * @return {boolean} True if property has a pending change
       * @protected
       */
      _isPropertyPending(prop) {
        return this.__dataPending && (prop in this.__dataPending);
      }

      /**
       * Marks the properties as invalid, and enqueues an async
       * `_propertiesChanged` callback.
       *
       * @protected
       */
      _invalidateProperties() {
        if (!this.__dataInvalid) {
          this.__dataInvalid = true;
          microtask.run(() => {
            if (this.__dataInvalid) {
              this.__dataInvalid = false;
              this._flushProperties();
            }
          });
        }
      }

      /**
       * Calls the `_propertiesChanged` callback with the current set of
       * pending changes (and old values recorded when pending changes were
       * set), and resets the pending set of changes.
       *
       * @protected
       */
      _flushProperties() {
        let oldProps = this.__dataOld;
        let changedProps = this.__dataPending;
        this.__dataPending = null;
        this.__dataCounter++;
        this._propertiesChanged(this.__data, changedProps, oldProps);
        this.__dataCounter--;
      }

      /**
       * Callback called when any properties with accessors created via
       * `_createPropertyAccessor` have been set.
       *
       * @param {Object} currentProps Bag of all current accessor values
       * @param {Object} changedProps Bag of properties changed since the last
       *   call to `_propertiesChanged`
       * @param {Object} oldProps Bag of previous values for each property
       *   in `changedProps`
       * @protected
       */
      _propertiesChanged(currentProps, changedProps, oldProps) { // eslint-disable-line no-unused-vars
      }

      /**
       * Method called to determine whether a property value should be
       * considered as a change and cause the `_propertiesChanged` callback
       * to be enqueued.
       *
       * The default implementation returns `true` for primitive types if a
       * strict equality check fails, and returns `true` for all Object/Arrays.
       * The method always returns false for `NaN`.
       *
       * Override this method to e.g. provide stricter checking for
       * Objects/Arrays when using immutable patterns.
       *
       * @param {string} property
       * @param {*} value
       * @param {*} old
       * @return {boolean} Whether the property should be considered a change
       *   and enqueue a `_proeprtiesChanged` callback
       * @protected
       */
      _shouldPropertyChange(property, value, old) {
        return (
          // Strict equality check for primitives
          (old !== value &&
           // This ensures (old==NaN, value==NaN) always returns false
           (old === old || value === value))
        );
      }

    }

  });

})();
</script>
<script>
(function() {

  'use strict';

  /**
   * Scans a template to produce an annotation object that stores expression
   * metadata along with information to associate the metadata with nodes in an
   * instance.
   *
   * Elements with `id` in the template are noted and marshaled into an
   * the `$` hash in an instance.
   *
   * Example
   *
   *     &lt;template>
   *       &lt;div id="foo">&lt;/div>
   *     &lt;/template>
   *     &lt;script>
   *      Polymer({
   *        task: function() {
   *          this.$.foo.style.color = 'red';
   *        }
   *      });
   *     &lt;/script>
   *
   * Other expressions that are noted include:
   *
   * Double-mustache annotations in text content. The annotation must be the only
   * content in the tag, compound expressions are not (currently) supported.
   *
   *     <[tag]>{{path.to.host.property}}<[tag]>
   *
   * Double-mustache annotations in an attribute.
   *
   *     <[tag] someAttribute="{{path.to.host.property}}"><[tag]>
   *
   * Only immediate host properties can automatically trigger side-effects.
   * Setting `host.path` in the example above triggers the binding, setting
   * `host.path.to.host.property` does not.
   *
   * `on-` style event declarations.
   *
   *     <[tag] on-<event-name>="{{hostMethodName}}"><[tag]>
   *
   * Note: **the `annotations` feature does not actually implement the behaviors
   * associated with these expressions, it only captures the data**.
   *
   * Other optional features contain actual data implementations.
   *
   * @class standard feature: annotations
   */

  /*

  Scans a template to produce an annotation map that stores expression metadata
  and information that associates the metadata to nodes in a template instance.

  Supported annotations are:

    * id attributes
    * binding annotations in text nodes
      * double-mustache expressions: {{expression}}
      * double-bracket expressions: [[expression]]
    * binding annotations in attributes
      * attribute-bind expressions: name="{{expression}} || [[expression]]"
      * property-bind expressions: name*="{{expression}} || [[expression]]"
      * property-bind expressions: name:="expression"
    * event annotations
      * event delegation directives: on-<eventName>="expression"

  Generated data-structure:

    [
      {
        id: '<id>',
        events: [
          {
            mode: ['auto'|''],
            name: '<name>'
            value: '<expression>'
          }, ...
        ],
        bindings: [
          {
            kind: ['text'|'attribute'|'property'],
            mode: ['auto'|''],
            name: '<name>'
            value: '<expression>'
          }, ...
        ],
        parent: <reference to parent annotation>,
        index: <integer index in parent's childNodes collection>
      },
      ...
    ]
  */

  // null-array (shared empty array to avoid null-checks)
  const emptyArray = [];

  let bindingRegex = (function() {
    let IDENT  = '(?:' + '[a-zA-Z_$][\\w.:$\\-*]*' + ')';
    let NUMBER = '(?:' + '[-+]?[0-9]*\\.?[0-9]+(?:[eE][-+]?[0-9]+)?' + ')';
    let SQUOTE_STRING = '(?:' + '\'(?:[^\'\\\\]|\\\\.)*\'' + ')';
    let DQUOTE_STRING = '(?:' + '"(?:[^"\\\\]|\\\\.)*"' + ')';
    let STRING = '(?:' + SQUOTE_STRING + '|' + DQUOTE_STRING + ')';
    let ARGUMENT = '(?:' + IDENT + '|' + NUMBER + '|' +  STRING + '\\s*' + ')';
    let ARGUMENTS = '(?:' + ARGUMENT + '(?:,\\s*' + ARGUMENT + ')*' + ')';
    let ARGUMENT_LIST = '(?:' + '\\(\\s*' +
                                  '(?:' + ARGUMENTS + '?' + ')' +
                                '\\)\\s*' + ')';
    let BINDING = '(' + IDENT + '\\s*' + ARGUMENT_LIST + '?' + ')'; // Group 3
    let OPEN_BRACKET = '(\\[\\[|{{)' + '\\s*';
    let CLOSE_BRACKET = '(?:]]|}})';
    let NEGATE = '(?:(!)\\s*)?'; // Group 2
    let EXPRESSION = OPEN_BRACKET + NEGATE + BINDING + CLOSE_BRACKET;
    return new RegExp(EXPRESSION, "g");
  })();

  let insertionPointTag = 'slot';

  /**
   * @param {HTMLTemplateElement} template
   * @param {boolean=} stripWhiteSpace
   * @return {Array<Object>}
   */
  function parseTemplateAnnotations(template, stripWhiteSpace, ownerDocument) {
    // TODO(kschaaf): File issue and/or remove when fixed
    // hold a reference to content as _content to prevent odd Chrome gc issue
    // nested templates also may receive their content as _content
    let content = (template._content = template._content || template.content);
    // since a template may be re-used, memo-ize notes.
    if (!content._notes) {
      content._notes = [];
      // TODO(sorvell): whitespace and processAnnotations need to be factored
      // into plugins
      ownerDocument = ownerDocument || template.ownerDocument;
      parseNodeAnnotations(content, content._notes,
        stripWhiteSpace || template.hasAttribute('strip-whitespace'), ownerDocument);
    }
    return content._notes;
  }

  // add annotations gleaned from subtree at `node` to `list`
  function parseNodeAnnotations(node, list, stripWhiteSpace, ownerDocument) {
    return node.nodeType === Node.TEXT_NODE ?
      parseTextNodeAnnotation(node, list) :
        parseElementAnnotations(node, list, stripWhiteSpace, ownerDocument);
  }

  function parseBindings(text) {
    let parts = [];
    let lastIndex = 0;
    let m;
    // Example: "literal1{{prop}}literal2[[!compute(foo,bar)]]final"
    // Regex matches:
    //        Iteration 1:  Iteration 2:
    // m[1]: '{{'          '[['
    // m[2]: ''            '!'
    // m[3]: 'prop'        'compute(foo,bar)'
    while ((m = bindingRegex.exec(text)) !== null) {
      // Add literal part
      if (m.index > lastIndex) {
        parts.push({literal: text.slice(lastIndex, m.index)});
      }
      // Add binding part
      // Mode (one-way or two)
      let mode = m[1][0];
      let negate = Boolean(m[2]);
      let value = m[3].trim();
      let customEvent, notifyEvent, colon;
      if (mode == '{' && (colon = value.indexOf('::')) > 0) {
        notifyEvent = value.substring(colon + 2);
        value = value.substring(0, colon);
        customEvent = true;
      }
      parts.push({
        compoundIndex: parts.length,
        value: value,
        mode: mode,
        negate: negate,
        event: notifyEvent,
        customEvent: customEvent
      });
      lastIndex = bindingRegex.lastIndex;
    }
    // Add a final literal part
    if (lastIndex && lastIndex < text.length) {
      let literal = text.substring(lastIndex);
      if (literal) {
        parts.push({
          literal: literal
        });
      }
    }
    if (parts.length) {
      return parts;
    }
  }

  function literalFromParts(parts) {
    let s = '';
    for (let i=0; i<parts.length; i++) {
      let literal = parts[i].literal;
      s += literal || '';
    }
    return s;
  }

  // add annotations gleaned from TextNode `node` to `list`
  function parseTextNodeAnnotation(node, list) {
    let parts = parseBindings(node.textContent);
    if (parts) {
      // Initialize the textContent with any literal parts
      // NOTE: default to a space here so the textNode remains; some browsers
      // (IE) evacipate an empty textNode following cloneNode/importNode.
      node.textContent = literalFromParts(parts) || ' ';
      let note = {
        bindings: [{
          kind: 'text',
          name: 'textContent',
          parts: parts,
          isCompound: parts.length !== 1
        }]
      };
      list.push(note);
      return note;
    }
  }

  // add annotations gleaned from Element `node` to `list`
  function parseElementAnnotations(element, list, stripWhiteSpace, ownerDocument) {
    let note = {
      bindings: [],
      events: []
    };
    if (element.localName === insertionPointTag) {
      list._hasInsertionPoint = true;
    }
    parseChildNodesAnnotations(element, note, list, stripWhiteSpace, ownerDocument);
    if (element.attributes) {
      parseNodeAttributeAnnotations(element, note);
      Polymer.ResolveUrl.resolveAttrs(element, ownerDocument);
    }
    if (note.bindings.length || note.events.length || note.id) {
      list.push(note);
    }
    return note;
  }

  // 1.x backwards-compatible auto-wrapper for template type extensions
  // This is a clear layering violation and gives favored-nation status to
  // dom-if and dom-repeat templates.  This is a conceit we're choosing to keep
  // a.) to ease 1.x backwards-compatibility due to loss of `is`, and
  // b.) to maintain if/repeat capability in parser-constrained elements
  //     (e.g. table, select) in lieu of native CE type extensions without
  //     massive new invention in this space (e.g. directive system)
  const templateExtensions = {
    'dom-if': true,
    'dom-repeat': true
  };
  function wrapTemplateExtension(node) {
    let is = node.getAttribute('is');
    if (is && templateExtensions[is]) {
      let t = node;
      t.removeAttribute('is');
      node = t.ownerDocument.createElement(is);
      t.parentNode.replaceChild(node, t);
      node.appendChild(t);
      while(t.attributes.length) {
        node.setAttribute(t.attributes[0].name, t.attributes[0].value);
        t.removeAttribute(t.attributes[0].name);
      }
    }
    return node;
  }

  // add annotations gleaned from children of `root` to `list`, `root`'s
  // `note` is supplied as it is the note.parent of added annotations
  function parseChildNodesAnnotations(root, note, list, stripWhiteSpace, ownerDocument) {
    if (root.firstChild) {
      let node = root.firstChild;
      let i = 0;
      while (node) {
        // Wrap templates
        if (node.localName == 'template') {
          node = wrapTemplateExtension(node);
        }
        // Recurse
        if (node.localName == 'template' &&
          !node.hasAttribute('preserve-content')) {
          parseTemplate(node, i, list, note, stripWhiteSpace, ownerDocument);
        }
        // collapse adjacent textNodes: fixes an IE issue that can cause
        // text nodes to be inexplicably split =(
        // note that root.normalize() should work but does not so we do this
        // manually.
        let next = node.nextSibling;
        if (node.nodeType === Node.TEXT_NODE) {
          let n = next;
          while (n && (n.nodeType === Node.TEXT_NODE)) {
            node.textContent += n.textContent;
            next = n.nextSibling;
            root.removeChild(n);
            n = next;
          }
          // optionally strip whitespace
          if (stripWhiteSpace && !node.textContent.trim()) {
            root.removeChild(node);
            // decrement index since node is removed
            i--;
          }
        }
        // if this node didn't get evacipated, parse it.
        if (node.parentNode) {
          let childAnnotation = parseNodeAnnotations(node, list,
            stripWhiteSpace, ownerDocument);
          if (childAnnotation) {
            childAnnotation.parent = note;
            childAnnotation.index = i;
          }
        }
        node = next;
        i++;
      }
    }
  }

  // 1. Parse annotations from the template and memoize them on
  //    content._notes (recurses into nested templates)
  // 2. Remove template.content and store it in annotation list, where it
  //    will be the responsibility of the host to set it back to the template
  //    (this is both an optimization to avoid re-stamping nested template
  //    children and avoids a bug in Chrome where nested template children
  //    upgrade)
  function parseTemplate(node, index, list, parent, stripWhiteSpace, ownerDocument) {
    let content = node.content.ownerDocument.createDocumentFragment();
    content._notes = parseTemplateAnnotations(node, stripWhiteSpace, ownerDocument);
    content.appendChild(node.content);
    list.push({
      bindings: emptyArray,
      events: emptyArray,
      templateContent: content,
      parent: parent,
      index: index
    });
  }

  // add annotation data from attributes to the `annotation` for node `node`
  function parseNodeAttributeAnnotations(node, annotation) {
    // Make copy of original attribute list, since the order may change
    // as attributes are added and removed
    let attrs = Array.prototype.slice.call(node.attributes);
    for (let i=attrs.length-1, a; (a=attrs[i]); i--) {
      let n = a.name;
      let v = a.value;
      let b;
      // events (on-*)
      if (n.slice(0, 3) === 'on-') {
        node.removeAttribute(n);
        annotation.events.push({
          name: n.slice(3),
          value: v
        });
      }
      // bindings (other attributes)
      else if ((b = parseNodeAttributeAnnotation(node, n, v))) {
        annotation.bindings.push(b);
      }
      // static id
      else if (n === 'id') {
        annotation.id = v;
      }
    }
  }

  // construct annotation data from a generic attribute, or undefined
  function parseNodeAttributeAnnotation(node, name, value) {
    let parts = parseBindings(value);
    if (parts) {
      // Attribute or property
      let origName = name;
      let kind = 'property';
      if (name[name.length-1] == '$') {
        name = name.slice(0, -1);
        kind = 'attribute';
      }
      // Initialize attribute bindings with any literal parts
      let literal = literalFromParts(parts);
      if (literal && kind == 'attribute') {
        node.setAttribute(name, literal);
      }
      // Clear attribute before removing, since IE won't allow removing
      // `value` attribute if it previously had a value (can't
      // unconditionally set '' before removing since attributes with `$`
      // can't be set using setAttribute)
      if (node.localName === 'input' && origName === 'value') {
        node.setAttribute(origName, '');
      }
      // Remove annotation
      node.removeAttribute(origName);
      // Case hackery: attributes are lower-case, but bind targets
      // (properties) are case sensitive. Gambit is to map dash-case to
      // camel-case: `foo-bar` becomes `fooBar`.
      // Attribute bindings are excepted.
      let propertyName = Polymer.CaseMap.dashToCamelCase(name);
      if (kind === 'property') {
        name = propertyName;
      }
      return {
        kind: kind,
        name: name,
        propertyName: propertyName,
        parts: parts,
        literal: literal,
        isCompound: parts.length !== 1
      };
    }
  }

  function findTemplateAnnotatedNode(root, note) {
    // recursively ascend tree until we hit root
    let parent = note.parent && findTemplateAnnotatedNode(root,
      note.parent);
    // unwind the stack, returning the indexed node at each level
    if (parent) {
      // note: marginally faster than indexing via childNodes
      // (http://jsperf.com/childnodes-lookup)
      for (let n=parent.firstChild, i=0; n; n=n.nextSibling) {
        if (note.index === i++) {
          return n;
        }
      }
    } else {
      return root;
    }
  }

  // construct `$` map (from id annotations)
  function applyIdToMap(inst, map, node, note) {
    if (note.id) {
      map[note.id] = node;
    }
  }

  // install event listeners (from event annotations)
  function applyEventListener(inst, node, note, host) {
    if (note.events && note.events.length) {
      for (let j=0, e$=note.events, e; (j<e$.length) && (e=e$[j]); j++) {
        inst._addMethodEventListenerToNode(node, e.name, e.value, host);
      }
    }
  }

  // push configuration references at configure time
  function applyTemplateContent(inst, node, note) {
    if (note.templateContent) {
      node._content = note.templateContent;
    }
  }

  function createNodeEventHandler(context, eventName, methodName) {
    // Instances can optionally have a _methodHost which allows redirecting where
    // to find methods. Currently used by `templatize`.
    context = context._methodHost || context;
    let handler = function(e) {
      if (context[methodName]) {
        context[methodName](e, e.detail);
      } else {
        console.warn('listener method `' + methodName + '` not defined');
      }
    };
    return handler;
  }

  Polymer.TemplateStamp = Polymer.dedupingMixin(function(superClass) {

    return class TemplateStamp extends superClass {

      constructor() {
        super();
        this.$ = null;
        this._templateNodes = null;
        this._templateNotes = null;
      }

      /**
       * Clones the provided template content and returns a document fragment
       * containing the cloned dom.
       *
       * The template is parsed (once and memoized) using this library's
       * template parsing features, which identify nodes with declarative
       * event listeners (`on-...``), `id`'s, `<template>`s, and bindings
       * (`{{...}}` and `[[...]]`).  This template metadata ("notes")
       * are stored as `this._templateNotes`, and any nodes identified in
       * with notes are collected for this instance into `_templateNodes` in
       * the same order as the notes array.
       *
       * Finally, this method generates an "id map" for all nodes with id's
       * under `this.$`, passes template content back to templates as `_content`
       * (a performance optimization to avoid deep template cloning), and
       * installs declarative event listeners.
       *
       * Note that the memoized template parsing process is destructive to the
       * template: attributes for bindings and declarative event listeners are
       * removed after being noted in notes, and any nested <template>.content
       * is removed and stored in notes as well.
       *
       * Note that this method may only be called once per instance (it does
       * not support stamping multiple templates per element instance).
       *
       * @param {HTMLTemplateElement} template Template to stamp
       */
      _stampTemplate(template) {
        // Polyfill support: bootstrap the template if it has not already been
        if (template && !template.content &&
            window.HTMLTemplateElement && HTMLTemplateElement.decorate) {
          HTMLTemplateElement.decorate(template);
        }
        let notes = this._templateNotes = this._parseTemplateAnnotations(template);
        let dom = document.importNode(template._content || template.content, true);
        // NOTE: ShadyDom optimization indicating there is an insertion point
        dom.__noInsertionPoint = !notes._hasInsertionPoint;
        this.$ = {};
        this._templateNodes = new Array(notes.length);
        for (let i=0, l=notes.length, note, node; (i<l) && (note=notes[i]); i++) {
          node = this._templateNodes[i] = findTemplateAnnotatedNode(dom, note);
          applyIdToMap(this, this.$, node, note);
          applyTemplateContent(this, node, note);
          applyEventListener(this, node, note, this);
        }
        return dom;
      }

      // preprocess-time

      // construct and return a list of annotation records
      // by scanning `template`'s content
      //
      // TODO(sorvell): This should just crawl over a template and call
      // a supplied list of callbacks.
      _parseTemplateAnnotations(template) {
        return parseTemplateAnnotations(template);
      }

      _addMethodEventListenerToNode(node, eventName, methodName, context) {
        context = context || node;
        let handler = createNodeEventHandler(context, eventName, methodName);
        this._addEventListenerToNode(node, eventName, handler);
        return handler;
      }

      _addEventListenerToNode(node, eventName, handler) {
        node.addEventListener(eventName, handler);
      }

      _removeEventListenerFromNode(node, eventName, handler) {
        node.removeEventListener(eventName, handler);
      }

    }

  });

})();
</script>
<script>
(function() {

  'use strict';

  const CaseMap = Polymer.CaseMap;
  const mixin = Polymer.mixin;

  // For tracking nested clients that will require flushing
  let hostStack = {

    stack: [],

    isEmpty() {
      return !this.stack.length;
    },

    registerHost(inst) {
      if (this.stack.length) {
        let host = this.stack[this.stack.length-1];
        host._enqueueClient(inst);
      }
    },

    beginHosting(inst) {
      this.stack.push(inst);
    },

    endHosting(inst) {
      let stackLen = this.stack.length;
      if (stackLen && this.stack[stackLen-1] == inst) {
        this.stack.pop();
      }
    }

  }

  // Monotonically increasing unique ID used for de-duping effects triggered
  // from multiple properties in the same turn
  let dedupeId = 0;

  // Property effect types; effects are stored on the prototype using these keys
  const TYPES = {
    ANY: '__propertyEffects',
    COMPUTE: '__computeEffects',
    REFLECT: '__reflectEffects',
    NOTIFY: '__notifyEffects',
    PROPAGATE: '__propagateEffects',
    OBSERVE: '__observeEffects',
    READ_ONLY: '__readOnly'
  }

  /**
   * Ensures that the model has an own-property map of effects for the given type.
   * The model may be a prototype or an instance.
   *
   * Property effects are stored as arrays of effects by property in a map,
   * by named type on the model. e.g.
   *
   *   __computeEffects: {
   *     foo: [ ... ],
   *     bar: [ ... ]
   *   }
   *
   * If the model does not yet have an effect map for the type, one is created
   * and returned.  If it does, but it is not an own property (i.e. the
   * prototype had effects), the the map is deeply cloned and the copy is
   * set on the model and returned, ready for new effects to be added.
   *
   * @param {Object} model Prototype or instance
   * @param {string} type Property effect type
   * @return {Object} The own-property map of effects for the given type
   * @private
   */
  function ensureOwnEffectMap(model, type) {
    let effects = model[type];
    if (!effects) {
      effects = model[type] = {};
    } else if (!model.hasOwnProperty(type)) {
      effects = model[type] = Object.create(model[type]);
      for (let p in effects) {
        let protoFx = effects[p];
        let instFx = effects[p] = Array(protoFx.length);
        for (let i=0; i<protoFx.length; i++) {
          instFx[i] = protoFx[i];
        }
      }
    }
    return effects;
  }

  // -- effects ----------------------------------------------

  /**
   * Runs all effects of a given type for the given set of property changes
   * on an instance.
   *
   * @param {Object} inst The instance with effects to run
   * @param {string} type Type of effect to run
   * @param {Object} props Bag of current property changes
   * @param {Object=} oldProps Bag of previous values for changed properties
   * @private
   */
  function runEffects(inst, effects, props, oldProps, hasPaths) {
    if (effects) {
      let ran;
      let id = dedupeId++;
      for (let prop in props) {
        if (runEffectsForProperty(inst, effects, id, prop, props, oldProps, hasPaths)) {
          ran = true;
        }
      }
      return ran;
    }
  }

  /**
   * Runs a list of effects for a given property.
   *
   * @param {Object} inst The instance with effects to run
   * @param {Array} effects Array of effects
   * @param {number} id Effect run id used for de-duping effects
   * @param {string} prop Name of changed property
   * @param {*} value Value of changed property
   * @param {*} old Previous value of changed property
   * @private
   */
  function runEffectsForProperty(inst, effects, dedupeId, prop, props, oldProps, hasPaths) {
    let ran;
    let rootProperty = hasPaths ? Polymer.Path.root(prop) : prop;
    let fxs = effects[rootProperty];
    if (fxs) {
      for (let i=0, l=fxs.length, fx; (i<l) && (fx=fxs[i]); i++) {
        if ((!fx.info || fx.info.lastRun !== dedupeId) &&
            (!hasPaths || pathMatchesTrigger(prop, fx.trigger))) {
          fx.fn(inst, prop, props, oldProps, fx.info, hasPaths);
          if (fx.info) {
            fx.info.lastRun = dedupeId;
          }
          ran = true;
        }
      }
    }
    return ran;
  }

  /**
   * Determines whether a property/path that has changed matches the trigger
   * criteria for an effect.  A trigger is a descriptor with the following
   * structure, which matches the descriptors returned from `parseArg`.
   * e.g. for `foo.bar.*`:
   * ```
   * trigger: {
   *   name: 'a.b',
   *   structured: true,
   *   wildcard: true
   * }
   * ```
   * If no trigger is given, the path is deemed to match.
   *
   * @param {string} path Path or property that changed
   * @param {Object} trigger Descriptor
   * @return {boolean} Whether the path matched the trigger
   */
  function pathMatchesTrigger(path, trigger) {
    if (trigger) {
      let triggerPath = trigger.name;
      return (triggerPath == path) ||
        (trigger.structured && Polymer.Path.isAncestor(triggerPath, path)) ||
        (trigger.wildcard && Polymer.Path.isDescendant(triggerPath, path));
    } else {
      return true;
    }
  }

  /**
   * Implements the "observer" effect.
   *
   * Calls the method with `info.methodName` on the instance, passing the
   * new and old values.
   *
   * @param {Object} inst The instance the effect will be run on
   * @param {string} property Name of property
   * @param {*} value Current value of property
   * @param {*} old Previous value of property
   * @param {Object} info Effect metadata
   * @private
   */
  function runObserverEffect(inst, property, props, oldProps, info) {
    let fn = inst[info.methodName];
    let changedProp = info.property;
    if (fn) {
      fn.call(inst, inst.__data[changedProp], oldProps[changedProp]);
    } else {
      console.warn('observer method `' + info.methodName + '` not defined');
    }
  }

  /**
   * Runs "notify" effects for a set of changed properties.
   *
   * This method differs from the generic `runEffects` method in that it
   * will dispatch path notification events in the case that the property
   * changed was a path and the root property for that path didn't have a
   * "notify" effect.  This is to maintain 1.0 behavior that did not require
   * `notify: true` to ensure object sub-property notifications were
   * sent.
   *
   * @param {Element} inst The instance with effects to run
   * @param {Object} props Bag of current property changes
   * @param {Object} oldProps Bag of previous values for changed properties
   * @private
   */
  function runNotifyEffects(inst, notifyProps, props, oldProps, hasPaths) {
    // Notify
    let fxs = inst.__notifyEffects;
    let notified;
    let id = dedupeId++;
    // Try normal notify effects; if none, fall back to try path notification
    for (let prop in notifyProps) {
      if (notifyProps[prop]) {
        if (fxs && runEffectsForProperty(inst, fxs, id, prop, props, oldProps, hasPaths)) {
          notified = true;
        } else if (hasPaths && notifyPath(inst, prop, props)) {
          notified = true;
        }
      }
    }
    // Flush host if we actually notified and host was batching
    let host;
    if (notified && (host = inst.__dataHost) && host._flushProperties) {
      host._flushProperties();
    }
  }

  /**
   * Dispatches {property}-changed events with path information in the detail
   * object to indicate a sub-path of the property was changed.
   *
   * @param {Element} inst The element from which to fire the event
   * @param {string} path The path that was changed
   * @param {*} value
   * @private
   */
  function notifyPath(inst, path, props) {
    let rootProperty = Polymer.Path.root(path);
    if (rootProperty !== path) {
      let eventName = Polymer.CaseMap.camelToDashCase(rootProperty) + '-changed';
      dispatchNotifyEvent(inst, eventName, props[path], path);
      return true;
    }
  }

  /**
   * Dispatches {property}-changed events to indicate a property (or path)
   * changed.
   *
   * @param {Element} inst The element from which to fire the event
   * @param {string} eventName The name of the event to send ('{property}-changed')
   * @param {*} value The value of the changed property
   * @param {string | null | undefined} path If a sub-path of this property changed, the path
   *   that changed (optional).
   * @private
   */
  function dispatchNotifyEvent(inst, eventName, value, path) {
    let detail = {
      value: value,
      queueProperty: true
    };
    if (path) {
      detail.path = path;
    }
    inst.dispatchEvent(new CustomEvent(eventName, { detail }));
  }

  /**
   * Implements the "notify" effect.
   *
   * Dispatches a non-bubbling event named `info.eventName` on the instance
   * with a detail object containing the new `value`.
   *
   * @param {Element} inst The instance the effect will be run on
   * @param {string} property Name of property
   * @param {*} value Current value of property
   * @param {*} old Previous value of property
   * @param {Object} info Effect metadata
   * @private
   */
  function runNotifyEffect(inst, property, props, oldProps, info, hasPaths) {
    let rootProperty = hasPaths ? Polymer.Path.root(property) : property;
    let path = rootProperty != property ? property : null;
    let value = path ? Polymer.Path.get(inst, path) : inst.__data[property];
    if (path && value === undefined) {
      value = props[property];  // specifically for .splices
    }
    dispatchNotifyEvent(inst, info.eventName, value, path);
  }

  /**
   * Adds a 2-way binding notification event listener to the node specified
   *
   * @param {Object} node Child element to add listener to
   * @param {Object} inst Host element instance to handle notification event
   * @param {Object} info Listener metadata stored via addAnnotatedListener
   * @private
   */
  function addNotifyListener(node, inst, info) {
    node.addEventListener(info.event, function(e) {
      handleNotification(e, inst, info.property, info.path, info.negate);
    });
  }

  /**
   * Handler function for 2-way notification events. Receives context
   * information captured in the `addNotifyListener` closure from the
   * `__notifyListeners` metadata.
   *
   * Sets the value of the notified property to the host property or path.  If
   * the event contained path information, translate that path to the host
   * scope's name for that path first.
   *
   * @param {Event} e Notification event (e.g. '<property>-changed')
   * @param {Object} inst Host element instance handling the notification event
   * @param {string} property Child element property that was bound
   * @param {string} path Host property/path that was bound
   * @param {boolean} negate Whether the binding was negated
   * @private
   */
  function handleNotification(e, inst, property, path, negate) {
    let value;
    let targetPath = e.detail && e.detail.path;
    if (targetPath) {
      path = Polymer.Path.translate(property, path, targetPath);
      value = e.detail && e.detail.value;
    } else {
      value = e.target[property];
    }
    value = negate ? !value : value;
    setPropertyFromNotification(inst, path, value, e);
  }

  /**
   * Called by 2-way binding notification event listeners to set a property
   * or path to the host based on a notification from a bound child.
   *
   * @param {string} path Path on this instance to set
   * @param {*} value Value to set to given path
   * @protected
   */
  function setPropertyFromNotification(inst, path, value, event) {
    let detail = event.detail;
    if (detail && detail.queueProperty) {
      if (!inst.__readOnly || !inst.__readOnly[path]) {
        inst._setPendingPropertyOrPath(path, value, true, Boolean(detail.path));
      }
    } else {
      inst.set(path, value);
    }
  }

  /**
   * Implements the "reflect" effect.
   *
   * Sets the attribute named `info.attrName` to the given property value.
   *
   * @param {Object} inst The instance the effect will be run on
   * @param {string} property Name of property
   * @param {*} value Current value of property
   * @param {*} old Previous value of property
   * @param {Object} info Effect metadata
   * @private
   */
  function runReflectEffect(inst, property, props, oldProps, info) {
    let value = inst.__data[property];
    if (Polymer.sanitizeDOMValue) {
      value = Polymer.sanitizeDOMValue(value, info.attrName, 'attribute', inst);
    }
    inst._propertyToAttribute(property, info.attrName, value);
  }

  /**
   * Runs "computed" effects for a set of changed properties.
   *
   * This method differs from the generic `runEffects` method in that it
   * continues to run computed effects based on the output of each pass until
   * there are no more newly computed properties.  This ensures that all
   * properties that will be computed by the initial set of changes are
   * computed before other effects (binding propagation, observers, and notify)
   * run.
   *
   * @param {Element} inst The instance the effect will be run on
   * @param {Object} changedProps Bag of changed properties
   * @param {Object} oldProps Bag of previous values for changed properties
   */
  function runComputedEffects(inst, changedProps, oldProps, hasPaths) {
    let computeEffects = inst.__computeEffects;
    if (computeEffects) {
      let inputProps = changedProps;
      while (runEffects(inst, computeEffects, inputProps, oldProps, hasPaths)) {
        mixin(oldProps, inst.__dataOld);
        mixin(changedProps, inst.__dataPending);
        inputProps = inst.__dataPending;
        inst.__dataPending = null;
      }
    }
  }

  /**
   * Implements the "computed property" effect by running the method with the
   * values of the arguments specified in the `info` object and setting the
   * return value to the computed property specified.
   *
   * @param {Object} inst The instance the effect will be run on
   * @param {string} property Name of property
   * @param {*} value Current value of property
   * @param {*} old Previous value of property
   * @param {Object} info Effect metadata
   * @private
   */
  function runComputedEffect(inst, property, props, oldProps, info) {
    var result = runMethodEffect(inst, property, props, oldProps, info);
    var computedProp = info.methodInfo;
    if (inst.__propertyEffects && inst.__propertyEffects[computedProp]) {
      inst._setPendingProperty(computedProp, result, true);
    } else {
      inst[computedProp] = result;
    }
  }

  /**
   * Computes path changes based on path links set up using the `linkPaths`
   * API.
   *
   * @param {Element} inst The instance whose props are changing
   * @param {Object} changedProps Bag of changed properties
   * @private
   */
  function computeLinkedPaths(inst, changedProps, hasPaths) {
    let links;
    if (hasPaths && (links = inst.__dataLinkedPaths)) {
      const cache = inst.__dataTemp;
      let link;
      for (let a in links) {
        let b = links[a];
        for (let path in changedProps) {
          if (Polymer.Path.isDescendant(a, path)) {
            link = Polymer.Path.translate(a, b, path);
            cache[link] = changedProps[link] = changedProps[path];
            let notifyProps = inst.__dataToNotify || (inst.__dataToNotify = {});
            notifyProps[link] = true;
          } else if (Polymer.Path.isDescendant(b, path)) {
            link = Polymer.Path.translate(b, a, path);
            cache[link] = changedProps[link] = changedProps[path];
            let notifyProps = inst.__dataToNotify || (inst.__dataToNotify = {});
            notifyProps[link] = true;
          }
        }
      }
    }
  }

  // -- bindings ----------------------------------------------

  /**
   * Adds "binding" property effects for the template annotation
   * ("note" for short) and node index specified.  These may either be normal
   * "binding" effects (property/path bindings) or "method binding"
   * effects, aka inline computing functions, depending on the type of binding
   * detailed in the note.
   *
   * @param {Object} model Prototype or instance
   * @param {Object} note Annotation note returned from Annotator
   * @param {number} index Index into `_templateNodes` list of annotated nodes that the
   *   note applies to
   * @param {Object=} dynamicFns Map indicating whether method names should
   *   be included as a dependency to the effect.
   * @private
   */
  function addBindingEffect(model, note, index, dynamicFns) {
    for (let i=0; i<note.parts.length; i++) {
      let part = note.parts[i];
      if (part.signature) {
        addMethodBindingEffect(model, note, part, index, dynamicFns);
      } else if (!part.literal) {
        if (note.kind === 'attribute' && note.name[0] === '-') {
          console.warn('Cannot set attribute ' + note.name +
            ' because "-" is not a valid attribute starting character');
        } else {
          model._addPropertyEffect(Polymer.Path.root(part.value), TYPES.PROPAGATE, {
            fn: runBindingEffect,
            info:  {
              kind: note.kind,
              index: index,
              name: note.name,
              propertyName: note.propertyName,
              value: part.value,
              isCompound: note.isCompound,
              compoundIndex: part.compoundIndex,
              event: part.event,
              customEvent: part.customEvent,
              negate: part.negate
            }
          });
        }
      }
    }
  }

  /**
   * Implements the "binding" (property/path binding) effect.
   *
   * @param {Element} inst The instance the effect will be run on
   * @param {string} path Name of property
   * @param {*} value Current value of property
   * @param {*} old Previous value of property
   * @param {Object} info Effect metadata
   * @private
   */
  function runBindingEffect(inst, path, props, oldProps, info, hasPaths) {
    let value;
    let node = inst._templateNodes[info.index];
    // Subpath notification: transform path and set to client
    // e.g.: foo="{{obj.sub}}", path: 'obj.sub.prop', set 'foo.prop'=obj.sub.prop
    if (hasPaths && (path.length > info.value.length) &&
        (info.kind == 'property') && !info.isCompound &&
        node.__propertyEffects && node.__propertyEffects[info.name]) {
      let value = props[path];
      path = Polymer.Path.translate(info.value, info.name, path);
      if (node._setPendingPropertyOrPath(path, value, false, true)) {
        inst._enqueueClient(node);
      }
    } else {
      // Root or deeper path was set; extract bound path value
      // e.g.: foo="{{obj.sub}}", path: 'obj', set 'foo'=obj.sub
      //   or: foo="{{obj.sub}}", path: 'obj.sub.prop', set 'foo'=obj.sub
      if (path != info.value) {
        value = Polymer.Path.get(inst, info.value);
      } else {
        if (hasPaths && Polymer.Path.isPath(path)) {
          value = Polymer.Path.get(inst, path);
        } else {
          value = inst.__data[path];
        }
      }
      // Propagate value to child
      applyBindingValue(inst, info, value);
    }
  }

  /**
   * Sets the value for an "binding" (binding) effect to a node,
   * either as a property or attribute.
   *
   * @param {Object} inst The instance owning the binding effect
   * @param {Object} info Effect metadata
   * @param {*} value Value to set
   * @private
   */
  function applyBindingValue(inst, info, value) {
    let node = inst._templateNodes[info.index];
    value = computeBindingValue(node, value, info);
    if (Polymer.sanitizeDOMValue) {
      value = Polymer.sanitizeDOMValue(value, info.name, info.kind, node);
    }
    if (info.kind == 'attribute') {
      // Attribute binding
      inst._valueToNodeAttribute(node, value, info.name);
    } else {
      // Property binding
      let prop = info.name;
      if (node.__propertyEffects && node.__propertyEffects[prop]) {
        if (!node.__readOnly || !node.__readOnly[prop]) {
          if (node._setPendingProperty(prop, value)) {
            inst._enqueueClient(node);
          }
        }
      } else  {
        inst._setUnmanagedPropertyToNode(node, prop, value);
      }
    }
  }

  /**
   * Transforms an "binding" effect value based on compound & negation
   * effect metadata, as well as handling for special-case properties
   *
   * @param {Node} node Node the value will be set to
   * @param {*} value Value to set
   * @param {Object} info Effect metadata
   * @return {*} Transformed value to set
   * @private
   */
  function computeBindingValue(node, value, info) {
    if (info.negate) {
      value = !value;
    }
    if (info.isCompound) {
      let storage = node.__dataCompoundStorage[info.name];
      storage[info.compoundIndex] = value;
      value = storage.join('');
    }
    if (info.kind !== 'attribute') {
      // Some browsers serialize `undefined` to `"undefined"`
      if (info.name === 'textContent' ||
          (node.localName == 'input' && info.name == 'value')) {
        value = value == undefined ? '' : value;
      }
    }
    return value;
  }

  /**
   * Adds "binding method" property effects for the template binding
   * ("note" for short), part metadata, and node index specified.
   *
   * @param {Object} model Prototype or instance
   * @param {Object} note Binding note returned from Annotator
   * @param {Object} part The compound part metadata
   * @param {number} index Index into `_templateNodes` list of annotated nodes that the
   *   note applies to
   * @param {Object=} dynamicFns Map indicating whether method names should
   *   be included as a dependency to the effect.
   * @private
   */
  function addMethodBindingEffect(model, note, part, index, dynamicFns) {
    createMethodEffect(model, part.signature, TYPES.PROPAGATE,
      runMethodBindingEffect, {
        index: index,
        isCompound: note.isCompound,
        compoundIndex: part.compoundIndex,
        kind: note.kind,
        name: note.name,
        negate: part.negate,
        part: part
      }, dynamicFns
    );
  }

  /**
   * Implements the "binding method" (inline computed function) effect.
   *
   * Runs the method with the values of the arguments specified in the `info`
   * object and setting the return value to the node property/attribute.
   *
   * @param {Object} inst The instance the effect will be run on
   * @param {string} property Name of property
   * @param {*} value Current value of property
   * @param {*} old Previous value of property
   * @param {Object} info Effect metadata
   * @private
   */
  function runMethodBindingEffect(inst, property, props, oldProps, info) {
    let val = runMethodEffect(inst, property, props, oldProps, info);
    applyBindingValue(inst, info.methodInfo, val);
  }

  /**
   * Post-processes template bindings (notes for short) provided by the
   * Bindings library for use by the effects system:
   * - Parses bindings for methods into method `signature` objects
   * - Memoizes the root property for path bindings
   * - Recurses into nested templates and processes those templates and
   *   extracts any host properties, which are set to the template's
   *   `_content._hostProps`
   * - Adds bindings from the host to <template> elements for any nested
   *   template's lexically bound "host properties"; template handling
   *   elements can then add accessors to the template for these properties
   *   to forward host properties into template instances accordingly.
   *
   * @param {Array<Object>} notes List of notes to process; the notes are
   *   modified in place.
   * @private
   */
  function processAnnotations(notes) {
    if (!notes._processed) {
      for (let i=0; i<notes.length; i++) {
        let note = notes[i];
        // Parse bindings for methods & path roots (models)
        for (let j=0; j<note.bindings.length; j++) {
          let b = note.bindings[j];
          for (let k=0; k<b.parts.length; k++) {
            let p = b.parts[k];
            if (!p.literal) {
              p.signature = parseMethod(p.value);
              if (!p.signature) {
                p.rootProperty = Polymer.Path.root(p.value);
              }
            }
          }
        }
        // Recurse into nested templates & bind host props
        if (note.templateContent) {
          processAnnotations(note.templateContent._notes);
          let hostProps = note.templateContent._hostProps =
            discoverTemplateHostProps(note.templateContent._notes);
          let bindings = [];
          for (let prop in hostProps) {
            bindings.push({
              index: note.index,
              kind: 'property',
              name: '_host_' + prop,
              parts: [{
                mode: '{',
                value: prop
              }]
            });
          }
          note.bindings = note.bindings.concat(bindings);
        }
      }
      notes._processed = true;
    }
  }

  /**
   * Finds all property usage in templates (property/path bindings and function
   * arguments) and returns the path roots as keys in a map. Each outer template
   * merges inner _hostProps to propagate inner host property needs to outer
   * templates.
   *
   * @param {Array<Object>} notes List of notes to process for a given template
   * @return {Object<string,boolean>} Map of host properties that the template
   *   (or any nested templates) uses
   * @private
   */
  function discoverTemplateHostProps(notes) {
    let hostProps = {};
    for (let i=0, n; (i<notes.length) && (n=notes[i]); i++) {
      // Find all bindings to parent.* and spread them into _parentPropChain
      for (let j=0, b$=n.bindings, b; (j<b$.length) && (b=b$[j]); j++) {
        for (let k=0, p$=b.parts, p; (k<p$.length) && (p=p$[k]); k++) {
          if (p.signature) {
            let args = p.signature.args;
            for (let kk=0; kk<args.length; kk++) {
              let rootProperty = args[kk].rootProperty;
              if (rootProperty) {
                hostProps[rootProperty] = true;
              }
            }
            hostProps[p.signature.methodName] = true;
          } else {
            if (p.rootProperty) {
              hostProps[p.rootProperty] = true;
            }
          }
        }
      }
      // Merge child _hostProps into this _hostProps
      if (n.templateContent) {
        let templateHostProps = n.templateContent._hostProps;
        Polymer.Base.mixin(hostProps, templateHostProps);
      }
    }
    return hostProps;
  }

  /**
   * Returns true if a binding's metadata meets all the requirements to allow
   * 2-way binding, and therefore a <property>-changed event listener should be
   * added:
   * - used curly braces
   * - is a property (not attribute) binding
   * - is not a textContent binding
   * - is not compound
   *
   * @param {Object} binding Binding metadata
   * @return {boolean} True if 2-way listener should be added
   * @private
   */
  function shouldAddListener(binding) {
    return binding.name &&
           binding.kind != 'attribute' &&
           binding.kind != 'text' &&
           !binding.isCompound &&
           binding.parts[0].mode === '{';
  }

  /**
   * Sets up a prototypical `__notifyListeners` metadata array to be used at
   * instance time to add event listeners for 2-way bindings.
   *
   * @param {Object} model Prototype (instances not currently supported)
   * @param {number} index Index into `_templateNodes` list of annotated nodes that the
   *   event should be added to
   * @param {string} property Property of target node to listen for changes
   * @param {string} path Host path that the change should be propagated to
   * @param {string=} event A custom event name to listen for (e.g. via the
   *   `{{prop::eventName}}` syntax)
   * @param {boolean=} negate Whether the notified value should be negated before
   *   setting to host path
   * @private
   */
  function addAnnotatedListener(model, index, property, path, event, negate) {
    let eventName = event ||
      (CaseMap.camelToDashCase(property) + '-changed');
    model.__notifyListeners = model.__notifyListeners || [];
    model.__notifyListeners.push({
      index: index,
      property: property,
      path: path,
      event: eventName,
      negate: negate
    });
  }

  /**
   * Adds all 2-way binding notification listeners to a host based on
   * `__notifyListeners` metadata recorded by prior calls to`addAnnotatedListener`
   *
   * @param {Object} inst Host element instance
   * @private
   */
  function setupNotifyListeners(inst) {
    let b$ = inst.__notifyListeners;
    for (let i=0, l=b$.length, info; (i<l) && (info=b$[i]); i++) {
      let node = inst._templateNodes[info.index];
      addNotifyListener(node, inst, info);
    }
  }

  /**
   * On the `inst` element that was previously bound, uses `inst._templateNotes`
   * to setup compound binding storage structures onto the bound
   * nodes (`inst._templateNodes`).
   * (`inst._, and 2-way binding event listeners are also added.)
   *
   * @param {Object} inst Instance that bas been previously bound
   * @private
   */
  function setupBindings(inst) {
    let notes = inst._templateNotes;
    if (notes.length) {
      for (let i=0; i < notes.length; i++) {
        let note = notes[i];
        let node = inst._templateNodes[i];
        node.__dataHost = inst;
        if (note.bindings) {
          setupCompoundBinding(note, node);
        }
      }
    }
    if (inst.__notifyListeners) {
      setupNotifyListeners(inst);
    }
  }

  // -- for method-based effects (complexObserver & computed) --------------

  /**
   * Adds property effects for each argument in the method signature (and
   * optionally, for the method name if `dynamic` is true) that calls the
   * provided effect function.
   *
   * @param {Element | Object} model Prototype or instance
   * @param {Object} sig Method signature metadata
   * @param {string} type
   * @param {Function} effectFn Function to run when arguments change
   * @param {*=} methodInfo
   * @param {Object=} dynamicFns Map indicating whether method names should
   *   be included as a dependency to the effect.
   * @private
   */
  function createMethodEffect(model, sig, type, effectFn, methodInfo, dynamicFns) {
    let dynamicFn = sig.static || dynamicFns && dynamicFns[sig.methodName];
    let info = {
      methodName: sig.methodName,
      args: sig.args,
      methodInfo,
      dynamicFn
    };
    for (let i=0, arg; (i<sig.args.length) && (arg=sig.args[i]); i++) {
      if (!arg.literal) {
        model._addPropertyEffect(arg.rootProperty, type, {
          fn: effectFn, info: info, trigger: arg
        });
      }
    }
    if (dynamicFn) {
      model._addPropertyEffect(sig.methodName, type, {
        fn: effectFn, info: info
      });
    }
  }

  /**
   * Calls a method with arguments marshaled from properties on the instance
   * based on the method signature contained in the effect metadata.
   *
   * Multi-property observers, computed properties, and inline computing
   * functions call this function to invoke the method, then use the return
   * value accordingly.
   *
   * @param {Object} inst The instance the effect will be run on
   * @param {string} property Name of property
   * @param {*} value Current value of property
   * @param {*} old Previous value of property
   * @param {Object} info Effect metadata
   * @private
   */
  function runMethodEffect(inst, property, props, oldProps, info) {
    // Instances can optionally have a _methodHost which allows redirecting where
    // to find methods. Currently used by `templatize`.
    let context = inst._methodHost || inst;
    let fn = context[info.methodName];
    if (fn) {
      let args = marshalArgs(inst.__data, info.args, property, props);
      return fn.apply(context, args);
    } else if (!info.dynamicFn) {
      console.warn('method `' + info.methodName + '` not defined');
    }
  }

  const emptyArray = [];

  /**
   * Parses an expression string for a method signature, and returns a metadata
   * describing the method in terms of `methodName`, `static` (whether all the
   * arguments are literals), and an array of `args`
   *
   * @param {string} expression The expression to parse
   * @return {?Object} The method metadata object if a method expression was
   *   found, otherwise `undefined`
   * @private
   */
  function parseMethod(expression) {
    // tries to match valid javascript property names
    let m = expression.match(/([^\s]+?)\(([\s\S]*)\)/);
    if (m) {
      let sig = { methodName: m[1], static: true };
      if (m[2].trim()) {
        // replace escaped commas with comma entity, split on un-escaped commas
        let args = m[2].replace(/\\,/g, '&comma;').split(',');
        return parseArgs(args, sig);
      } else {
        sig.args = emptyArray;
        return sig;
      }
    }
    return null;
  }

  /**
   * Parses an array of arguments and sets the `args` property of the supplied
   * signature metadata object. Sets the `static` property to false if any
   * argument is a non-literal.
   *
   * @param {Array<string>} argList Array of argument names
   * @param {Object} sig Method signature metadata object
   * @return {Object} The updated signature metadata object
   * @private
   */
  function parseArgs(argList, sig) {
    sig.args = argList.map(function(rawArg) {
      let arg = parseArg(rawArg);
      if (!arg.literal) {
        sig.static = false;
      }
      return arg;
    }, this);
    return sig;
  }

  /**
   * Parses an individual argument, and returns an argument metadata object
   * with the following fields:
   *
   *   {
   *     value: 'prop',        // property/path or literal value
   *     literal: false,       // whether argument is a literal
   *     structured: false,    // whether the property is a path
   *     rootProperty: 'prop', // the root property of the path
   *     wildcard: false       // whether the argument was a wildcard '.*' path
   *   }
   *
   * @param {string} rawArg The string value of the argument
   * @return {Object} Argument metadata object
   * @private
   */
  function parseArg(rawArg) {
    // clean up whitespace
    let arg = rawArg.trim()
      // replace comma entity with comma
      .replace(/&comma;/g, ',')
      // repair extra escape sequences; note only commas strictly need
      // escaping, but we allow any other char to be escaped since its
      // likely users will do this
      .replace(/\\(.)/g, '\$1')
      ;
    // basic argument descriptor
    let a = {
      name: arg
    };
    // detect literal value (must be String or Number)
    let fc = arg[0];
    if (fc === '-') {
      fc = arg[1];
    }
    if (fc >= '0' && fc <= '9') {
      fc = '#';
    }
    switch(fc) {
      case "'":
      case '"':
        a.value = arg.slice(1, -1);
        a.literal = true;
        break;
      case '#':
        a.value = Number(arg);
        a.literal = true;
        break;
    }
    // if not literal, look for structured path
    if (!a.literal) {
      a.rootProperty = Polymer.Path.root(arg);
      // detect structured path (has dots)
      a.structured = Polymer.Path.isDeep(arg);
      if (a.structured) {
        a.wildcard = (arg.slice(-2) == '.*');
        if (a.wildcard) {
          a.name = arg.slice(0, -2);
        }
      }
    }
    return a;
  }

  /**
   * Gather the argument values for a method specified in the provided array
   * of argument metadata.
   *
   * The `path` and `value` arguments are used to fill in wildcard descriptor
   * when the method is being called as a result of a path notification.
   *
   * @param {Object} data Instance data storage object to read properties from
   * @param {Array<Object>} args Array of argument metadata
   * @return {Array<*>} Array of argument values
   * @private
   */
  function marshalArgs(data, args, path, props) {
    let values = [];
    for (let i=0, l=args.length; i<l; i++) {
      let arg = args[i];
      let name = arg.name;
      let v;
      if (arg.literal) {
        v = arg.value;
      } else {
        if (arg.structured) {
          v = Polymer.Path.get(data, name);
          // when data is not stored e.g. `splices`
          if (v === undefined) {
            v = props[name];
          }
        } else {
          v = data[name];
        }
      }
      if (arg.wildcard) {
        // Only send the actual path changed info if the change that
        // caused the observer to run matched the wildcard
        let baseChanged = (name.indexOf(path + '.') === 0);
        let matches = (path.indexOf(name) === 0 && !baseChanged);
        values[i] = {
          path: matches ? path : name,
          value: matches ? props[path] : v,
          base: v
        };
      } else {
        values[i] = v;
      }
    }
    return values;
  }

  /**
   * Initializes `__dataCompoundStorage` local storage on a bound node with
   * initial literal data for compound bindings, and sets the joined
   * literal parts to the bound property.
   *
   * When changes to compound parts occur, they are first set into the compound
   * storage array for that property, and then the array is joined to result in
   * the final value set to the property/attribute.
   *
   * @param {Object} note Annotation metadata
   * @param {Node} node Bound node to initialize
   * @private
   */
  function setupCompoundBinding(note, node) {
    let bindings = note.bindings;
    for (let i=0; i<bindings.length; i++) {
      let binding = bindings[i];
      if (binding.isCompound) {
        // Create compound storage map
        let storage = node.__dataCompoundStorage ||
          (node.__dataCompoundStorage = {});
        let parts = binding.parts;
        // Copy literals from parts into storage for this binding
        let literals = new Array(parts.length);
        for (let j=0; j<parts.length; j++) {
          literals[j] = parts[j].literal;
        }
        let name = binding.name;
        storage[name] = literals;
        // Configure properties with their literal parts
        if (binding.literal && binding.kind == 'property') {
          node[name] = binding.literal;
        }
      }
    }
  }

  // data api

  /**
   * Sends array splice notifications (`.splices` and `.length`)
   *
   * Note: this implementation only accepts normalized paths
   *
   * @param {Element} inst Instance to send notifications to
   * @param {Array} array The array the mutations occurred on
   * @param {string} path The path to the array that was mutated
   * @param {Array} splices Array of splice records
   * @private
   */
  function notifySplices(inst, array, path, splices) {
    let splicesPath = path + '.splices';
    inst.notifyPath(splicesPath, { indexSplices: splices });
    inst.notifyPath(path + '.length', array.length);
    // Null here to allow potentially large splice records to be GC'ed.
    inst.__data[splicesPath] = {indexSplices: null};
  }

  /**
   * Creates a splice record and sends an array splice notification for
   * the described mutation
   *
   * Note: this implementation only accepts normalized paths
   *
   * @param {Element} inst Instance to send notifications to
   * @param {Array} array The array the mutations occurred on
   * @param {string} path The path to the array that was mutated
   * @param {number} index Index at which the array mutation occurred
   * @param {number} addedCount Number of added items
   * @param {Array} removed Array of removed items
   * @private
   */
  function notifySplice(inst, array, path, index, addedCount, removed) {
    notifySplices(inst, array, path, [{
      index: index,
      addedCount: addedCount,
      removed: removed,
      object: array,
      type: 'splice'
    }]);
  }

  /**
   * Returns an upper-cased version of the string.
   *
   * @param {string} name String to uppercase
   * @return {string} Uppercased string
   * @private
   */
  function upper(name) {
    return name[0].toUpperCase() + name.substring(1);
  }

  /**
   * Sets the provided properties into pending data on the instance.
   *
   * @param {HTMLElement} inst Instance to apply data to
   * @param {object} props Bag of instance properties to set
   */
  function initalizeInstanceProperties(inst, props) {
    inst.__dataOld = inst.__dataOld || {};
    inst.__dataPending = inst.__dataPending || {};
    let readOnly = inst.__readOnly;
    for (let prop in props) {
      if (!readOnly || !readOnly[prop]) {
        inst.__data[prop] = inst.__dataPending[prop] = props[prop];
      }
    }
  }

  Polymer.PropertyEffects = Polymer.dedupingMixin(function(superClass) {

    const mixin = Polymer.TemplateStamp(Polymer.PropertyAccessors(superClass));

    /**
     * @unrestricted
     */
    class PropertyEffects extends mixin {

      get PROPERTY_EFFECT_TYPES() {
        return TYPES;
      }

      _initializeProperties() {
        super._initializeProperties();
        hostStack.registerHost(this);
        this.__dataInitialized = false;
        this.__dataPendingClients = null;
        this.__dataToNotify = null;
        this.__dataLinkedPaths = null;
        this.__dataHasPaths = false;
        // May be set on instance prior to upgrade
        this.__dataCompoundStorage = this.__dataCompoundStorage || null;
        this.__dataHost = this.__dataHost || null;
        this.__dataTemp = {};
        // Capture instance properties; these will be set into accessors
        // during first flush. Don't set them here, since we want
        // these to overwrite defaults/constructor assignments
        for (let p in this.__propertyEffects) {
          if (this.hasOwnProperty(p)) {
            this.__dataInstanceProps = this.__dataInstanceProps || {};
            this.__dataInstanceProps[p] = this[p];
            delete this[p];
          }
        }
      }

      _initializeProtoProperties(props) {
        this.__data = Object.create(props);
        this.__dataPending = Object.create(props);
        this.__dataOld = {};
      }

      // Prototype setup ----------------------------------------

      /**
       * Ensures an accessor exists for the specified property, and adds
       * to a list of "property effects" that will run when the accessor for
       * the specified property is set.  Effects are grouped by "type", which
       * roughly corresponds to a phase in effect processing.  The effect
       * metadata should be in the following form:
       *
       *   {
       *     fn: effectFunction, // Reference to function to call to perform effect
       *     info: { ... }       // Effect metadata passed to function
       *     // path: '...'      // Will be set by this method based on path arg
       *   }
       *
       * Effect functions are called with the following signature:
       *
       *   effectFunction(inst, property, currentValue, oldValue, info)
       *
       * This method may be called either on the prototype of a class
       * using the PropertyEffects mixin (for best performance), or on
       * an instance to add dynamic effects.  When called on an instance or
       * subclass of a class that has already had property effects added to
       * its prototype, the property effect lists will be cloned and added as
       * own properties of the caller.
       *
       * @param {string} path Property (or path) that should trigger the effect
       * @param {string} type Effect type, from this.PROPERTY_EFFECT_TYPES
       * @param {Object=} effect Effect metadata object
       * @protected
       */
      _addPropertyEffect(property, type, effect) {
        let effects = ensureOwnEffectMap(this, TYPES.ANY)[property];
        if (!effects) {
          effects = this.__propertyEffects[property] = [];
          this._createPropertyAccessor(property,
            type == TYPES.READ_ONLY);
        }
        // effects are accumulated into arrays per property based on type
        if (effect) {
          effects.push(effect);
        }
        effects = ensureOwnEffectMap(this, type)[property];
        if (!effects) {
          effects = this[type][property] = [];
        }
        effects.push(effect);
      }

      /**
       * Returns whether the current prototype/instance has a property effect
       * of a certain type.
       *
       * @param {string} property Property name
       * @param {string=} type Effect type, from this.PROPERTY_EFFECT_TYPES
       * @return {boolean} True if the prototype/instance has an effect of this type
       * @protected
       */
      _hasPropertyEffect(property, type) {
        let effects = this[type || TYPES.ANY];
        return Boolean(effects && effects[property]);
      }

      /**
       * Returns whether the current prototype/instance has a "read only"
       * accessor for the given property.
       *
       * @param {string} property Property name
       * @return {boolean} True if the prototype/instance has an effect of this type
       * @protected
       */
      _hasReadOnlyEffect(property) {
        return this._hasPropertyEffect(property, TYPES.READ_ONLY);
      }

      /**
       * Returns whether the current prototype/instance has a "notify"
       * property effect for the given property.
       *
       * @param {string} property Property name
       * @return {boolean} True if the prototype/instance has an effect of this type
       * @protected
       */
      _hasNotifyEffect(property) {
        return this._hasPropertyEffect(property, TYPES.NOTIFY);
      }

      /**
       * Returns whether the current prototype/instance has a "reflect to attribute"
       * property effect for the given property.
       *
       * @param {string} property Property name
       * @return {boolean} True if the prototype/instance has an effect of this type
       * @protected
       */
      _hasReflectEffect(property) {
        return this._hasPropertyEffect(property, TYPES.REFLECT);
      }

      /**
       * Returns whether the current prototype/instance has a "computed"
       * property effect for the given property.
       *
       * @param {string} property Property name
       * @return {boolean} True if the prototype/instance has an effect of this type
       * @protected
       */
      _hasComputedEffect(property) {
        return this._hasPropertyEffect(property, TYPES.COMPUTE);
      }

      // Runtime ----------------------------------------

      /**
       * Sets a pending property or path.  If the root property of the path in
       * question had no accessor, the path is set, otherwise it is enqueued
       * via `_setPendingProperty`.
       *
       * This function isolates relatively expensive functionality necessary
       * for the public API (`set`, `setProperties`, `notifyPath`, and property
       * change listeners via {{...}} bindings), such that it is only done
       * when paths enter the system, and not at every propagation step.  It
       * also sets a `__dataHasPaths` flag on the instance which is used to
       * fast-path slower path-matching code in the property effects host paths.
       *
       * `path` can be a path string or array of path parts as accepted by the
       * public API.
       *
       * @param {string | !Array<number|string>} path Path to set
       * @param {*} value Value to set
       * @param {boolean=} isPathNotification If the path being set is a path
       *   notification of an already changed value, as opposed to a request
       *   to set and notify the change.  In the latter `false` case, a dirty
       *   check is performed and then the value is set to the path before
       *   enqueuing the pending property change.
       * @return {boolean} Returns true if the property/path was enqueued in
       *   the pending changes bag.
       * @protected
       */
      _setPendingPropertyOrPath(path, value, shouldNotify, isPathNotification) {
        let rootProperty = Polymer.Path.root(Array.isArray(path) ? path[0] : path);
        let hasEffect = this.__propertyEffects && this.__propertyEffects[rootProperty];
        let isPath = (rootProperty !== path);
        if (hasEffect) {
          if (isPath) {
            if (!isPathNotification) {
              // Dirty check changes being set to a path against the actual object,
              // since this is the entry point for paths into the system; from here
              // the only dirty checks are against the `__dataTemp` cache to prevent
              // duplicate work in the same turn only. Note, if this was a notification
              // of a change already set to a path (isPathNotification: true),
              // we always let the change through and skip the `set` since it was
              // already dirty checked at the point of entry and the underlying
              // object has already been updated
              let old = Polymer.Path.get(this, path);
              path = /** @type {string} */ Polymer.Path.set(this, path, value);
              // Use property-accessor's simpler dirty check
              if (!path || !super._shouldPropertyChange(path, value, old)) {
                return false;
              }
            }
            this.__dataHasPaths = true;
          }
          return this._setPendingProperty(path, value, shouldNotify);
        } else {
          if (isPath) {
            Polymer.Path.set(this, path, value);
          } else {
            this[path] = value;
          }
        }
        return false;
      }

      /**
       * Applies a value to a non-Polymer element/node's property.
       *
       * The implementation makes a best-effort at binding interop:
       * Some native element properties have side-effects when
       * re-setting the same value (e.g. setting <input>.value resets the
       * cursor position), so we do a dirty-check before setting the value.
       * However, for better interop with non-Polymer custom elements that
       * accept objects, we explicitly re-set object changes coming from the
       * Polymer world (which may include deep object changes without the
       * top reference changing), erring on the side of providing more
       * information.
       *
       * Users may override this method to provide alternate approaches.
       *
       * @param {Node} node The node to set a property on
       * @param {string} prop The property to set
       * @param {*} value The value to set
       */
      _setUnmanagedPropertyToNode(node, prop, value) {
        // It is a judgment call that resetting primitives is
        // "bad" and resettings objects is also "good"; alternatively we could
        // implement a whitelist of tag & property values that should never
        // be reset (e.g. <input>.value && <select>.value)
        if (value !== node[prop] || typeof value == 'object') {
          node[prop] = value;
        }
      }

      /**
       * Overrides the `PropertyAccessors` implementation to introduce special
       * dirty check logic depending on the property & value being set:
       *
       * 1. Any value set to a path (e.g. 'obj.prop': 42 or 'obj.prop': {...})
       *    Stored in `__dataTemp`, dirty checked against `__dataTemp`
       * 2. Object set to simple property (e.g. 'prop': {...})
       *    Stored in `__dataTemp` and `__data`, dirty checked against
       *    `__dataTemp` by default implementation of `_shouldPropertyChange`
       * 3. Primitive value set to simple property (e.g. 'prop': 42)
       *    Stored in `__data`, dirty checked against `__data`
       *
       * The dirty-check is important to prevent cycles due to two-way
       * notification, but paths and objects are only dirty checked against any
       * previous value set during this turn via a "temporary cache" that is
       * cleared when the last `_propertiesChaged` exits. This is so:
       * a. any cached array paths (e.g. 'array.3.prop') may be invalidated
       *    due to array mutations like shift/unshift/splice; this is fine
       *    since path changes are dirty-checked at user entry points like `set`
       * b. dirty-checking for objects only lasts one turn to allow the user
       *    to mutate the object in-place and re-set it with the same identity
       *    and have all sub-properties re-propagated in a subsequent turn.
       *
       * The temp cache is not necessarily sufficient to prevent invalid array
       * paths, since a splice can happen during the same turn (with pathological
       * user code); we could introduce a "fixup" for temporarily cached array
       * paths if needed: https://github.com/Polymer/polymer/issues/4227
       *
       * @override
       */
      _setPendingProperty(property, value, shouldNotify) {
        let isPath = this.__dataHasPaths && Polymer.Path.isPath(property);
        let prevProps = isPath ? this.__dataTemp : this.__data;
        if (this._shouldPropertyChange(property, value, prevProps[property])) {
          if (!this.__dataPending) {
            this.__dataPending = {};
            this.__dataOld = {};
          }
          // Ensure old is captured from the last turn
          if (!(property in this.__dataOld)) {
            this.__dataOld[property] = this.__data[property];
          }
          // Paths and objects are stored in temporary cache (cleared at end of
          // turn), which is used for dirty-checking
          if (isPath || typeof value == 'object') {
            this.__dataTemp[property] = value;
          }
          // Properties (but not sub-paths) get stored __data cache, used to
          // return accessor values from getters
          if (!isPath) {
            this.__data[property] = value;
          }
          // All changes go into pending property bag, passed to _propertiesChanged
          this.__dataPending[property] = value;
          // Track properties that should notify separately
          if (isPath || (this.__notifyEffects && this.__notifyEffects[property])) {
            this.__dataToNotify = this.__dataToNotify || {};
            this.__dataToNotify[property] = shouldNotify;
          }
          return true;
        }
      }

      /**
       * Overrides base implementation to ensure all accessors set `shouldNotify`
       * to true, for per-property notification tracking.
       *
       * @override
       */
      _setProperty(property, value) {
        if (this._setPendingProperty(property, value, true)) {
          this._invalidateProperties();
        }
      }

      /**
       * Overrides default PropertyAccessors implementation to pull the value
       * to dirty check against from the `__dataTemp` cache (rather than the
       * normal `__data` cache) for Objects.  Since the temp cache is cleared
       * at the end of a turn, this implementation allows side-effects of deep
       * object changes to be processed by re-setting the same object (using
       * the temp cache as a backstop to prevent cycles due to 2-way
       * notification).
       *
       * Override this to provide more strict dirty checking, i.e. immutable
       * (`value === old`) or based on type.
       *
       * @override
       * @param {string} property
       * @param {*} value
       * @param {*} old
       * @return {boolean}
       */
      _shouldPropertyChange(property, value, old) {
        if (typeof value == 'object') {
          old = this.__dataTemp[property];
        }
        return super._shouldPropertyChange(property, value, old);
      }

      /**
       * Overrides PropertyAccessor's default async queuing of
       * `_propertiesChanged`: if `__dataInitialized` is false (has not yet been
       * manually flushed), the function no-ops; otherwise flushes
       * `_propertiesChanged` synchronously.
       *
       * @override
       */
      _invalidateProperties() {
        if (this.__dataInitialized) {
          this._flushProperties();
        }
      }

      /**
       * Enqueues the given client on a list of pending clients, whose
       * pending property changes can later be flushed via a call to
       * `_flushClients`.
       *
       * @param {Object} client PropertyEffects client to enqueue
       * @protected
       */
      _enqueueClient(client) {
        this.__dataPendingClients = this.__dataPendingClients || [];
        if (client !== this) {
          this.__dataPendingClients.push(client);
        }
      }

      /**
       * Flushes any clients previously enqueued via `_enqueueClient`, causing
       * their `_flushProperties` method to run.
       *
       * @protected
       */
      _flushClients() {
        // Flush all clients
        let clients = this.__dataPendingClients;
        if (clients) {
          this.__dataPendingClients = null;
          for (let i=0; i < clients.length; i++) {
            let client = clients[i];
            if (!client.__dataInitialized || client.__dataPending) {
              client._flushProperties();
            }
          }
        }
      }

      /**
       * Sets a bag of property changes to this instance, and
       * synchronously processes all effects of the properties as a batch.
       *
       * Property names must be simple properties, not paths.  Batched
       * path propagation is not supported.
       *
       * @param {Object} props Bag of one or more key-value pairs whose key is
       *   a property and value is the new value to set for that property.
       */
      setProperties(props) {
        for (let path in props) {
          if (!this.__readOnly || !this.__readOnly[path]) {
            //TODO(kschaaf): explicitly disallow paths in setProperty?
            // wildcard observers currently only pass the first changed path
            // in the `info` object, and you could do some odd things batching
            // paths, e.g. {'foo.bar': {...}, 'foo': null}
            this._setPendingPropertyOrPath(path, props[path], true);
          }
        }
        this._invalidateProperties();
      }
      /**
       * Overrides PropertyAccessor's default async queuing of
       * `_propertiesChanged`, to instead synchronously flush
       * `_propertiesChanged` unless the `this._asyncEffects` property is true.
       *
       * If this is the first time properties are being flushed, the `ready`
       * callback will be called.
       *
       * @override
       */
      _flushProperties() {
        if (!this.__dataInitialized) {
          this.ready()
        } else if (this.__dataPending || this.__dataPendingClients) {
          super._flushProperties();
          if (!this.__dataCounter) {
            // Clear temporary cache at end of turn
            this.__dataTemp = {};
          }
        }
      }

      /**
       * Polymer-specific lifecycle callback called the first time properties
       * are being flushed.  Prior to `ready`, all property sets through
       * accessors are queued and their effects are flushed after this method
       * returns.
       *
       * Users may override this function to implement behavior that is
       * dependent on the element having its properties initialized, e.g.
       * from defaults (initialized from `constructor`, `_initializeProperties`),
       * `attributeChangedCallback`, or binding values propagated from host
       * "binding effects".  `super.ready()` must be called to ensure the
       * data system becomes enabled.
       *
       * @public
       */
      ready() {
        // Update instance properties that shadowed proto accessors; these take
        // priority over any defaults set in `properties` or constructor
        let instanceProps = this.__dataInstanceProps;
        if (instanceProps) {
          initalizeInstanceProperties(this, instanceProps);
        }
        // Enable acceessors
        this.__dataInitialized = true;
        // Run normal flush
        this._flushProperties();
      }

      /**
       * Stamps the provided template and performs instance-time setup for
       * Polymer template features, including data bindings, declarative event
       * listeners, and the `this.$` map of `id`'s to nodes.  A document fragment
       * is returned containing the stamped DOM, ready for insertion into the
       * DOM.
       *
       * Note that for host data to be bound into the stamped DOM, the template
       * must have been previously bound to the prototype via a call to
       * `_bindTemplate`, which performs one-time template binding work.
       *
       * Note that this method currently only supports being called once per
       * instance.
       *
       * @param {HTMLTemplateElement} template Template to stamp
       * @return {DocumentFragment} Cloned template content
       * @protected
       */
      _stampTemplate(template) {
        hostStack.beginHosting(this);
        let dom = super._stampTemplate(template);
        hostStack.endHosting(this);
        setupBindings(this);
        return dom;
      }

      /**
       * Implements `PropertyAccessors`'s properties changed callback.
       *
       * Runs each class of effects for the batch of changed properties in
       * a specific order (compute, propagate, reflect, observe, notify).
       *
       * @override
       */
      _propertiesChanged(currentProps, changedProps, oldProps) {
        // ----------------------------
        // let c = Object.getOwnPropertyNames(changedProps || {});
        // window.debug && console.group(this.localName + '#' + this.id + ': ' + c);
        // if (window.debug) { debugger; }
        // ----------------------------
        let hasPaths = this.__dataHasPaths;
        this.__dataHasPaths = false;
        // Compute properties
        runComputedEffects(this, changedProps, oldProps, hasPaths);
        // Compute linked paths
        computeLinkedPaths(this, changedProps, hasPaths);
        // Clear notify properties prior to possible reentry (propagate, observe),
        // but after computing effects have a chance to add to them
        let notifyProps = this.__dataToNotify;
        this.__dataToNotify = null;
        // Propagate properties to clients
        runEffects(this, this.__propagateEffects, changedProps, oldProps, hasPaths);
        // Flush clients
        this._flushClients();
        // Reflect properties
        runEffects(this, this.__reflectEffects, changedProps, oldProps, hasPaths);
        // Observe properties
        runEffects(this, this.__observeEffects, changedProps, oldProps, hasPaths);
        // Notify properties to host
        if (notifyProps) {
          runNotifyEffects(this, notifyProps, changedProps, oldProps, hasPaths);
        }
        // ----------------------------
        // window.debug && console.groupEnd(this.localName + '#' + this.id + ': ' + c);
        // ----------------------------
      }

      /**
       * Aliases one data path as another, such that path notifications from one
       * are routed to the other.
       *
       * @method linkPaths
       * @param {string | !Array<string|number>} to Target path to link.
       * @param {string | !Array<string|number>} from Source path to link.
       * @public
       */
      linkPaths(to, from) {
        to = Polymer.Path.normalize(to);
        from = Polymer.Path.normalize(from);
        this.__dataLinkedPaths = this.__dataLinkedPaths || {};
        this.__dataLinkedPaths[to] = from;
      }

      /**
       * Removes a data path alias previously established with `_linkPaths`.
       *
       * Note, the path to unlink should be the target (`to`) used when
       * linking the paths.
       *
       * @method unlinkPaths
       * @param {string | !Array<string|number>} path Target path to unlink.
       * @public
       */
      unlinkPaths(path) {
        path = Polymer.Path.normalize(path);
        if (this.__dataLinkedPaths) {
          delete this.__dataLinkedPaths[path];
        }
      }

      /**
       * Notify that an array has changed.
       *
       * Example:
       *
       *     this.items = [ {name: 'Jim'}, {name: 'Todd'}, {name: 'Bill'} ];
       *     ...
       *     this.items.splice(1, 1, {name: 'Sam'});
       *     this.items.push({name: 'Bob'});
       *     this.notifySplices('items', [
       *       { index: 1, removed: [{name: 'Todd'}], addedCount: 1, obect: this.items, type: 'splice' },
       *       { index: 3, removed: [], addedCount: 1, object: this.items, type: 'splice'}
       *     ]);
       *
       * @param {string} path Path that should be notified.
       * @param {Array} splices Array of splice records indicating ordered
       *   changes that occurred to the array. Each record should have the
       *   following fields:
       *    * index: index at which the change occurred
       *    * removed: array of items that were removed from this index
       *    * addedCount: number of new items added at this index
       *    * object: a reference to the array in question
       *    * type: the string literal 'splice'
       *
       *   Note that splice records _must_ be normalized such that they are
       *   reported in index order (raw results from `Object.observe` are not
       *   ordered and must be normalized/merged before notifying).
       * @public
      */
      notifySplices(path, splices) {
        let info = {};
        let array = /** @type {Array} */(Polymer.Path.get(this, path, info));
        notifySplices(this, array, info.path, splices);
      }

      /**
       * Convenience method for reading a value from a path.
       *
       * Note, if any part in the path is undefined, this method returns
       * `undefined` (this method does not throw when dereferencing undefined
       * paths).
       *
       * @method get
       * @param {(string|!Array<(string|number)>)} path Path to the value
       *   to read.  The path may be specified as a string (e.g. `foo.bar.baz`)
       *   or an array of path parts (e.g. `['foo.bar', 'baz']`).  Note that
       *   bracketed expressions are not supported; string-based path parts
       *   *must* be separated by dots.  Note that when dereferencing array
       *   indices, the index may be used as a dotted part directly
       *   (e.g. `users.12.name` or `['users', 12, 'name']`).
       * @param {Object=} root Root object from which the path is evaluated.
       * @return {*} Value at the path, or `undefined` if any part of the path
       *   is undefined.
       * @public
       */
      get(path, root) {
        return Polymer.Path.get(root || this, path);
      }

      /**
       * Convenience method for setting a value to a path and notifying any
       * elements bound to the same path.
       *
       * Note, if any part in the path except for the last is undefined,
       * this method does nothing (this method does not throw when
       * dereferencing undefined paths).
       *
       * @method set
       * @param {(string|!Array<(string|number)>)} path Path to the value
       *   to write.  The path may be specified as a string (e.g. `'foo.bar.baz'`)
       *   or an array of path parts (e.g. `['foo.bar', 'baz']`).  Note that
       *   bracketed expressions are not supported; string-based path parts
       *   *must* be separated by dots.  Note that when dereferencing array
       *   indices, the index may be used as a dotted part directly
       *   (e.g. `'users.12.name'` or `['users', 12, 'name']`).
       * @param {*} value Value to set at the specified path.
       * @param {Object=} root Root object from which the path is evaluated.
       *   When specified, no notification will occur.
       * @public
      */
      set(path, value, root) {
        if (root) {
          Polymer.Path.set(root, path, value);
        } else {
          if (!this.__readOnly || !this.__readOnly[/** @type {string} */(path)]) {
            if (this._setPendingPropertyOrPath(path, value, true)) {
              this._invalidateProperties();
            }
          }
        }
      }

      /**
       * Adds items onto the end of the array at the path specified.
       *
       * The arguments after `path` and return value match that of
       * `Array.prototype.push`.
       *
       * This method notifies other paths to the same array that a
       * splice occurred to the array.
       *
       * @method push
       * @param {string} path Path to array.
       * @param {...*} items Items to push onto array
       * @return {number} New length of the array.
       * @public
       */
      push(path, ...items) {
        let info = {};
        let array = /** @type {Array}*/(Polymer.Path.get(this, path, info));
        let len = array.length;
        let ret = array.push(...items);
        if (items.length) {
          notifySplice(this, array, info.path, len, items.length, []);
        }
        return ret;
      }

      /**
       * Removes an item from the end of array at the path specified.
       *
       * The arguments after `path` and return value match that of
       * `Array.prototype.pop`.
       *
       * This method notifies other paths to the same array that a
       * splice occurred to the array.
       *
       * @method pop
       * @param {string} path Path to array.
       * @return {*} Item that was removed.
       * @public
       */
      pop(path) {
        let info = {};
        let array = /** @type {Array} */(Polymer.Path.get(this, path, info));
        let hadLength = Boolean(array.length);
        let ret = array.pop();
        if (hadLength) {
          notifySplice(this, array, info.path, array.length, 0, [ret]);
        }
        return ret;
      }

      /**
       * Starting from the start index specified, removes 0 or more items
       * from the array and inserts 0 or more new items in their place.
       *
       * The arguments after `path` and return value match that of
       * `Array.prototype.splice`.
       *
       * This method notifies other paths to the same array that a
       * splice occurred to the array.
       *
       * @method splice
       * @param {string} path Path to array.
       * @param {number} start Index from which to start removing/inserting.
       * @param {number} deleteCount Number of items to remove.
       * @param {...*} items Items to insert into array.
       * @return {Array} Array of removed items.
       * @public
       */
      splice(path, start, deleteCount, ...items) {
        let info = {};
        let array = /** @type {Array} */(Polymer.Path.get(this, path, info));
        // Normalize fancy native splice handling of crazy start values
        if (start < 0) {
          start = array.length - Math.floor(-start);
        } else {
          start = Math.floor(start);
        }
        if (!start) {
          start = 0;
        }
        let ret = array.splice(start, deleteCount, ...items);
        if (items.length || ret.length) {
          notifySplice(this, array, info.path, start, items.length, ret);
        }
        return ret;
      }

      /**
       * Removes an item from the beginning of array at the path specified.
       *
       * The arguments after `path` and return value match that of
       * `Array.prototype.pop`.
       *
       * This method notifies other paths to the same array that a
       * splice occurred to the array.
       *
       * @method shift
       * @param {string} path Path to array.
       * @return {*} Item that was removed.
       * @public
       */
      shift(path) {
        let info = {};
        let array = /** @type {Array} */(Polymer.Path.get(this, path, info));
        let hadLength = Boolean(array.length);
        let ret = array.shift();
        if (hadLength) {
          notifySplice(this, array, info.path, 0, 0, [ret]);
        }
        return ret;
      }

      /**
       * Adds items onto the beginning of the array at the path specified.
       *
       * The arguments after `path` and return value match that of
       * `Array.prototype.push`.
       *
       * This method notifies other paths to the same array that a
       * splice occurred to the array.
       *
       * @method unshift
       * @param {string} path Path to array.
       * @param {...*} items Items to insert info array
       * @return {number} New length of the array.
       * @public
       */
      unshift(path, ...items) {
        let info = {};
        let array = /** @type {Array} */(Polymer.Path.get(this, path, info));
        let ret = array.unshift(...items);
        if (items.length) {
          notifySplice(this, array, info.path, 0, items.length, []);
        }
        return ret;
      }

      /**
       * Notify that a path has changed.
       *
       * Example:
       *
       *     this.item.user.name = 'Bob';
       *     this.notifyPath('item.user.name');
       *
       * @param {string} path Path that should be notified.
       * @param {*=} value Value at the path (optional).
       * @public
      */
      notifyPath(path, value) {
        /** @type {string} */
        let propPath;
        if (arguments.length == 1) {
          // Get value if not supplied
          let info = {};
          value = Polymer.Path.get(this, path, info);
          propPath = info.path;
        } else if (Array.isArray(path)) {
          // Normalize path if needed
          propPath = Polymer.Path.normalize(path);
        } else {
          propPath = /** @type{string} */(path);
        }
        if (this._setPendingPropertyOrPath(propPath, value, true, true)) {
          this._invalidateProperties();
        }
      }

      /**
       * Creates a read-only accessor for the given property.
       *
       * To set the property, use the protected `_setProperty` API.
       * To create a custom protected setter (e.g. `_setMyProp()` for
       * property `myProp`), pass `true` for `protectedSetter`.
       *
       * Note, if the property will have other property effects, this method
       * should be called first, before adding other effects.
       *
       * @param {string} property Property name
       * @param {boolean=} protectedSetter Creates a custom protected setter
       *   when `true`.
       * @protected
       */
      _createReadOnlyProperty(property, protectedSetter) {
        this._addPropertyEffect(property, TYPES.READ_ONLY);
        if (protectedSetter) {
          this['_set' + upper(property)] = function(value) {
            this._setProperty(property, value);
          }
        }
      }

      /**
       * Creates a single-property observer for the given property.
       *
       * @param {string} property Property name
       * @param {string} methodName Name of observer method to call
       * @param {boolean=} dynamicFn Whether the method name should be included as
       *   a dependency to the effect.
       * @protected
       */
      _createPropertyObserver(property, methodName, dynamicFn) {
        let info = { property, methodName };
        this._addPropertyEffect(property, TYPES.OBSERVE, {
          fn: runObserverEffect, info, trigger: {name: property}
        });
        if (dynamicFn) {
          this._addPropertyEffect(methodName, TYPES.OBSERVE, {
            fn: runObserverEffect, info, trigger: {name: methodName}
          });
        }
      }

      /**
       * Creates a multi-property "method observer" based on the provided
       * expression, which should be a string in the form of a normal Javascript
       * function signature: `'methodName(arg1, [..., argn])'`.  Each argument
       * should correspond to a property or path in the context of this
       * prototype (or instance), or may be a literal string or number.
       *
       * @param {string} expression Method expression
       * @param {Object=} dynamicFns Map indicating whether method names should
       *   be included as a dependency to the effect.
       * @protected
       */
      _createMethodObserver(expression, dynamicFns) {
        let sig = parseMethod(expression);
        if (!sig) {
          throw new Error("Malformed observer expression '" + expression + "'");
        }
        createMethodEffect(this, sig, TYPES.OBSERVE, runMethodEffect, null, dynamicFns);
      }

      /**
       * Causes the setter for the given property to dispatch `<property>-changed`
       * events to notify of changes to the property.
       *
       * @param {string} property Property name
       * @protected
       */
      _createNotifyingProperty(property) {
        this._addPropertyEffect(property, TYPES.NOTIFY, {
          fn: runNotifyEffect,
          info: {
            eventName: CaseMap.camelToDashCase(property) + '-changed',
            property: property
          }
        });
      }

      /**
       * Causes the setter for the given property to reflect the property value
       * to a (dash-cased) attribute of the same name.
       *
       * @param {string} property Property name
       * @protected
       */
      _createReflectedProperty(property) {
        let attr = CaseMap.camelToDashCase(property);
        if (attr[0] === '-') {
          console.warn('Property ' + property + ' cannot be reflected to attribute ' +
            attr + ' because "-" is not a valid starting attribute name. Use a lowercase first letter for the property thisead.');
        } else {
          this._addPropertyEffect(property, TYPES.REFLECT, {
            fn: runReflectEffect,
            info: {
              attrName: attr
            }
          });
        }
      }

      /**
       * Creates a computed property whose value is set to the result of the
       * method described by the given `expression` each time one or more
       * arguments to the method changes.  The expression should be a string
       * in the form of a normal Javascript function signature:
       * `'methodName(arg1, [..., argn])'`
       *
       * @param {string} property Name of computed property to set
       * @param {string} expression Method expression
       * @param {Object=} dynamicFns Map indicating whether method names should
       *   be included as a dependency to the effect.
       * @protected
       */
      _createComputedProperty(property, expression, dynamicFns) {
        let sig = parseMethod(expression);
        if (!sig) {
          throw new Error("Malformed computed expression '" + expression + "'");
        }
        createMethodEffect(this, sig, TYPES.COMPUTE, runComputedEffect, property, dynamicFns);
      }

      // -- binding ----------------------------------------------

      /**
       * Creates "binding" property effects for all binding bindings
       * in the provided template that forward host properties into DOM stamped
       * from the template via `_stampTemplate`.
       *
       * @param {HTMLTemplateElement} template Template containing binding
       *   bindings
       * @param {Object=} dynamicFns Map indicating whether method names should
       *   be included as a dependency to the effect.
       * @protected
       */
      _bindTemplate(template, dynamicFns) {
        // Clear any existing propagation effects inherited from superClass
        this.__propagateEffects = {};
        this.__notifyListeners = [];
        let notes = this._parseTemplateAnnotations(template);
        processAnnotations(notes);
        for (let i=0, note; (i<notes.length) && (note=notes[i]); i++)  {
          // where to find the node in the concretized list
          let b$ = note.bindings;
          for (let j=0, binding; (j<b$.length) && (binding=b$[j]); j++) {
            if (shouldAddListener(binding)) {
              addAnnotatedListener(this, i, binding.name,
                binding.parts[0].value,
                binding.parts[0].event,
                binding.parts[0].negate);
            }
            addBindingEffect(this, binding, i, dynamicFns);
          }
        }
      }

    }

    return PropertyEffects;
  });

})();
</script>


<script>
Polymer.ElementMixin = Polymer.dedupingMixin(function(base) {

  const mixin = Polymer.PropertyEffects(base);

  let caseMap = Polymer.CaseMap;

  /**
   * Returns the config object specifically on `klass`. Use for:
   * (1) super chain mixes togther to make `propertiesForClass` which is
   * then used to make `observedAttributes`.
   * (2) properties effects and observers are created from it at `finalize` time.
   * @param {HTMLElement} klass
   * @private
   */
  function ownConfigForClass(klass) {
    if (!klass.hasOwnProperty(
      goog.reflect.objectProperty('__ownConfig', klass))) {
      klass.__ownConfig =
        klass.hasOwnProperty(goog.reflect.objectProperty('config', klass)) ?
        klass.config : {};
    }
    return klass.__ownConfig;
  }

  /**
   * Mixes `props` into `flattenedProps` but upgrades shorthand type
   * syntax to { type: Type}.
   * @param {Object} flattenedProps
   * @param {Object} props
   * @private
   */
  function flattenProperties(flattenedProps, props) {
    for (let p in props) {
      let o = props[p];
      if (typeof o == 'function') {
        o = { type: o };
      }
      flattenedProps[p] = o;
    }
    return flattenedProps;
  }

  /**
   * Returns a flattened list of properties mixed together from the chain of all
   * constructor's `config.properties`. This list is used to create
   * (1) observedAttributes,
   * (2) class property default values
   * @param {HTMLElement} klass
   * @private
   */
  function propertiesForClass(klass) {
    if (!klass.hasOwnProperty(
      goog.reflect.objectProperty('__classProperties', klass))) {
      klass.__classProperties =
      flattenProperties({}, ownConfigForClass(klass).properties);
      let superCtor = Object.getPrototypeOf(klass.prototype).constructor;
      if (superCtor.prototype instanceof PolymerElement) {
        klass.__classProperties = Polymer.mixin(
          Object.create(propertiesForClass(superCtor)),
          klass.__classProperties);
      }
    }
    return klass.__classProperties;
  }

  /**
   * Returns a list of properties with default values.
   * This list is created as an optimization since it is a subset of
   * the list returned from `propertiesForClass`.
   * This list is used in `_initializeProperties` to set property defaults.
   * @param {HTMLElement} klass
   * @private
   */
  function propertyDefaultsForClass(klass) {
    if (!klass.hasOwnProperty(
      goog.reflect.objectProperty('__classPropertyDefaults', klass))) {
      this.__classPropertyDefaults = null;
      let props = propertiesForClass(klass);
      for (let p in props) {
        let info = props[p];
        if ('value' in info) {
          klass.__classPropertyDefaults = klass.__classPropertyDefaults || {};
          klass.__classPropertyDefaults[p] = info;
        }
      }
    }
    return klass.__classPropertyDefaults;
  }

  /**
   * Returns true if a `klass` has finalized. Called in `ElementClass.finalize()`
   * @param {HTMLElement} klass
   * @private
   */
  function hasClassFinalized(klass) {
    return klass.hasOwnProperty(goog.reflect.objectProperty('__finalized', klass));
  }

  /**
   * Called by `ElementClass.finalize()`. Ensures this `klass` and
   * *all superclasses* are finalized by traversing the prototype chain
   * and calling `klass.finalize()`.
   * @param {HTMLElement} klass
   * @private
   */
  function finalizeClassAndSuper(klass) {
    let proto = klass.prototype;
    let superCtor = Object.getPrototypeOf(proto).constructor;
    if (superCtor.prototype instanceof PolymerElement) {
      superCtor.finalize();
    }
    finalizeClass(klass);
  }

  /**
   * Configures a `klass` based on a staic `klass.config` object and
   * a `template`. This includes creating accessors and effects
   * for properties in `config` and the `template` as well as preparing the
   * `template` for stamping.
   */
  function finalizeClass(klass) {
    klass.__finalized = true;
    let proto = klass.prototype;
    if (klass.hasOwnProperty(
      goog.reflect.objectProperty('is', klass)) && klass.is) {
      Polymer.telemetry.register(proto);
    }
    let config = ownConfigForClass(klass);
    if (config) {
      finalizeConfig(proto, config);
    }
    let template = klass.template;
    if (template) {
      finalizeTemplate(proto, template.cloneNode(true),
        klass.is, klass.extends);
    }
  }

  /**
   * Configures a `proto` based on a `config` object.
   * Leverages `PropertyEffects` to create property accessors and effects
   * supporting, observers, reflecting to attributes, change notification,
   * computed properties, and read only properties.
   * @param {HTMLElement} proto
   * @param {Object} config
   * @private
   */
  function finalizeConfig(proto, config) {
    let {properties, observers} = config;
    if (properties) {
      // process properties
      for (let p in properties) {
        createPropertyFromConfig(proto, p, properties[p], properties);
      }
    }
    if (observers) {
      for (let i=0; i < observers.length; i++) {
        proto._createMethodObserver(observers[i], properties);
      }
    }
  }

  /**
   * Creates effects for a property.
   *
   * Note, once a property has been set to
   * `readOnly`, `computed`, `reflectToAttribute`, or `notify`
   * these values may not be changed. For example, a subclass cannot
   * alter these settings. However, additional `observers` may be added
   * by subclasses.
   *
   * @param {string} name Name of the property.
   * @param {*=} info Info object from which to create property effects.
   * Supported keys:
   *
   * * type: {function} type to which an attribute matching the property
   * is deserialized. Note the property is camel-cased from a dash-cased
   * attribute. For example, 'foo-bar' attribute is dersialized to a
   * property named 'fooBar'.
   *
   * * readOnly: {boolean} creates a readOnly property and
   * makes a private setter for the private of the form '_setFoo' for a
   * property 'foo',
   *
   * * computed: {string} creates a computed property. A computed property
   * also automatically is set to `readOnly: true`. The value is calculated
   * by running a method and arguments parsed from the given string. For
   * example 'compute(foo)' will compute a given property when the
   * 'foo' property changes by executing the 'compute' method. This method
   * must return the computed value.
   *
   * * reflectToAttriute: {boolean} If true, the property value is reflected
   * to an attribute of the same name. Note, the attribute is dash-cased
   * so a property named 'fooBar' is reflected as 'foo-bar'.
   *
   * * notify: {boolean} sends a non-bubbling notification event when
   * the property changes. For example, a property named 'foo' sends an
   * event named 'foo-changed' with `event.detail` set to the value of
   * the property.
   *
   * * observer: {string} name of a method that runs when the property
   * changes. The arguments of the method are (value, previousValue).
   *
   * @param {HTMLElement} proto
   * @param {string} name
   * @param {object} info
   * @param {object} props
   * @private
   */
  /* Note: Users may want control over modifying property
   effects via subclassing. For example, a user might want to make a
   reflectToAttribute property not do so in a subclass. We've chosen to
   disable this because it leads to additional complication.
   For example, a readOnly effect generates a special setter. If a subclass
   disables the effect, the setter would fail unexpectedly.
   Based on feedback, we may want to try to make effects more malleable
   and/or provide an advanced api for manipulating them.
   Also consider adding warnings when an effect cannot be changed.
  */
  function createPropertyFromConfig(proto, name, info, allProps) {
    // computed forces readOnly...
    if (info.computed) {
      info.readOnly = true;
    }
    // Note, since all computed properties are readOnly, this prevents
    // adding additional computed property effects (which leads to a confusing
    // setup where multiple triggers for setting a property)
    // While we do have `hasComputedEffect` this is set on the property's
    // dependencies rather than itself.
    if (info.computed  && !proto._hasReadOnlyEffect(name)) {
      proto._createComputedProperty(name, info.computed, allProps);
    }
    if (info.readOnly && !proto._hasReadOnlyEffect(name)) {
      proto._createReadOnlyProperty(name, !info.computed);
    }
    if (info.reflectToAttribute && !proto._hasReflectEffect(name)) {
      proto._createReflectedProperty(name);
    }
    if (info.notify && !proto._hasNotifyEffect(name)) {
      proto._createNotifyingProperty(name);
    }
    // always add observer
    if (info.observer) {
      proto._createPropertyObserver(name, info.observer, allProps[info.observer]);
    }
  }

  /**
   * Configures an element `proto` to function with a given `template`.
   * The element name `is` and extends `ext` must be specified for ShadyCSS
   * style scoping.
   * @param {HTMLElement} proto
   * @param {HTMLTemplateElement} template
   * @param {string} is
   * @param {string} ext
   * @private
   */
  function finalizeTemplate(proto, template, is, ext) {
    // support `include="module-name"`
    let cssText = Polymer.StyleGather.cssFromElement(template);
    if (cssText) {
      let style = document.createElement('style');
      style.textContent = cssText;
      template.content.insertBefore(style, template.content.firstChild);
    }
    if (window.ShadyCSS) {
      window.ShadyCSS.prepareTemplate(template, is, ext);
    }
    proto._bindTemplate(template, propertiesForClass(proto.constructor));
    proto._template = template;
  }

  /**
   * @unrestricted
   */
  class PolymerElement extends mixin {

    static get observedAttributes() {
      if (!this.hasOwnProperty(goog.reflect.objectProperty('__observedAttributes', this))) {
        let list = [];
        let properties = propertiesForClass(this);
        for (let prop in properties) {
          list.push(Polymer.CaseMap.camelToDashCase(prop));
        }
        this.__observedAttributes = list;
      }
      return this.__observedAttributes;
    }

    /**
     * Called automatically when the first element instance is created to
     * ensure that class finalization work has been completed.
     * May be called by users to eagerly perform class finalization work
     * prior to the creation of the first element instance.
     * @public
     */
    static finalize() {
      if (!hasClassFinalized(this)) {
        finalizeClassAndSuper(this);
      }
    }

    static get template() {
      if (!this.hasOwnProperty(goog.reflect.objectProperty('_template', this))) {
        this._template = Polymer.DomModule.import(this.is, 'template') ||
          // note: implemented so a subclass can retrieve the super
          // template; call the super impl this way so that `this` points
          // to the superclass.
          Object.getPrototypeOf(this.prototype).constructor.template;
      }
      return this._template;
    }

    constructor() {
      super();
      Polymer.telemetry.instanceCount++;
      // Stamp template
      if (this._template) {
        this.root = this._stampTemplate(this._template);
      } else {
        this.root = this;
      }
    }

    _initializeProperties() {
      this.constructor.finalize();
      super._initializeProperties();
      // apply property defaults...
      let p$ = propertyDefaultsForClass(this.constructor);
      if (!p$) {
        return;
      }
      for (let p in p$) {
        let info = p$[p];
        if (!this._isPropertyPending(p)) {
          var value = typeof info.value == 'function' ?
            info.value.call(this) :
            info.value;
          if (this._hasPropertyEffect(p)) {
            this._setProperty(p, value)
          } else {
            this[p] = value;
          }
        }
      }
    }

    connectedCallback() {
      if (window.ShadyCSS) {
        window.ShadyCSS.styleElement(this);
      }
      this._flushProperties();
    }

    disconnectedCallback() {}

    ready() {
      super.ready();
      if (this._template) {
        this.root = this._attachDom(this.root);
      }
    }

    /**
     * Attach an element's stamped dom to itself. By default,
     * this method creates a `shadowRoot` and adds the dom to it.
     * However, this method may be overridden to allow an element
     * to put its dom in another location.
     *
     * @method _attachDom
     * @throws {Error}
     * @suppress {missingReturn}
     * @param {NodeList} dom to attach to the element.
     * @return {Node} node to which the dom has been attached.
     */
    _attachDom(dom) {
      if (this.attachShadow) {
        if (dom) {
          if (!this.shadowRoot) {
            this.attachShadow({mode: 'open'});
          }
          this.shadowRoot.appendChild(dom);
          return this.shadowRoot;
        }
      } else {
        throw new Error('ShadowDOM not available. ' +
          // TODO(sorvell): move to compile-time conditional when supported
         'Polymer.Element can create dom as children instead of in ' +
         'ShadowDOM by setting `this.root = this;\` before \`ready\`.');
      }
    }

    attributeChangedCallback(name, old, value) {
      if (old !== value) {
        let property = caseMap.dashToCamelCase(name);
        let type = propertiesForClass(this.constructor)[property].type;
        if (!this._hasReadOnlyEffect(property)) {
          this._attributeToProperty(name, value, type);
        }
      }
    }

    /**
     * Update styling for this element
     *
     * @param {Object=} properties
     *  Override styling with an object of properties where the keys are css properties, and the values are strings
     *  Example: `this.updateStyles({'color': 'blue'})`
     *  These properties are retained unless a value of `null` is set.
     */
    updateStyles(properties) {
      if (window.ShadyCSS) {
        window.ShadyCSS.styleSubtree(this, properties);
      }
    }

    /**
     * Rewrites a given URL relative to the original location of the document
     * containing the `dom-module` for this element.  This method will return
     * the same URL before and after vulcanization.
     *
     * @method resolveUrl
     * @param {string} url URL to resolve.
     * @return {string} Rewritten URL relative to the import
     */
    resolveUrl(url) {
      const module = Polymer.DomModule.import(this.constructor.is);
      const root = module ? module.assetpath : document.baseURI;
      return Polymer.ResolveUrl.resolveUrl(url, root);
    }

  }

  return PolymerElement;
});

// telemetry
Polymer.telemetry = {
  instanceCount: 0,
  registrations: [],
  _regLog: function(prototype) {
    console.log('[' + prototype.is + ']: registered')
  },
  register: function(prototype) {
    this.registrations.push(prototype);
    Polymer.log && this._regLog(prototype);
  },
  dumpRegistrations: function() {
    this.registrations.forEach(this._regLog);
  }
};

Polymer.updateStyles = function(props) {
  if (window.ShadyCSS) {
    window.ShadyCSS.styleDocument(props);
  }
};
</script>
<script>
(function() {
  'use strict';

  /** @constructor */
  Polymer.Debouncer = function Debouncer() {
    this._asyncModule = null;
    this._callback = null;
    this._timer = null;
    this.flush = this.flush.bind(this);
  };

  Polymer.mixin(Polymer.Debouncer.prototype, {
    /**
     * Sets the scheduler; that is, a module with the Async interface,
     * a callback and optional arguments to be passed to the run function
     * from the async module.
     *
     * @param {{run: function, cancel: function}} asyncModule
     * @param {function} callback
     * @param {Array=}
     */
    setConfig(asyncModule, cb) {
      this._asyncModule = asyncModule;
      this._callback = cb;
      this._timer = this._asyncModule.run(this.flush);
    },

    /**
     * Cancels an active debouncer and returns a reference to itself.
     */
    cancel() {
      if (this.isActive()) {
        this._asyncModule.cancel(this._timer);
        this._timer = null;
      }
    },

    /**
     * Flushes an active debouncer and returns a reference to itself.
     */
    flush() {
      if (this.isActive()) {
        this.cancel();
        this._callback();
      }
    },

    /**
     * Returns true if the debouncer is active.
     *
     * @return {boolean}
     */
    isActive() {
      return this._timer != null;
    }
  });

  /**
   * Creates a debouncer if no debouncer is passed as a parameter
   * or it cancels an active debouncer otherwise.
   *
   * @param {Polymer.Debouncer?} debouncer
   * @param {{run: function, cancel: function}} asyncModule
   * @param {function} cb
   * @return {Polymer.Debouncer}
   */
  Polymer.Debouncer.debounce = function debounce(debouncer, asyncModule, cb) {
    if (debouncer instanceof Polymer.Debouncer) {
      debouncer.cancel();
    } else {
      debouncer = new Polymer.Debouncer();
    }
    debouncer.setConfig(asyncModule, cb);
    return debouncer;
  };

})();
</script>
<script>
(function() {

  'use strict';

  // let DIRECTION_MAP = {
  //   x: 'pan-x',
  //   y: 'pan-y',
  //   none: 'none',
  //   all: 'auto'
  // };

  // detect native touch action support
  let HAS_NATIVE_TA = typeof document.head.style.touchAction === 'string';
  let GESTURE_KEY = '__polymerGestures';
  let HANDLED_OBJ = '__polymerGesturesHandled';
  let TOUCH_ACTION = '__polymerGesturesTouchAction';
  // radius for tap and track
  let TAP_DISTANCE = 25;
  let TRACK_DISTANCE = 5;
  // number of last N track positions to keep
  let TRACK_LENGTH = 2;

  // Disabling "mouse" handlers for 2500ms is enough
  let MOUSE_TIMEOUT = 2500;
  let MOUSE_EVENTS = ['mousedown', 'mousemove', 'mouseup', 'click'];
  // an array of bitmask values for mapping MouseEvent.which to MouseEvent.buttons
  let MOUSE_WHICH_TO_BUTTONS = [0, 1, 4, 2];
  let MOUSE_HAS_BUTTONS = (function() {
    try {
      return new MouseEvent('test', {buttons: 1}).buttons === 1;
    } catch (e) {
      return false;
    }
  })();

  // Check for touch-only devices
  let IS_TOUCH_ONLY = navigator.userAgent.match(/iP(?:[oa]d|hone)|Android/);

  // touch will make synthetic mouse events
  // `preventDefault` on touchend will cancel them,
  // but this breaks `<input>` focus and link clicks
  // disable mouse handlers for MOUSE_TIMEOUT ms after
  // a touchend to ignore synthetic mouse events
  let mouseCanceller = function(mouseEvent) {
    // Check for sourceCapabilities, used to distinguish synthetic events
    // if mouseEvent did not come from a device that fires touch events,
    // it was made by a real mouse and should be counted
    // http://wicg.github.io/InputDeviceCapabilities/#dom-inputdevicecapabilities-firestouchevents
    let sc = mouseEvent.sourceCapabilities;
    if (sc && !sc.firesTouchEvents) {
      return;
    }
    // skip synthetic mouse events
    mouseEvent[HANDLED_OBJ] = {skip: true};
    // disable "ghost clicks"
    if (mouseEvent.type === 'click') {
      let path = mouseEvent.composedPath && mouseEvent.composedPath();
      if (path) {
        for (let i = 0; i < path.length; i++) {
          if (path[i] === POINTERSTATE.mouse.target) {
            return;
          }
        }
      }
      mouseEvent.preventDefault();
      mouseEvent.stopPropagation();
    }
  };

  /**
   * @param {boolean=} setup
   */
  function setupTeardownMouseCanceller(setup) {
    let events = IS_TOUCH_ONLY ? ['click'] : MOUSE_EVENTS;
    for (let i = 0, en; i < events.length; i++) {
      en = events[i];
      if (setup) {
        document.addEventListener(en, mouseCanceller, true);
      } else {
        document.removeEventListener(en, mouseCanceller, true);
      }
    }
  }

  function ignoreMouse() {
    if (!POINTERSTATE.mouse.mouseIgnoreJob) {
      setupTeardownMouseCanceller(true);
    }
    let unset = function() {
      setupTeardownMouseCanceller();
      POINTERSTATE.mouse.target = null;
      POINTERSTATE.mouse.mouseIgnoreJob = null;
    };
    POINTERSTATE.mouse.mouseIgnoreJob = Polymer.Debouncer.debounce(
          POINTERSTATE.mouse.mouseIgnoreJob
        , Polymer.Async.timeOut.after(MOUSE_TIMEOUT)
        , unset);
  }

  function hasLeftMouseButton(ev) {
    let type = ev.type;
    // exit early if the event is not a mouse event
    if (MOUSE_EVENTS.indexOf(type) === -1) {
      return false;
    }
    // ev.button is not reliable for mousemove (0 is overloaded as both left button and no buttons)
    // instead we use ev.buttons (bitmask of buttons) or fall back to ev.which (deprecated, 0 for no buttons, 1 for left button)
    if (type === 'mousemove') {
      // allow undefined for testing events
      let buttons = ev.buttons === undefined ? 1 : ev.buttons;
      if ((ev instanceof window.MouseEvent) && !MOUSE_HAS_BUTTONS) {
        buttons = MOUSE_WHICH_TO_BUTTONS[ev.which] || 0;
      }
      // buttons is a bitmask, check that the left button bit is set (1)
      return Boolean(buttons & 1);
    } else {
      // allow undefined for testing events
      let button = ev.button === undefined ? 0 : ev.button;
      // ev.button is 0 in mousedown/mouseup/click for left button activation
      return button === 0;
    }
  }

  function isSyntheticClick(ev) {
    if (ev.type === 'click') {
      // ev.detail is 0 for HTMLElement.click in most browsers
      if (ev.detail === 0) {
        return true;
      }
      // in the worst case, check that the x/y position of the click is within
      // the bounding box of the target of the event
      // Thanks IE 10 >:(
      let t = gestures._findOriginalTarget(ev);
      let bcr = t.getBoundingClientRect();
      // use page x/y to account for scrolling
      let x = ev.pageX, y = ev.pageY;
      // ev is a synthetic click if the position is outside the bounding box of the target
      return !((x >= bcr.left && x <= bcr.right) && (y >= bcr.top && y <= bcr.bottom));
    }
    return false;
  }

  let POINTERSTATE = {
    mouse: {
      target: null,
      mouseIgnoreJob: null
    },
    touch: {
      x: 0,
      y: 0,
      id: -1,
      scrollDecided: false
    }
  };

  function firstTouchAction(ev) {
    let ta = 'auto';
    let path = ev.composedPath && ev.composedPath();
    if (path) {
      for (let i = 0, n; i < path.length; i++) {
        n = path[i];
        if (n[TOUCH_ACTION]) {
          ta = n[TOUCH_ACTION];
          break;
        }
      }
    }
    return ta;
  }

  function trackDocument(stateObj, movefn, upfn) {
    stateObj.movefn = movefn;
    stateObj.upfn = upfn;
    document.addEventListener('mousemove', movefn);
    document.addEventListener('mouseup', upfn);
  }

  function untrackDocument(stateObj) {
    document.removeEventListener('mousemove', stateObj.movefn);
    document.removeEventListener('mouseup', stateObj.upfn);
    stateObj.movefn = null;
    stateObj.upfn = null;
  }

  let gestures = {
    gestures: {},
    recognizers: [],

    deepTargetFind: function(x, y) {
      let node = document.elementFromPoint(x, y);
      let next = node;
      // this code path is only taken when native ShadowDOM is used
      // if there is a shadowroot, it may have a node at x/y
      // if there is not a shadowroot, exit the loop
      while (next && next.shadowRoot && !window.ShadyDOM) {
        // if there is a node at x/y in the shadowroot, look deeper
        next = next.shadowRoot.elementFromPoint(x, y);
        if (next) {
          node = next;
        }
      }
      return node;
    },
    // a cheaper check than ev.composedPath()[0];
    _findOriginalTarget: function(ev) {
      // shadowdom
      if (ev.composedPath) {
        return ev.composedPath()[0];
      }
      // shadydom
      return ev.target;
    },
    _handleNative: function(ev) {
      let handled;
      let type = ev.type;
      let node = ev.currentTarget;
      let gobj = node[GESTURE_KEY];
      if (!gobj) {
        return;
      }
      let gs = gobj[type];
      if (!gs) {
        return;
      }
      if (!ev[HANDLED_OBJ]) {
        ev[HANDLED_OBJ] = {};
        if (type.slice(0, 5) === 'touch') {
          let t = ev.changedTouches[0];
          if (type === 'touchstart') {
            // only handle the first finger
            if (ev.touches.length === 1) {
              POINTERSTATE.touch.id = t.identifier;
            }
          }
          if (POINTERSTATE.touch.id !== t.identifier) {
            return;
          }
          if (!HAS_NATIVE_TA) {
            if (type === 'touchstart' || type === 'touchmove') {
              gestures._handleTouchAction(ev);
            }
          }
          if (type === 'touchend') {
            let rootTarget = ev.composedPath ? ev.composedPath()[0] : ev.target;
            POINTERSTATE.mouse.target = rootTarget;
            // ignore syntethic mouse events after a touch
            ignoreMouse();
          }
        }
      }
      handled = ev[HANDLED_OBJ];
      // used to ignore synthetic mouse events
      if (handled.skip) {
        return;
      }
      let recognizers = gestures.recognizers;
      // reset recognizer state
      for (let i = 0, r; i < recognizers.length; i++) {
        r = recognizers[i];
        if (gs[r.name] && !handled[r.name]) {
          if (r.flow && r.flow.start.indexOf(ev.type) > -1 && r.reset) {
            r.reset();
          }
        }
      }
      // enforce gesture recognizer order
      for (let i = 0, r; i < recognizers.length; i++) {
        r = recognizers[i];
        if (gs[r.name] && !handled[r.name]) {
          handled[r.name] = true;
          r[type](ev);
        }
      }
    },

    _handleTouchAction: function(ev) {
      let t = ev.changedTouches[0];
      let type = ev.type;
      if (type === 'touchstart') {
        POINTERSTATE.touch.x = t.clientX;
        POINTERSTATE.touch.y = t.clientY;
        POINTERSTATE.touch.scrollDecided = false;
      } else if (type === 'touchmove') {
        if (POINTERSTATE.touch.scrollDecided) {
          return;
        }
        POINTERSTATE.touch.scrollDecided = true;
        let ta = firstTouchAction(ev);
        let prevent = false;
        let dx = Math.abs(POINTERSTATE.touch.x - t.clientX);
        let dy = Math.abs(POINTERSTATE.touch.y - t.clientY);
        if (!ev.cancelable) {
          // scrolling is happening
        } else if (ta === 'none') {
          prevent = true;
        } else if (ta === 'pan-x') {
          prevent = dy > dx;
        } else if (ta === 'pan-y') {
          prevent = dx > dy;
        }
        if (prevent) {
          ev.preventDefault();
        } else {
          gestures.prevent('track');
        }
      }
    },

    addListener: function(node, evType, handler) {
      if (this.gestures[evType]) {
        this._add(node, evType, handler);
        return true;
      }
    },

    removeListener: function(node, evType, handler) {
      if (this.gestures[evType]) {
        this._remove(node, evType, handler);
        return true;
      }
    },

    // automate the event listeners for the native events
    _add: function(node, evType, handler) {
      let recognizer = this.gestures[evType];
      let deps = recognizer.deps;
      let name = recognizer.name;
      let gobj = node[GESTURE_KEY];
      if (!gobj) {
        node[GESTURE_KEY] = gobj = {};
      }
      for (let i = 0, dep, gd; i < deps.length; i++) {
        dep = deps[i];
        // don't add mouse handlers on iOS because they cause gray selection overlays
        if (IS_TOUCH_ONLY && MOUSE_EVENTS.indexOf(dep) > -1 && dep !== 'click') {
          continue;
        }
        gd = gobj[dep];
        if (!gd) {
          gobj[dep] = gd = {_count: 0};
        }
        if (gd._count === 0) {
          node.addEventListener(dep, this._handleNative);
        }
        gd[name] = (gd[name] || 0) + 1;
        gd._count = (gd._count || 0) + 1;
      }
      node.addEventListener(evType, handler);
      if (recognizer.touchAction) {
        this.setTouchAction(node, recognizer.touchAction);
      }
    },

    // automate event listener removal for native events
    _remove: function(node, evType, handler) {
      let recognizer = this.gestures[evType];
      let deps = recognizer.deps;
      let name = recognizer.name;
      let gobj = node[GESTURE_KEY];
      if (gobj) {
        for (let i = 0, dep, gd; i < deps.length; i++) {
          dep = deps[i];
          gd = gobj[dep];
          if (gd && gd[name]) {
            gd[name] = (gd[name] || 1) - 1;
            gd._count = (gd._count || 1) - 1;
            if (gd._count === 0) {
              node.removeEventListener(dep, this._handleNative);
            }
          }
        }
      }
      node.removeEventListener(evType, handler);
    },

    register: function(recog) {
      this.recognizers.push(recog);
      for (let i = 0; i < recog.emits.length; i++) {
        this.gestures[recog.emits[i]] = recog;
      }
    },

    _findRecognizerByEvent: function(evName) {
      for (let i = 0, r; i < this.recognizers.length; i++) {
        r = this.recognizers[i];
        for (let j = 0, n; j < r.emits.length; j++) {
          n = r.emits[j];
          if (n === evName) {
            return r;
          }
        }
      }
      return null;
    },

    // set scrolling direction on node to check later on first move
    // must call this before adding event listeners!
    setTouchAction: function(node, value) {
      if (HAS_NATIVE_TA) {
        node.style.touchAction = value;
      }
      node[TOUCH_ACTION] = value;
    },

    _fire: function(target, type, detail) {
      let ev = new Event(type, { bubbles: true, cancelable: true, composed: true });
      ev.detail = detail;
      target.dispatchEvent(ev);
      // forward `preventDefault` in a clean way
      if (ev.defaultPrevented) {
        let preventer = detail.preventer || detail.sourceEvent;
        if (preventer && preventer.preventDefault) {
          preventer.preventDefault();
        }
      }
    },

    prevent: function(evName) {
      let recognizer = this._findRecognizerByEvent(evName);
      if (recognizer.info) {
        recognizer.info.prevent = true;
      }
    },

    /**
     * Reset the 2500ms timeout on processing mouse input after detecting touch input.
     *
     * Touch inputs create synthesized mouse inputs anywhere from 0 to 2000ms after the touch.
     * This method should only be called during testing with simulated touch inputs.
     * Calling this method in production may cause duplicate taps or other gestures.
     *
     * @method resetMouseCanceller
     */
    resetMouseCanceller: function() {
      if (POINTERSTATE.mouse.mouseIgnoreJob) {
        POINTERSTATE.mouse.mouseIgnoreJob.flush();
      }
    }
  };

  gestures.register({
    name: 'downup',
    deps: ['mousedown', 'touchstart', 'touchend'],
    flow: {
      start: ['mousedown', 'touchstart'],
      end: ['mouseup', 'touchend']
    },
    emits: ['down', 'up'],

    info: {
      movefn: null,
      upfn: null
    },

    reset: function() {
      untrackDocument(this.info);
    },

    mousedown: function(e) {
      if (!hasLeftMouseButton(e)) {
        return;
      }
      let t = gestures._findOriginalTarget(e);
      let self = this;
      let movefn = function movefn(e) {
        if (!hasLeftMouseButton(e)) {
          self._fire('up', t, e);
          untrackDocument(self.info);
        }
      };
      let upfn = function upfn(e) {
        if (hasLeftMouseButton(e)) {
          self._fire('up', t, e);
        }
        untrackDocument(self.info);
      };
      trackDocument(this.info, movefn, upfn);
      this._fire('down', t, e);
    },
    touchstart: function(e) {
      this._fire('down', gestures._findOriginalTarget(e), e.changedTouches[0], e);
    },
    touchend: function(e) {
      this._fire('up', gestures._findOriginalTarget(e), e.changedTouches[0], e);
    },
    _fire: function(type, target, event, preventer) {
      gestures._fire(target, type, {
        x: event.clientX,
        y: event.clientY,
        sourceEvent: event,
        preventer: preventer,
        prevent: function(e) {
          return gestures.prevent(e);
        }
      });
    }
  });

  gestures.register({
    name: 'track',
    touchAction: 'none',
    deps: ['mousedown', 'touchstart', 'touchmove', 'touchend'],
    flow: {
      start: ['mousedown', 'touchstart'],
      end: ['mouseup', 'touchend']
    },
    emits: ['track'],

    info: {
      x: 0,
      y: 0,
      state: 'start',
      started: false,
      moves: [],
      addMove: function(move) {
        if (this.moves.length > TRACK_LENGTH) {
          this.moves.shift();
        }
        this.moves.push(move);
      },
      movefn: null,
      upfn: null,
      prevent: false
    },

    reset: function() {
      this.info.state = 'start';
      this.info.started = false;
      this.info.moves = [];
      this.info.x = 0;
      this.info.y = 0;
      this.info.prevent = false;
      untrackDocument(this.info);
    },

    hasMovedEnough: function(x, y) {
      if (this.info.prevent) {
        return false;
      }
      if (this.info.started) {
        return true;
      }
      let dx = Math.abs(this.info.x - x);
      let dy = Math.abs(this.info.y - y);
      return (dx >= TRACK_DISTANCE || dy >= TRACK_DISTANCE);
    },

    mousedown: function(e) {
      if (!hasLeftMouseButton(e)) {
        return;
      }
      let t = gestures._findOriginalTarget(e);
      let self = this;
      let movefn = function movefn(e) {
        let x = e.clientX, y = e.clientY;
        if (self.hasMovedEnough(x, y)) {
          // first move is 'start', subsequent moves are 'move', mouseup is 'end'
          self.info.state = self.info.started ? (e.type === 'mouseup' ? 'end' : 'track') : 'start';
          if (self.info.state === 'start') {
            // if and only if tracking, always prevent tap
            gestures.prevent('tap');
          }
          self.info.addMove({x: x, y: y});
          if (!hasLeftMouseButton(e)) {
            // always _fire "end"
            self.info.state = 'end';
            untrackDocument(self.info);
          }
          self._fire(t, e);
          self.info.started = true;
        }
      };
      let upfn = function upfn(e) {
        if (self.info.started) {
          movefn(e);
        }

        // remove the temporary listeners
        untrackDocument(self.info);
      };
      // add temporary document listeners as mouse retargets
      trackDocument(this.info, movefn, upfn);
      this.info.x = e.clientX;
      this.info.y = e.clientY;
    },

    touchstart: function(e) {
      let ct = e.changedTouches[0];
      this.info.x = ct.clientX;
      this.info.y = ct.clientY;
    },

    touchmove: function(e) {
      let t = gestures._findOriginalTarget(e);
      let ct = e.changedTouches[0];
      let x = ct.clientX, y = ct.clientY;
      if (this.hasMovedEnough(x, y)) {
        if (this.info.state === 'start') {
          // if and only if tracking, always prevent tap
          gestures.prevent('tap');
        }
        this.info.addMove({x: x, y: y});
        this._fire(t, ct);
        this.info.state = 'track';
        this.info.started = true;
      }
    },

    touchend: function(e) {
      let t = gestures._findOriginalTarget(e);
      let ct = e.changedTouches[0];
      // only trackend if track was started and not aborted
      if (this.info.started) {
        // reset started state on up
        this.info.state = 'end';
        this.info.addMove({x: ct.clientX, y: ct.clientY});
        this._fire(t, ct, e);
      }
    },

    _fire: function(target, touch) {
      let secondlast = this.info.moves[this.info.moves.length - 2];
      let lastmove = this.info.moves[this.info.moves.length - 1];
      let dx = lastmove.x - this.info.x;
      let dy = lastmove.y - this.info.y;
      let ddx, ddy = 0;
      if (secondlast) {
        ddx = lastmove.x - secondlast.x;
        ddy = lastmove.y - secondlast.y;
      }
      return gestures._fire(target, 'track', {
        state: this.info.state,
        x: touch.clientX,
        y: touch.clientY,
        dx: dx,
        dy: dy,
        ddx: ddx,
        ddy: ddy,
        sourceEvent: touch,
        hover: function() {
          return gestures.deepTargetFind(touch.clientX, touch.clientY);
        }
      });
    }

  });

  gestures.register({
    name: 'tap',
    deps: ['mousedown', 'click', 'touchstart', 'touchend'],
    flow: {
      start: ['mousedown', 'touchstart'],
      end: ['click', 'touchend']
    },
    emits: ['tap'],
    info: {
      x: NaN,
      y: NaN,
      prevent: false
    },
    reset: function() {
      this.info.x = NaN;
      this.info.y = NaN;
      this.info.prevent = false;
    },
    save: function(e) {
      this.info.x = e.clientX;
      this.info.y = e.clientY;
    },

    mousedown: function(e) {
      if (hasLeftMouseButton(e)) {
        this.save(e);
      }
    },
    click: function(e) {
      if (hasLeftMouseButton(e)) {
        this.forward(e);
      }
    },

    touchstart: function(e) {
      this.save(e.changedTouches[0], e);
    },
    touchend: function(e) {
      this.forward(e.changedTouches[0], e);
    },

    forward: function(e, preventer) {
      let dx = Math.abs(e.clientX - this.info.x);
      let dy = Math.abs(e.clientY - this.info.y);
      let t = gestures._findOriginalTarget(e);
      // dx,dy can be NaN if `click` has been simulated and there was no `down` for `start`
      if (isNaN(dx) || isNaN(dy) || (dx <= TAP_DISTANCE && dy <= TAP_DISTANCE) || isSyntheticClick(e)) {
        // prevent taps from being generated if an event has canceled them
        if (!this.info.prevent) {
          gestures._fire(t, 'tap', {
            x: e.clientX,
            y: e.clientY,
            sourceEvent: e,
            preventer: preventer
          });
        }
      }
    }
  });

  /** @deprecated */
  gestures.findOriginalTarget = gestures._findOriginalTarget;

  /** @deprecated */
  gestures.add = gestures._add;

  Polymer.Gestures = gestures;

})();
</script>
<script>
(function() {

  'use strict';

  const gestures = Polymer.Gestures;

  Polymer.GestureEventListeners = Polymer.dedupingMixin(function(superClass) {

    return class GestureEventListeners extends superClass {

      _addEventListenerToNode(node, eventName, handler) {
        if (!gestures.addListener(node, eventName, handler) &&
          super._addEventListenerToNode) {
          super._addEventListenerToNode(node, eventName, handler);
        }
      }

      _removeEventListenerFromNode(node, eventName, handler) {
        if (!gestures.removeListener(node, eventName, handler) &&
          super._removeEventListenerFromNode) {
          super._removeEventListenerFromNode(node, eventName, handler);
        }
      }

    }

  });

})();
</script>
<script>

(function() {

  'use strict';

  // run a callback when HTMLImports are ready or immediately if
  // this api is not available.
  function whenImportsReady(cb) {
    if (window.HTMLImports) {
      HTMLImports.whenReady(cb);
    } else {
      cb();
    }
  }

  /**
   * Convenience method for importing an HTML document imperatively.
   *
   * This method creates a new `<link rel="import">` element with
   * the provided URL and appends it to the document to start loading.
   * In the `onload` callback, the `import` property of the `link`
   * element will contain the imported document contents.
   *
   * @method importHref
   * @param {string} href URL to document to load.
   * @param {Function=} onload Callback to notify when an import successfully
   *   loaded.
   * @param {Function=} onerror Callback to notify when an import
   *   unsuccessfully loaded.
   * @param {boolean=} optAsync True if the import should be loaded `async`.
   *   Defaults to `false`.
   * @return {HTMLLinkElement} The link element for the URL to be loaded.
   */
  Polymer.importHref = function(href, onload, onerror, optAsync) {
    let link =
      document.head.querySelector('link[href="' + href + '"][import-href]');
    if (!link) {
      link = document.createElement('link');
      link.rel = 'import';
      link.href = href;
      link.setAttribute('import-href', '');
    }
    // always ensure link has `async` attribute if user specified one,
    // even if it was previously not async. This is considered less confusing.
    if (optAsync) {
      link.setAttribute('async', '');
    }
    // NOTE: the link may now be in 3 states: (1) pending insertion,
    // (2) inflight, (3) already laoded. In each case, we need to add
    // event listeners to process callbacks.
    let cleanup = function() {
      link.removeEventListener('load', loadListener);
      link.removeEventListener('error', errorListener);
    }
    let loadListener = function(event) {
      cleanup();
      // In case of a successful load, cache the load event on the link so
      // that it can be used to short-circuit this method in the future when
      // it is called with the same href param.
      link.__dynamicImportLoaded = true;
      if (onload) {
        whenImportsReady(() => {
          onload(event);
        });
      }
    };
    let errorListener = function(event) {
      cleanup();
      // In case of an error, remove the link from the document so that it
      // will be automatically created again the next time `importHref` is
      // called.
      if (link.parentNode) {
        link.parentNode.removeChild(link);
      }
      if (onerror) {
        whenImportsReady(() => {
          onerror(event);
        });
      }
    };
    link.addEventListener('load', loadListener);
    link.addEventListener('error', errorListener);
    if (link.parentNode == null) {
      document.head.appendChild(link);
    // if the link already loaded, dispatch a fake load event
    // so that listeners are called and get a proper event argument.
    } else if (link.__dynamicImportLoaded) {
      link.dispatchEvent(new Event('load'));
    }
    return link;
  };

})();
</script>
<script>
(function() {

  'use strict';

  let scheduled = false;
  let beforeRenderQueue = [];
  let afterRenderQueue = [];

  function schedule() {
    scheduled = true;
    // before next render
    requestAnimationFrame(function() {
      scheduled = false;
      flushQueue(beforeRenderQueue);
      // after the render
      setTimeout(function() {
        flushQueue(afterRenderQueue);
      });
    });
  }

  function flushQueue(queue) {
    for (let i=0, q, context, callback, args; i<queue.length; i++) {
      try {
        q = queue[i];
        context = q[0];
        callback = q[1];
        args = q[2];
        callback.apply(context, args);
      } catch(e) {
        setTimeout(() => {
          throw e;
        })
      }
    }
    queue.length = 0;
  }

  Polymer.RenderStatus = {

    beforeNextRender: function(context, callback, args) {
      if (!scheduled) {
        schedule();
      }
      beforeRenderQueue.push([context, callback, args]);
    },

    afterNextRender: function(context, callback, args) {
      if (!scheduled) {
        schedule();
      }
      afterRenderQueue.push([context, callback, args]);
    }

  };

})();
</script>
<script>
(function() {

  // unresolved

  function resolve() {
    document.body.removeAttribute('unresolved');
  }

  if (window.WebComponents) {
    window.addEventListener('WebComponentsReady', resolve);
  } else {
    if (document.readyState === 'interactive' || document.readyState === 'complete') {
      resolve();
    } else {
      window.addEventListener('DOMContentLoaded', resolve);
    }
  }

})();
</script>
<script>
(function() {

  'use strict';

  function newSplice(index, removed, addedCount) {
    return {
      index: index,
      removed: removed,
      addedCount: addedCount
    };
  }

  const EDIT_LEAVE = 0;
  const EDIT_UPDATE = 1;
  const EDIT_ADD = 2;
  const EDIT_DELETE = 3;

  let ArraySplice = {

    // Note: This function is *based* on the computation of the Levenshtein
    // "edit" distance. The one change is that "updates" are treated as two
    // edits - not one. With Array splices, an update is really a delete
    // followed by an add. By retaining this, we optimize for "keeping" the
    // maximum array items in the original array. For example:
    //
    //   'xxxx123' -> '123yyyy'
    //
    // With 1-edit updates, the shortest path would be just to update all seven
    // characters. With 2-edit updates, we delete 4, leave 3, and add 4. This
    // leaves the substring '123' intact.
    calcEditDistances(current, currentStart, currentEnd,
                                old, oldStart, oldEnd) {
      // "Deletion" columns
      let rowCount = oldEnd - oldStart + 1;
      let columnCount = currentEnd - currentStart + 1;
      let distances = new Array(rowCount);

      // "Addition" rows. Initialize null column.
      for (let i = 0; i < rowCount; i++) {
        distances[i] = new Array(columnCount);
        distances[i][0] = i;
      }

      // Initialize null row
      for (let j = 0; j < columnCount; j++)
        distances[0][j] = j;

      for (let i = 1; i < rowCount; i++) {
        for (let j = 1; j < columnCount; j++) {
          if (this.equals(current[currentStart + j - 1], old[oldStart + i - 1]))
            distances[i][j] = distances[i - 1][j - 1];
          else {
            let north = distances[i - 1][j] + 1;
            let west = distances[i][j - 1] + 1;
            distances[i][j] = north < west ? north : west;
          }
        }
      }

      return distances;
    },

    // This starts at the final weight, and walks "backward" by finding
    // the minimum previous weight recursively until the origin of the weight
    // matrix.
    spliceOperationsFromEditDistances(distances) {
      let i = distances.length - 1;
      let j = distances[0].length - 1;
      let current = distances[i][j];
      let edits = [];
      while (i > 0 || j > 0) {
        if (i == 0) {
          edits.push(EDIT_ADD);
          j--;
          continue;
        }
        if (j == 0) {
          edits.push(EDIT_DELETE);
          i--;
          continue;
        }
        let northWest = distances[i - 1][j - 1];
        let west = distances[i - 1][j];
        let north = distances[i][j - 1];

        let min;
        if (west < north)
          min = west < northWest ? west : northWest;
        else
          min = north < northWest ? north : northWest;

        if (min == northWest) {
          if (northWest == current) {
            edits.push(EDIT_LEAVE);
          } else {
            edits.push(EDIT_UPDATE);
            current = northWest;
          }
          i--;
          j--;
        } else if (min == west) {
          edits.push(EDIT_DELETE);
          i--;
          current = west;
        } else {
          edits.push(EDIT_ADD);
          j--;
          current = north;
        }
      }

      edits.reverse();
      return edits;
    },

    /**
     * Splice Projection functions:
     *
     * A splice map is a representation of how a previous array of items
     * was transformed into a new array of items. Conceptually it is a list of
     * tuples of
     *
     *   <index, removed, addedCount>
     *
     * which are kept in ascending index order of. The tuple represents that at
     * the |index|, |removed| sequence of items were removed, and counting forward
     * from |index|, |addedCount| items were added.
     */

    /**
     * Lacking individual splice mutation information, the minimal set of
     * splices can be synthesized given the previous state and final state of an
     * array. The basic approach is to calculate the edit distance matrix and
     * choose the shortest path through it.
     *
     * Complexity: O(l * p)
     *   l: The length of the current array
     *   p: The length of the old array
     */
    calcSplices(current, currentStart, currentEnd,
                          old, oldStart, oldEnd) {
      let prefixCount = 0;
      let suffixCount = 0;
      let splice;

      let minLength = Math.min(currentEnd - currentStart, oldEnd - oldStart);
      if (currentStart == 0 && oldStart == 0)
        prefixCount = this.sharedPrefix(current, old, minLength);

      if (currentEnd == current.length && oldEnd == old.length)
        suffixCount = this.sharedSuffix(current, old, minLength - prefixCount);

      currentStart += prefixCount;
      oldStart += prefixCount;
      currentEnd -= suffixCount;
      oldEnd -= suffixCount;

      if (currentEnd - currentStart == 0 && oldEnd - oldStart == 0)
        return [];

      if (currentStart == currentEnd) {
        splice = newSplice(currentStart, [], 0);
        while (oldStart < oldEnd)
          splice.removed.push(old[oldStart++]);

        return [ splice ];
      } else if (oldStart == oldEnd)
        return [ newSplice(currentStart, [], currentEnd - currentStart) ];

      let ops = this.spliceOperationsFromEditDistances(
          this.calcEditDistances(current, currentStart, currentEnd,
                                 old, oldStart, oldEnd));

      splice = undefined;
      let splices = [];
      let index = currentStart;
      let oldIndex = oldStart;
      for (let i = 0; i < ops.length; i++) {
        switch(ops[i]) {
          case EDIT_LEAVE:
            if (splice) {
              splices.push(splice);
              splice = undefined;
            }

            index++;
            oldIndex++;
            break;
          case EDIT_UPDATE:
            if (!splice)
              splice = newSplice(index, [], 0);

            splice.addedCount++;
            index++;

            splice.removed.push(old[oldIndex]);
            oldIndex++;
            break;
          case EDIT_ADD:
            if (!splice)
              splice = newSplice(index, [], 0);

            splice.addedCount++;
            index++;
            break;
          case EDIT_DELETE:
            if (!splice)
              splice = newSplice(index, [], 0);

            splice.removed.push(old[oldIndex]);
            oldIndex++;
            break;
        }
      }

      if (splice) {
        splices.push(splice);
      }
      return splices;
    },

    sharedPrefix(current, old, searchLength) {
      for (let i = 0; i < searchLength; i++)
        if (!this.equals(current[i], old[i]))
          return i;
      return searchLength;
    },

    sharedSuffix(current, old, searchLength) {
      let index1 = current.length;
      let index2 = old.length;
      let count = 0;
      while (count < searchLength && this.equals(current[--index1], old[--index2]))
        count++;

      return count;
    },

    calculateSplices(current, previous) {
      return this.calcSplices(current, 0, current.length, previous, 0,
                              previous.length);
    },

    equals(currentValue, previousValue) {
      return currentValue === previousValue;
    }

  };

  Polymer.ArraySplice = {
    calculateSplices(current, previous) {
      return ArraySplice.calculateSplices(current, previous);
    }
  }

})();
</script><script>
(function() {

  let debouncerQueue = [];

  Polymer.enqueueDebouncer = function(debouncer) {
    debouncerQueue.push(debouncer);
  }

  function flushDebouncers() {
    const didFlush = Boolean(debouncerQueue.length);
    while (debouncerQueue.length) {
      try {
        debouncerQueue.shift().flush();
      } catch(e) {
        setTimeout(() => {
          throw e;
        });
      }
    }
    return didFlush;
  }

  Polymer.flush = function() {
    let shadyDOM, debouncers;
    do {
      shadyDOM = window.ShadyDOM && ShadyDOM.flush();
      if (window.ShadyCSS && window.ShadyCSS.ScopingShim) {
        window.ShadyCSS.ScopingShim.flush();
      }
      debouncers = flushDebouncers();
    } while (shadyDOM || debouncers);
  }

})();
</script>
<script>
(function() {

  function isSlot(node) {
    return (node.localName === 'slot');
  }

  function getEffectiveNodes(node) {
    if (isSlot(node)) {
      return node.assignedNodes({flatten: true});
    } else {
      return Array.from(node.childNodes).map(node => {
        if (isSlot(node)) {
          return node.assignedNodes({flatten: true});
        } else {
          return [node];
        }
      }).reduce((a, b) => a.concat(b), []);
    }
  }

  let matchesSelector = (function() {
    let p = Element.prototype;
    let normalizedMatchesSelector = p.matches || p.matchesSelector ||
      p.mozMatchesSelector || p.msMatchesSelector ||
      p.oMatchesSelector || p.webkitMatchesSelector;

    return function(node, selector) {
      return normalizedMatchesSelector.call(node, selector);
    }
  })();

  class EffectiveNodesObserver {

    constructor(target, callback) {
      /** @type {MutationObserver} */
      this._shadyChildrenObserver = null;
      /** @type {MutationObserver} */
      this._nativeChildrenObserver = null;
      this._connected = false;
      this._target = target;
      this.callback = callback;
      this._effectiveNodes = [];
      this._observer = null;
      this._scheduled = false;
      this._boundSchedule = () => {
        this._schedule();
      }
      this._connect();
      this._schedule();
    }

    _connect() {
      if (isSlot(this._target)) {
        this._listenSlots([this._target]);
      } else {
        this._listenSlots(this._target.children);
        if (window.ShadyDOM) {
          this._shadyChildrenObserver =
            ShadyDOM.observeChildren(this._target, (mutations) => {
              this._processMutations(mutations);
            });
        } else {
          this._nativeChildrenObserver =
            new MutationObserver((mutations) => {
              this._processMutations(mutations);
            });
          this._nativeChildrenObserver.observe(this._target, {childList: true});
        }
      }
      this._connected = true;
    }

    disconnect() {
      if (isSlot(this._target)) {
        this._unlistenSlots([this._target]);
      } else {
        this._unlistenSlots(this._target.children);
        if (window.ShadyDOM && this._shadyChildrenObserver) {
          ShadyDOM.unobserveChildren(this._shadyChildrenObserver);
          this._shadyChildrenObserver = null;
        } else if (this._nativeChildrenObserver) {
          this._nativeChildrenObserver.disconnect();
          this._nativeChildrenObserver = null;
        }
      }
      this._connected = false;
    }

    _schedule() {
      if (!this._scheduled) {
        this._scheduled = true;
        Polymer.Async.microTask.run(() => this.flush());
      }
    }

    _processMutations(mutations) {
      this._processSlotMutations(mutations);
      this.flush();
    }

    _processSlotMutations(mutations) {
      if (mutations) {
        for (let i=0; i < mutations.length; i++) {
          let mutation = mutations[i];
          if (mutation.addedNodes) {
            this._listenSlots(mutation.addedNodes);
          }
          if (mutation.removedNodes) {
            this._unlistenSlots(mutation.removedNodes);
          }
        }
      }
    }

    flush() {
      if (!this._connected) {
        return;
      }
      if (window.ShadyDOM) {
        ShadyDOM.flush();
      }
      if (this._nativeChildrenObserver) {
        this._processSlotMutations(this._nativeChildrenObserver.takeRecords());
      } else if (this.shadyChildrenObserver) {
        this._processSlotMutations(this._shadyChildrenObserver.takeRecords());
      }
      this._scheduled = false;
      let info = {
        target: this._target,
        addedNodes: [],
        removedNodes: []
      };
      let newNodes = getEffectiveNodes(this._target);
      let splices = Polymer.ArraySplice.calculateSplices(newNodes,
        this._effectiveNodes);
      // process removals
      for (let i=0, s; (i<splices.length) && (s=splices[i]); i++) {
        for (let j=0, n; (j < s.removed.length) && (n=s.removed[j]); j++) {
          info.removedNodes.push(n);
        }
      }
      // process adds
      for (let i=0, s; (i<splices.length) && (s=splices[i]); i++) {
        for (let j=s.index; j < s.index + s.addedCount; j++) {
          info.addedNodes.push(newNodes[j]);
        }
      }
      // update cache
      this._effectiveNodes = newNodes;
      if (info.addedNodes.length || info.removedNodes.length) {
        this.callback.call(this._target, info);
      }
    }

    _listenSlots(nodeList) {
      for (let i=0; i < nodeList.length; i++) {
        let n = nodeList[i];
        if (isSlot(n)) {
          n.addEventListener('slotchange', this._boundSchedule);
        }
      }
    }

    _unlistenSlots(nodeList) {
      for (let i=0; i < nodeList.length; i++) {
        let n = nodeList[i];
        if (isSlot(n)) {
          n.removeEventListener('slotchange', this._boundSchedule);
        }
      }
    }

  }

  class DomApi {

    constructor(node) {
      if (window.ShadyDOM) {
        ShadyDOM.patch(node);
      }
      this.node = node;
    }

    observeNodes(callback) {
      return new EffectiveNodesObserver(this.node, callback);
    }

    unobserveNodes(observerHandle) {
      observerHandle.disconnect();
    }

    notifyObserver() {}

    deepContains(node) {
      if (this.node.contains(node)) {
        return true;
      }
      let n = node;
      let doc = node.ownerDocument;
      // walk from node to `this` or `document`
      while (n && n !== doc && n !== this.node) {
        // use logical parentnode, or native ShadowRoot host
        n = Polymer.dom(n).parentNode || n.host;
      }
      return n === this.node;
    }

    getOwnerRoot() {
      return this.node.getRootNode();
    }

    getDistributedNodes() {
      return (this.node.localName === 'slot') ?
        this.node.assignedNodes({flatten: true}) :
        [];
    }

    getDestinationInsertionPoints() {
      let ip$ = [];
      let n = this.node.assignedSlot;
      while (n) {
        ip$.push(n);
        n = n.assignedSlot;
      }
      return ip$;
    }

    importNode(externalNode, deep) {
      let doc = this.node instanceof Document ? this.node :
        this.node.ownerDocument;
      return doc.importNode(externalNode, deep);
    }

    getEffectiveChildNodes() {
      return getEffectiveNodes(this.node);
    }

    queryDistributedElements(selector) {
      let c$ = this.getEffectiveChildNodes();
      let list = [];
      for (let i=0, l=c$.length, c; (i<l) && (c=c$[i]); i++) {
        if ((c.nodeType === Node.ELEMENT_NODE) &&
            matchesSelector(c, selector)) {
          list.push(c);
        }
      }
      return list;
    }

    get activeElement() {
      let node = this.node;
      return node._activeElement !== undefined ? node._activeElement : node.activeElement;
    }
  }

  function forwardMethods(proto, methods) {
    for (let i=0; i < methods.length; i++) {
      let method = methods[i];
      proto[method] = function() {
        return this.node[method].apply(this.node, arguments);
      }
    }
  }

  function forwardReadOnlyProperties(proto, properties) {
    for (let i=0; i < properties.length; i++) {
      let name = properties[i];
      Object.defineProperty(proto, name, {
        get: function() {
          return this.node[name];
        },
        configurable: true
      });
    }
  }

  function forwardProperties(proto, properties) {
    for (let i=0; i < properties.length; i++) {
      let name = properties[i];
      Object.defineProperty(proto, name, {
        get: function() {
          return this.node[name];
        },
        set: function(value) {
          this.node[name] = value;
        },
        configurable: true
      });
    }
  }

  forwardMethods(DomApi.prototype, [
    'cloneNode', 'appendChild', 'insertBefore', 'removeChild',
    'replaceChild', 'setAttribute', 'removeAttribute',
    'querySelector', 'querySelectorAll'
  ]);

  forwardReadOnlyProperties(DomApi.prototype, [
    'parentNode', 'firstChild', 'lastChild',
    'nextSibling', 'previousSibling', 'firstElementChild',
    'lastElementChild', 'nextElementSibling', 'previousElementSibling',
    'childNodes', 'children', 'classList'
  ]);

  forwardProperties(DomApi.prototype, [
    'textContent', 'innerHTML'
  ]);


  class EventApi {
    constructor(event) {
      this.event = event;
    }

    get rootTarget() {
      return this.event.composedPath()[0];
    }

    get localTarget() {
      return this.event.target;
    }

    get path() {
      return this.event.composedPath();
    }
  }

  Polymer.dom = function(obj) {
    obj = obj || document;
    let ctor = obj instanceof Event ? EventApi : DomApi;
    if (!obj.__domApi) {
      obj.__domApi = new ctor(obj);
    }
    return obj.__domApi;
  };

  Polymer.dom.matchesSelector = matchesSelector;

  Polymer.dom.flush = Polymer.flush;

  Polymer.dom.addDebouncer = Polymer.enqueueDebouncer;

  Polymer.Settings = {
    useShadow: true
  };

})();
</script>
<script>
(function() {

  'use strict';

  let styleInterface = window.ShadyCSS;

  Polymer.LegacyElementMixin = Polymer.dedupingMixin(function(base) {

    const mixin = Polymer.GestureEventListeners(Polymer.ElementMixin(base));

    return class LegacyElement extends mixin {

      constructor() {
        super();
        this.created();
      }

      created() {}

      connectedCallback() {
        super.connectedCallback();
        this.isAttached = true;
        this.attached();
      }

      attached() {}

      disconnectedCallback() {
        super.disconnectedCallback();
        this.isAttached = false;
        this.detached();
      }

      detached() {}

      attributeChangedCallback(name, old, value) {
        if (old !== value) {
          super.attributeChangedCallback(name, old, value);
          this.attributeChanged(name, old, value);
        }
      }

      attributeChanged() {}

      _initializeProperties() {
        this._registered();
        super._initializeProperties();
      }

      /**
       * Called automatically when an element is initializing.
       * Users may override this method to perform class registration time
       * work. The implementation should ensure the work is performed
       * only once for the class.
       * @protected
       */
      _registered() {}

      ready() {
        this._ensureAttributes();
        this._applyListeners();
        super.ready();
      }

      /**
       * Ensures an element has required attributes. Called when the element
       * is being readied via `ready`. Users should override to set the
       * element's required attributes. The implementation should be sure
       * to check and not override existing attributes added by
       * the user of the element. Typically, setting attributes should be left
       * to the element user and not done here; reasonable exceptions include
       * setting aria roles and focusability.
       * @protected
       */
      _ensureAttributes() {}

      /**
       * Adds element event listeners. Called when the element
       * is being readied via `ready`. Users should override to
       * add any required element event listeners.
       * In performance critical elements, the work done here should be kept
       * to a minimum since it is done before the element is rendered. In
       * these elements, consider adding listeners asychronously so as not to
       * block render.
       * @protected
       */
      _applyListeners() {}

      serialize(value) {
        return this._serializeValue(value);
      }

      deserialize(value, type) {
        return this._deserializeValue(value, type);
      }

      reflectPropertyToAttribute(property, attribute, value) {
        this._propertyToAttribute(this, property, attribute, value);
      }

      serializeValueToAttribute(value, attribute, node) {
        this._valueToNodeAttribute(node || this, value, attribute);
      }

      /**
       * Copies own properties (including accessor descriptors) from a source
       * object to a target object.
       *
       * @method extend
       * @param {Object} prototype Target object to copy properties to.
       * @param {Object} api Source object to copy properties from.
       * @return {Object} prototype object that was passed as first argument.
       */
      extend(prototype, api) {
        if (!(prototype && api)) {
          return prototype || api;
        }
        let n$ = Object.getOwnPropertyNames(api);
        for (let i=0, n; (i<n$.length) && (n=n$[i]); i++) {
          let pd = Object.getOwnPropertyDescriptor(api, n);
          if (pd) {
            Object.defineProperty(prototype, n, pd);
          }
        }
        return prototype;
      }

      /**
       * Copies props from a source object to a target object.
       *
       * Note, this method uses a simple `for...in` strategy for enumerating
       * properties.  To ensure only `ownProperties` are copied from source
       * to target and that accessor implementations are copied, use `extend`.
       *
       * @method mixin
       * @param {Object} target Target object to copy properties to.
       * @param {Object} source Source object to copy properties from.
       * @return {Object} Target object that was passed as first argument.
       */
      mixin(target, source) {
        return Polymer.mixin(target, source);
      }

      chainObject(object, inherited) {
        if (object && inherited && object !== inherited) {
          object.__proto__ = inherited;
        }
        return object;
      }

      /* **** Begin Template **** */
      /**
       * Calls `importNode` on the `content` of the `template` specified and
       * returns a document fragment containing the imported content.
       *
       * @method instanceTemplate
       * @param {HTMLTemplateElement} template HTML template element to instance.
       * @return {DocumentFragment} Document fragment containing the imported
       *   template content.
      */
      instanceTemplate(template) {
        var dom = /** @type {DocumentFragment} */
          (document.importNode(template._content || template.content, true));
        return dom;
      }

      /* **** Begin Events **** */
      /**
       * Dispatches a custom event with an optional detail value.
       *
       * @method fire
       * @param {string} type Name of event type.
       * @param {*=} detail Detail value containing event-specific
       *   payload.
       * @param {Object=} options Object specifying options.  These may include:
       *  `bubbles` (boolean, defaults to `true`),
       *  `cancelable` (boolean, defaults to false), and
       *  `node` on which to fire the event (HTMLElement, defaults to `this`).
       * @return {Event} The new event that was fired.
       */
      fire(type, detail, options) {
        options = options || {};
        detail = (detail === null || detail === undefined) ? {} : detail;
        var event = new Event(type, {
          bubbles: options.bubbles === undefined ? true : options.bubbles,
          cancelable: Boolean(options.cancelable),
          composed: options.composed === undefined ? true: options.composed
        });
        event.detail = detail;
        var node = options.node || this;
        node.dispatchEvent(event)
        return event;
      }

      /**
       * Convenience method to add an event listener on a given element,
       * late bound to a named method on this element.
       *
       * @method listen
       * @param {Element} node Element to add event listener to.
       * @param {string} eventName Name of event to listen for.
       * @param {string} methodName Name of handler method on `this` to call.
       */
      listen(node, eventName, methodName) {
        node = node || this;
        var hbl = this.__boundListeners ||
          (this.__boundListeners = new WeakMap());
        var bl = hbl.get(node);
        if (!bl) {
          bl = {};
          hbl.set(node, bl);
        }
        var key = eventName + methodName;
        if (!bl[key]) {
          bl[key] = this._addMethodEventListenerToNode(
            node, eventName, methodName, this);
        }
      }

      /**
       * Convenience method to remove an event listener from a given element,
       * late bound to a named method on this element.
       *
       * @method unlisten
       * @param {Element} node Element to remove event listener from.
       * @param {string} eventName Name of event to stop listening to.
       * @param {string} methodName Name of handler method on `this` to not call
       anymore.
       */
      unlisten(node, eventName, methodName) {
        node = node || this;
        var bl = this.__boundListeners && this.__boundListeners.get(node);
        var key = eventName + methodName;
        var handler = bl && bl[key];
        if (handler) {
          this._removeEventListenerFromNode(node, eventName, handler);
          bl[key] = null;
        }
      }

      /**
       * Override scrolling behavior to all direction, one direction, or none.
       *
       * Valid scroll directions:
       *   - 'all': scroll in any direction
       *   - 'x': scroll only in the 'x' direction
       *   - 'y': scroll only in the 'y' direction
       *   - 'none': disable scrolling for this node
       *
       * @method setScrollDirection
       * @param {String=} direction Direction to allow scrolling
       * Defaults to `all`.
       * @param {HTMLElement=} node Element to apply scroll direction setting.
       * Defaults to `this`.
       */
      setScrollDirection(direction, node) {
        Polymer.Gestures.setTouchAction(node || this, direction || 'auto');
      }
      /* **** End Events **** */

      /**
       * Convenience method to run `querySelector` on this local DOM scope.
       *
       * This function calls `Polymer.dom(this.root).querySelector(slctr)`.
       *
       * @method $$
       * @param {string} slctr Selector to run on this local DOM scope
       * @return {Element} Element found by the selector, or null if not found.
       */
      $$(slctr) {
        return this.root.querySelector(slctr);
      }

      /**
       * Return the element whose local dom within which this element
       * is contained. This is a shorthand for
       * `this.getRootNode().host`.
       */
      get domHost() {
        var root = this.getRootNode();
        return (root instanceof DocumentFragment) ? root.host : root;
      }

      /**
       * Force this element to distribute its children to its local dom.
       * This is necessary only when ShadyDOM is used and only in cases that
       * are not automatically handled. For example,
       * a user should call `distributeContent` if distribution has been
       * invalidated due to an element being added or removed from the shadowRoot
       * that contains an insertion point (<slot>) inside its subtree.
       * @method distributeContent
       */
      distributeContent() {
        if (window.ShadyDOM && this.shadowRoot) {
          this.shadowRoot.forceRender();
        }
      }

      /**
       * Returns a list of nodes that are the effective childNodes. The effective
       * childNodes list is the same as the element's childNodes except that
       * any `<content>` elements are replaced with the list of nodes distributed
       * to the `<content>`, the result of its `getDistributedNodes` method.
       *
       * @method getEffectiveChildNodes
       * @return {Array<Node>} List of effctive child nodes.
       */
      getEffectiveChildNodes() {
        return Polymer.dom(this).getEffectiveChildNodes();
      }

      /**
       * Returns a list of nodes distributed within this element that match
       * `selector`. These can be dom children or elements distributed to
       * children that are insertion points.
       * @method queryDistributedElements
       * @param {string} selector Selector to run.
       * @return {Array<Node>} List of distributed elements that match selector.
       */
      queryDistributedElements(selector) {
        return Polymer.dom(this).queryDistributedElements(selector);
      }

      /**
       * Returns a list of elements that are the effective children. The effective
       * children list is the same as the element's children except that
       * any `<content>` elements are replaced with the list of elements
       * distributed to the `<content>`.
       *
       * @method getEffectiveChildren
       * @return {Array<Node>} List of effctive children.
       */
      getEffectiveChildren() {
        var list = this.getEffectiveChildNodes();
        return list.filter(function(n) {
          return (n.nodeType === Node.ELEMENT_NODE);
        });
      }

      /**
       * Returns a string of text content that is the concatenation of the
       * text content's of the element's effective childNodes (the elements
       * returned by <a href="#getEffectiveChildNodes>getEffectiveChildNodes</a>.
       *
       * @method getEffectiveTextContent
       * @return {string} List of effctive children.
       */
      getEffectiveTextContent() {
        var cn = this.getEffectiveChildNodes();
        var tc = [];
        for (var i=0, c; (c = cn[i]); i++) {
          if (c.nodeType !== Node.COMMENT_NODE) {
            tc.push(c.textContent);
          }
        }
        return tc.join('');
      }

      /**
       * Returns the first effective childNode within this element that
       * match `selector`. These can be dom child nodes or elements distributed
       * to children that are insertion points.
       * @method queryEffectiveChildren
       * @param {string} selector Selector to run.
       * @return {Object<Node>} First effective child node that matches selector.
       */
      queryEffectiveChildren(selector) {
        var e$ = this.queryDistributedElements(selector);
        return e$ && e$[0];
      }

      /**
       * Returns a list of effective childNodes within this element that
       * match `selector`. These can be dom child nodes or elements distributed
       * to children that are insertion points.
       * @method queryEffectiveChildren
       * @param {string} selector Selector to run.
       * @return {Array<Node>} List of effective child nodes that match selector.
       */
      queryAllEffectiveChildren(selector) {
        return this.queryDistributedElements(selector);
      }

      /**
       * Returns a list of nodes distributed to this element's `<content>`.
       *
       * If this element contains more than one `<content>` in its local DOM,
       * an optional selector may be passed to choose the desired content.
       *
       * @method getContentChildNodes
       * @param {String=} slctr CSS selector to choose the desired
       *   `<content>`.  Defaults to `content`.
       * @return {Array<Node>} List of distributed nodes for the `<content>`.
       */
      getContentChildNodes(slctr) {
        var content = this.root.querySelector(slctr || 'content');
        return content ? content.getDistributedNodes() : [];
      }

      /**
       * Returns a list of element children distributed to this element's
       * `<content>`.
       *
       * If this element contains more than one `<content>` in its
       * local DOM, an optional selector may be passed to choose the desired
       * content.  This method differs from `getContentChildNodes` in that only
       * elements are returned.
       *
       * @method getContentChildNodes
       * @param {String=} slctr CSS selector to choose the desired
       *   `<content>`.  Defaults to `content`.
       * @return {Array<HTMLElement>} List of distributed nodes for the
       *   `<content>`.
       */
      getContentChildren(slctr) {
        return this.getContentChildNodes(slctr).filter(function(n) {
          return (n.nodeType === Node.ELEMENT_NODE);
        });
      }

      /**
       * Checks whether an element is in this element's light DOM tree.
       *
       * @method isLightDescendant
       * @param {?Node} node The element to be checked.
       * @return {Boolean} true if node is in this element's light DOM tree.
       */
      isLightDescendant(node) {
        return this !== node && this.contains(node) &&
            this.getRootNode() === node.getRootNode();
      }

      /**
       * Checks whether an element is in this element's local DOM tree.
       *
       * @method isLocalDescendant
       * @param {HTMLElement=} node The element to be checked.
       * @return {boolean} true if node is in this element's local DOM tree.
       */
      isLocalDescendant(node) {
        return this.root === node.getRootNode();
      }

      // NOTE: should now be handled by ShadyCss library.
      scopeSubtree(container, shouldObserve) { // eslint-disable-line no-unused-vars
      }

      /**
       * Returns the computed style value for the given property.
       * @param {String} property
       * @return {String} the computed value
       */
      getComputedStyleValue(property) {
        return styleInterface.getComputedStyleValue(this, property);
      }

      // debounce

      /**
       * Call `debounce` to collapse multiple requests for a named task into
       * one invocation which is made after the wait time has elapsed with
       * no new request.  If no wait time is given, the callback will be called
       * at microtask timing (guaranteed before paint).
       *
       *     debouncedClickAction(e) {
       *       // will not call `processClick` more than once per 100ms
       *       this.debounce('click', function() {
       *        this.processClick();
       *       } 100);
       *     }
       *
       * @method debounce
       * @param {String} jobName String to indentify the debounce job.
       * @param {function()} callback Function that is called (with `this`
       *   context) when the wait time elapses.
       * @param {number} wait Optional wait time in milliseconds (ms) after the
       *   last signal that must elapse before invoking `callback`
       */
      debounce(jobName, callback, wait) {
        this._debouncers = this._debouncers || {};
        return this._debouncers[jobName] = Polymer.Debouncer.debounce(
              this._debouncers[jobName]
            , wait > 0 ? Polymer.Async.timeOut.after(wait) : Polymer.Async.microTask
            , callback.bind(this));
      }

      /**
       * Returns whether a named debouncer is active.
       *
       * @method isDebouncerActive
       * @param {String} jobName The name of the debouncer started with `debounce`
       * @return {boolean} Whether the debouncer is active (has not yet fired).
       */
      isDebouncerActive(jobName) {
        this._debouncers = this._debouncers || {};
        var debouncer = this._debouncers[jobName];
        return !!(debouncer && debouncer.isActive());
      }

      /**
       * Immediately calls the debouncer `callback` and inactivates it.
       *
       * @method flushDebouncer
       * @param {String} jobName The name of the debouncer started with `debounce`
       */
      flushDebouncer(jobName) {
        this._debouncers = this._debouncers || {};
        var debouncer = this._debouncers[jobName];
        if (debouncer) {
          debouncer.flush();
        }
      }

      /**
       * Cancels an active debouncer.  The `callback` will not be called.
       *
       * @method cancelDebouncer
       * @param {String} jobName The name of the debouncer started with `debounce`
       */
      cancelDebouncer(jobName) {
        this._debouncers = this._debouncers || {}
        var debouncer = this._debouncers[jobName];
        if (debouncer) {
          debouncer.cancel();
        }
      }

      /**
       * Runs a callback function asyncronously.
       *
       * By default (if no waitTime is specified), async callbacks are run at
       * microtask timing, which will occur before paint.
       *
       * @method async
       * @param {Function} callback The callback function to run, bound to `this`.
       * @param {number=} waitTime Time to wait before calling the
       *   `callback`.  If unspecified or 0, the callback will be run at microtask
       *   timing (before paint).
       * @return {number} Handle that may be used to cancel the async job.
       */
      async(callback, waitTime) {
        return waitTime > 0 ? Polymer.Async.timeOut.run(callback.bind(this), waitTime) :
            ~Polymer.Async.microTask.run(callback.bind(this));
      }

      /**
       * Cancels an async operation started with `async`.
       *
       * @method cancelAsync
       * @param {number} handle Handle returned from original `async` call to
       *   cancel.
       */
      cancelAsync(handle) {
        handle < 0 ? Polymer.Async.microTask.cancel(~handle) :
            Polymer.Async.timeOut.cancel(handle);
      }

      // other

      /**
       * Convenience method for creating an element and configuring it.
       *
       * @method create
       * @param {string} tag HTML element tag to create.
       * @param {Object} props Object of properties to configure on the
       *    instance.
       * @return {Element} Newly created and configured element.
       */
      create(tag, props) {
        var elt = document.createElement(tag);
        if (props) {
          if (elt.setProperties) {
            elt.setProperties(props);
          } else {
            for (var n in props) {
              elt[n] = props[n];
            }
          }
        }
        return elt;
      }

      /**
       * Convenience method for importing an HTML document imperatively.
       *
       * This method creates a new `<link rel="import">` element with
       * the provided URL and appends it to the document to start loading.
       * In the `onload` callback, the `import` property of the `link`
       * element will contain the imported document contents.
       *
       * @method importHref
       * @param {string} href URL to document to load.
       * @param {Function} onload Callback to notify when an import successfully
       *   loaded.
       * @param {Function} onerror Callback to notify when an import
       *   unsuccessfully loaded.
       * @param {boolean} optAsync True if the import should be loaded `async`.
       *   Defaults to `false`.
       * @return {HTMLLinkElement} The link element for the URL to be loaded.
       */
      importHref(href, onload, onerror, optAsync) { // eslint-disable-line no-unused-vars
        let loadFn = onload ? onload.bind(this) : null;
        let errorFn = onerror ? onerror.bind(this) : null;
        return Polymer.importHref(href, loadFn, errorFn, optAsync);
      }

      /**
       * Polyfill for Element.prototype.matches, which is sometimes still
       * prefixed.
       *
       * @method elementMatches
       * @param {string} selector Selector to test.
       * @param {Element=} node Element to test the selector against.
       * @return {boolean} Whether the element matches the selector.
       */
      elementMatches(selector, node) {
        return Polymer.dom.matchesSelector(node || this, selector);
      }

      /**
       * Toggles an HTML attribute on or off.
       *
       * @method toggleAttribute
       * @param {String} name HTML attribute name
       * @param {boolean=} bool Boolean to force the attribute on or off.
       *    When unspecified, the state of the attribute will be reversed.
       * @param {HTMLElement=} node Node to target.  Defaults to `this`.
       */
      toggleAttribute(name, bool, node) {
        node = node || this;
        if (arguments.length == 1) {
          bool = !node.hasAttribute(name);
        }
        if (bool) {
          node.setAttribute(name, '');
        } else {
          node.removeAttribute(name);
        }
      }


      /**
       * Toggles a CSS class on or off.
       *
       * @method toggleClass
       * @param {String} name CSS class name
       * @param {boolean=} bool Boolean to force the class on or off.
       *    When unspecified, the state of the class will be reversed.
       * @param {HTMLElement=} node Node to target.  Defaults to `this`.
       */
      toggleClass(name, bool, node) {
        node = node || this;
        if (arguments.length == 1) {
          bool = !node.classList.contains(name);
        }
        if (bool) {
          node.classList.add(name);
        } else {
          node.classList.remove(name);
        }
      }

      /**
       * Cross-platform helper for setting an element's CSS `transform` property.
       *
       * @param {string} transformText Transform setting.
       * @param {HTMLElement=} node Element to apply the transform to.
       * Defaults to `this`
       */
      transform(transformText, node) {
        node = node || this;
        node.style.webkitTransform = transformText;
        node.style.transform = transformText;
      }

      /**
       * Cross-platform helper for setting an element's CSS `translate3d`
       * property.
       *
       * @method translate3d
       * @param {number} x X offset.
       * @param {number} y Y offset.
       * @param {number} z Z offset.
       * @param {HTMLElement=} node Element to apply the transform to.
       * Defaults to `this`.
       */
      translate3d(x, y, z, node) {
        node = node || this;
        this.transform('translate3d(' + x + ',' + y + ',' + z + ')', node);
      }

      /**
       * Removes an item from an array, if it exists.
       *
       * If the array is specified by path, a change notification is
       * generated, so that observers, data bindings and computed
       * properties watching that path can update.
       *
       * If the array is passed directly, **no change
       * notification is generated**.
       *
       * @method arrayDelete
       * @param {string | !Array<number|string>} arrayOrPath Path to array from which to remove the item
       *   (or the array itself).
       * @param {*} item Item to remove.
       * @return {Array} Array containing item removed.
       */
      arrayDelete(arrayOrPath, item) {
        var index;
        if (Array.isArray(arrayOrPath)) {
          index = arrayOrPath.indexOf(item);
          if (index >= 0) {
            return arrayOrPath.splice(index, 1);
          }
        } else {
          var arr = Polymer.Path.get(this, arrayOrPath);
          index = arr.indexOf(item);
          if (index >= 0) {
            return this.splice(arrayOrPath, index, 1);
          }
        }
        return null;
      }

      // logging
      _logger(level, args) {
        // accept ['foo', 'bar'] and [['foo', 'bar']]
        if (Array.isArray(args) && args.length === 1) {
          args = args[0];
        }
        switch(level) {
          case 'log':
          case 'warn':
          case 'error':
            console[level](...args);
        }
      }

      _log(...args) {
        this._logger('log', args);
      }

      _warn(...args) {
        this._logger('warn', args);
      }

      _error(...args) {
        this._logger('error', args)
      }

      _logf(...args) {
        return ['[%s::%s]', this.is, ...args];
      }

    }

  });

})();
</script>
<script>

  (function() {

    'use strict';

    let LegacyElementMixin = Polymer.LegacyElementMixin;

    let metaProps = {
      attached: true,
      detached: true,
      ready: true,
      created: true,
      beforeRegister: true,
      registered: true,
      attributeChanged: true,
      // meta objects
      behaviors: true,
      hostAttributes: true,
      properties: true,
      observers: true,
      listeners: true
    }

    function mixinBehaviors(behaviors, klass) {
      if (!behaviors) {
        return klass;
      }
      // NOTE: ensure the bahevior is extending a class with
      // legacy element api. This is necessary since behaviors expect to be able
      // to access 1.x legacy api.
      klass = LegacyElementMixin(klass);
      if (!Array.isArray(behaviors)) {
        behaviors = [behaviors];
      }
      let superBehaviors = klass.behaviors;
      // get flattened, deduped list of behaviors *not* already on super class
      behaviors = flattenBehaviors(behaviors, null, superBehaviors);
      // mixin new behaviors
      klass = _mixinBehaviors(behaviors, klass);
      if (superBehaviors) {
        behaviors = superBehaviors.concat(behaviors);
      }
      klass.behaviors = behaviors;
      return klass;
    }

    // NOTE:
    // 1.x
    // Behaviors were mixed in *in reverse order* and de-duped on the fly.
    // The rule was that behavior properties were copied onto the element
    // prototype if and only if the property did not already exist.
    // Given: Polymer{ behaviors: [A, B, C, A, B]}, property copy order was:
    // (1), B, (2), A, (3) C. This means prototype properties win over
    // B properties win over A win over C. This mirrors what would happen
    // with inheritance if element extended B extended A extended C.
    //
    // Again given, Polymer{ behaviors: [A, B, C, A, B]}, the resulting
    // `behaviors` array was [C, A, B].
    // Behavior lifecycle methods were called in behavior array order
    // followed by the element, e.g. (1) C.created, (2) A.created,
    // (3) B.created, (4) element.created. There was no support for
    // super, and "super-behavior" methods were callable only by name).
    //
    // 2.x
    // Behaviors are made into proper mixins which live in the
    // element's prototype chain. Behaviors are placed in the element prototype
    // eldest to youngest and de-duped youngest to oldest:
    // So, first [A, B, C, A, B] becomes [C, A, B] then,
    // the element prototype becomes (oldest) (1) Polymer.Element, (2) class(C),
    // (3) class(A), (4) class(B), (5) class(Polymer({...})).
    // Result:
    // This means element properties win over B properties win over A win
    // over C. (same as 1.x)
    // If lifecycle is called (super then me), order is
    // (1) C.created, (2) A.created, (3) B.created, (4) element.created
    // (again same as 1.x)
    function _mixinBehaviors(behaviors, klass) {
      for (let i=0; i<behaviors.length; i++) {
        let b = behaviors[i];
        if (b) {
          klass = Array.isArray(b) ? _mixinBehaviors(b, klass) :
            GenerateClassFromInfo(b, klass);
        }
      }
      return klass;
    }

    /**
     * @param {Array} behaviors
     * @param {Array=} list
     * @param {Array=} exclude
     */
    function flattenBehaviors(behaviors, list, exclude) {
      list = list || [];
      for (let i=behaviors.length-1; i >= 0; i--) {
        let b = behaviors[i];
        if (b) {
          if (Array.isArray(b)) {
            flattenBehaviors(b, list);
          } else {
            // dedup
            if (list.indexOf(b) < 0 && (!exclude || exclude.indexOf(b) < 0)) {
              list.unshift(b);
            }
          }
        } else {
          Polymer._warn('behavior is null, check for missing or 404 import');
        }
      }
      return list;
    }

    function GenerateClassFromInfo(info, Base) {

      let config = {
        properties: info.properties,
        observers: info.observers,
        generatedFrom: info
      };

      let registered = false;

      class PolymerGenerated extends Base {

        static get config() {
          return config;
        }

        static get template() {
          // get template first from any imperative set in `info._template`
          return info._template ||
            // next look in dom-module associated with this element's is.
            Polymer.DomModule.import(this.is, 'template') ||
            // next look for superclass template (note: use superclass symbol
            // to ensure correct `this.is`)
            Base.template ||
            // finally fall back to `_template` in element's protoype.
            this.prototype._template;
        }

        created() {
          super.created();
          if (info.created) {
            info.created.call(this);
          }
        }

        _registered() {
          if (!registered) {
            super._registered();
            // call `registered` only if it was not called for *this* constructor
            registered = true;
            if (info.registered) {
              info.registered.call(Object.getPrototypeOf(this));
            }
          }
        }

        _applyListeners() {
          super._applyListeners();
          if (info.listeners) {
            for (let l in info.listeners) {
              this._addMethodEventListenerToNode(this, l, info.listeners[l]);
            }
          }
        }

        // note: exception to "super then me" rule;
        // do work before calling super so that super attributes
        // only apply if not already set.
        _ensureAttributes() {
          if (info.hostAttributes) {
            for (let a in info.hostAttributes) {
              this._ensureAttribute(a, info.hostAttributes[a]);
            }
          }
          super._ensureAttributes();
        }

        ready() {
          super.ready();
          if (info.ready) {
            info.ready.call(this);
          }
        }

        attached() {
          super.attached();
          if (info.attached) {
            info.attached.call(this);
          }
        }

        detached() {
          super.detached();
          if (info.detached) {
            info.detached.call(this);
          }
        }

        attributeChanged(name, old, value) {
          super.attributeChanged(name, old, value);
          if (info.attributeChanged) {
            info.attributeChanged.call(this, name, old, value);
          }
       }
      }

      for (let p in info) {
        // NOTE: cannot copy `metaProps` methods onto prototype at least because
        // `super.ready` must be called and is not included in the user fn.
        if (!(p in metaProps)) {
          let pd = Object.getOwnPropertyDescriptor(info, p);
          if (pd) {
            Object.defineProperty(PolymerGenerated.prototype, p, pd);
          }
        }
      }

      return PolymerGenerated;
    }

    Polymer.Class = function(info) {
      if (!info) {
        Polymer._warn('Polymer.Class requires `info` argument');
      }
      let klass = GenerateClassFromInfo(info, info.behaviors ?
        // note: mixinBehaviors ensures `LegacyElementMixin`.
        mixinBehaviors(info.behaviors, HTMLElement) :
        LegacyElementMixin(HTMLElement));
      // decorate klass with registration info
      klass.is = info.is;
      // behaviors on prototype for BC...
      klass.prototype.behaviors = klass.behaviors;
      // NOTE: while we could call `beforeRegister` here to maintain
      // some BC, the state of the element at this point is not as it was in 1.0
      // In 1.0, the method was called *after* mixing prototypes together
      // but before processing of meta-objects. Since this is now done
      // in 1 step via `GenerateClassFromInfo`, this is no longer possible.
      // However, *most* work (not setting `is`) that was previously done in
      // `beforeRegister` should be possible in `registered`.
      return klass;
    }

    Polymer.mixinBehaviors = mixinBehaviors;

  })();

</script>
<script>

  (function() {

    window.Polymer._polymerFn = function(info) {
      // if input is a `class` (aka a function with a prototype), use the prototype
      // remember that the `constructor` will never be called
      var klass;
      if (typeof info === 'function') {
        klass = info;
      } else {
        klass = Polymer.Class(info);
      }
      var options = {};
      if (klass.extends) {
        options.extends = klass.extends;
      }
      customElements.define(klass.is, klass, options);
      return klass;
    };

  })();

</script>
<script>
  (function() {
    'use strict';

    // Base class for HTMLTemplateElement extension that has property effects
    // machinery for propagating host properties to children. This is an ES5
    // class only because Babel (incorrectly) requires super() in the class
    // constructor even though no `this` is used and it returns an instance.
    let newInstance = null;
    function HTMLTemplateElementExtension() { return newInstance; }
    HTMLTemplateElementExtension.prototype = Object.create(HTMLTemplateElement.prototype, {
      constructor: {
        value: HTMLTemplateElementExtension,
        writable: true
      }
    });
    const DataTemplate = Polymer.PropertyEffects(HTMLTemplateElementExtension);

    // Applies a DataTemplate subclass to a <template> instance
    function upgradeTemplate(template, constructor) {
      newInstance = template;
      Object.setPrototypeOf(template, constructor.prototype);
      new constructor();
      newInstance = null;
    }

    // Base class for TemplateInstance's
    class TemplateInstanceBase extends Polymer.PropertyEffects(class{}) {
      constructor(props) {
        super();
        this._configureProperties(props);
        this.root = this._stampTemplate(this.__dataHost);
        // Save list of stamped children
        let children = this.children = [];
        for (let n = this.root.firstChild; n; n=n.nextSibling) {
          children.push(n);
          n._templateInstance = this;
        }
        if (this.__templatizeOwner.__hideTemplateChildren__) {
          this._showHideChildren(true);
        }
        // Flush props only when props are passed if instance props exist
        // or when there isn't instance props.
        let options = this.__templatizeOptions;
        if ((props && options.instanceProps) || !options.instanceProps) {
          this._flushProperties();
        }
      }
      _configureProperties(props) {
        let options = this.__templatizeOptions;
        if (props) {
          for (let iprop in options.instanceProps) {
            if (iprop in props) {
              this._setPendingProperty(iprop, props[iprop]);
            }
          }
        }
        for (let hprop in this.__hostProps) {
          this._setPendingProperty(hprop, this.__dataHost['_host_' + hprop]);
        }
      }
      forwardHostProp(prop, value) {
        if (this._setPendingPropertyOrPath(prop, value, false, true)) {
          this.__dataHost._enqueueClient(this);
        }
      }
      _addEventListenerToNode(node, eventName, handler) {
        if (this._methodHost) {
          this._methodHost._addEventListenerToNode(node, eventName, (e) => {
            e.model = this;
            handler(e);
          });
        }
      }
      _showHideChildren(hide) {
        let c = this.children;
        for (let i=0; i<c.length; i++) {
          let n = c[i];
          // Ignore non-changes
          if (Boolean(hide) != Boolean(n.__hideTemplateChildren__)) {
            if (n.nodeType === Node.TEXT_NODE) {
              if (hide) {
                n.__polymerTextContent__ = n.textContent;
                n.textContent = '';
              } else {
                n.textContent = n.__polymerTextContent__;
              }
            } else if (n.style) {
              if (hide) {
                n.__polymerDisplay__ = n.style.display;
                n.style.display = 'none';
              } else {
                n.style.display = n.__polymerDisplay__;
              }
            }
          }
          n.__hideTemplateChildren__ = hide;
          if (n._showHideChildren) {
            n._showHideChildren(hide);
          }
        }
      }
      /**
       * Overrides default property-effects implementation to intercept
       * textContent bindings while children are "hidden" and cache in
       * private storage for later retrieval.
       *
       * @override
       */
      _setUnmanagedPropertyToNode(node, prop, value) {
        if (node.__hideTemplateChildren__ &&
            node.nodeType == Node.TEXT_NODE && prop == 'textContent') {
          node.__polymerTextContent__ = value;
        } else {
          super._setUnmanagedPropertyToNode(node, prop, value);
        }
      }
    }

    function findMethodHost(template) {
      // Technically this should be the owner of the outermost template.
      // In shadow dom, this is always getRootNode().host, but we can
      // approximate this via cooperation with our dataHost always setting
      // `_methodHost` as long as there were bindings (or id's) on this
      // instance causing it to get a dataHost.
      let templateHost = template.__dataHost;
      return templateHost && templateHost._methodHost || templateHost;
    }

    function createTemplatizerClass(template, options) {
      // Anonymous class created by the templatize
      /**
       * @unrestricted
       */
      let klass = class extends TemplateInstanceBase { }
      klass.prototype.__templatizeOptions = options;
      klass.prototype._bindTemplate(template);
      addNotifyEffects(klass, template, options);
      return klass;
    }

    function addPropagateEffects(template, options) {
      let userForwardHostProp = options.forwardHostProp;
      if (userForwardHostProp) {
        // Provide data API and property effects on memoized template class
        let klass = template._content.__templatizeTemplateClass;
        if (!klass) {
          klass = template._content.__templatizeTemplateClass =
            class TemplatizedTemplate extends DataTemplate {}
          // Add template - >instances effects
          // and host <- template effects
          let hostProps = template._content._hostProps;
          for (let prop in hostProps) {
            klass.prototype._addPropertyEffect('_host_' + prop,
              klass.prototype.PROPERTY_EFFECT_TYPES.PROPAGATE,
              {fn: createForwardHostPropEffect(prop, userForwardHostProp)});
            klass.prototype._createNotifyingProperty('_host_' + prop);
          }
        }
        upgradeTemplate(template, klass);
        // Mix any pre-bound data into __data; no need to flush this to
        // instances since they pull from the template at instance-time
        if (template.__dataProto) {
          Polymer.mixin(template.__data, template.__dataProto);
        }
        // Clear any pending data for performance
        template.__dataTemp = {};
        template.__dataPending = null;
        template.__dataOld = null;
        template._flushProperties();
      }
    }

    function createForwardHostPropEffect(hostProp, userForwardHostProp) {
      return function forwardHostProp(template, prop, props) {
        userForwardHostProp.call(template.__templatizeOwner,
          prop.substring('_host_'.length), props[prop]);
      }
    }

    function addNotifyEffects(klass, template, options) {
      let hostProps = template._content._hostProps || {};
      for (let iprop in options.instanceProps) {
        delete hostProps[iprop];
        let userNotifyInstanceProp = options.notifyInstanceProp;
        if (userNotifyInstanceProp) {
          klass.prototype._addPropertyEffect(iprop,
            klass.prototype.PROPERTY_EFFECT_TYPES.NOTIFY,
            {fn: createNotifyInstancePropEffect(iprop, userNotifyInstanceProp)});
        }
      }
      if (options.forwardHostProp && template.__dataHost) {
        for (let hprop in hostProps) {
          klass.prototype._addPropertyEffect(hprop,
            klass.prototype.PROPERTY_EFFECT_TYPES.NOTIFY,
            {fn: createNotifyHostPropEffect()})
        }
      }
    }

    function createNotifyInstancePropEffect(instProp, userNotifyInstanceProp) {
      return function notifyInstanceProp(inst, prop, props) {
        userNotifyInstanceProp.call(inst.__templatizeOwner,
          inst, prop, props[prop]);
      }
    }

    function createNotifyHostPropEffect() {
      return function notifyHostProp(inst, prop, props) {
        inst.__dataHost._setPendingPropertyOrPath('_host_' + prop, props[prop], true, true);
      }
    }

    let Templatize = {

      templatize(template, owner, options) {
        if (template.__templatizeOwner) {
          throw new Error('A <template> can only be templatized once');
        }
        template.__templatizeOwner = owner;
        // Ensure template has _content
        template._content = template._content || template.content;
        // Get memoized base class for the prototypical template, which
        // includes property effects for binding template & forwarding
        let baseClass = template._content.__templatizeInstanceClass;
        if (!baseClass) {
          baseClass = template._content.__templatizeInstanceClass =
            createTemplatizerClass(template, options);
        }
        // Host property forwarding must be installed onto template instance
        addPropagateEffects(template, options);
        // Subclass base class and add reference for this specific template
        let klass = class TemplateInstance extends baseClass {};
        klass.prototype._methodHost = findMethodHost(template);
        klass.prototype.__dataHost = template;
        klass.prototype.__templatizeOwner = owner;
        klass.prototype.__hostProps = template._content._hostProps;
        return klass;
      },

      /**
       * Returns the template "model" associated with a given element, which
       * serves as the binding scope for the template instance the element is
       * contained in. A template model is an instance of `Polymer.Base`, and
       * should be used to manipulate data associated with this template instance.
       *
       * Example:
       *
       *   let model = modelForElement(el);
       *   if (model.index < 10) {
       *     model.set('item.checked', true);
       *   }
       *
       * @method modelForElement
       * @param {HTMLElement} el Element for which to return a template model.
       * @return {TemplateInstanceBase} Model representing the binding scope for
       *   the element.
       */
      modelForElement(host, el) {
        let model;
        while (el) {
          // An element with a _templateInstance marks the top boundary
          // of a scope; walk up until we find one, and then ensure that
          // its __dataHost matches `this`, meaning this dom-repeat stamped it
          if ((model = el._templateInstance)) {
            // Found an element stamped by another template; keep walking up
            // from its __dataHost
            if (model.__dataHost != host) {
              el = model.__dataHost;
            } else {
              return model;
            }
          } else {
            // Still in a template scope, keep going up until
            // a _templateInstance is found
            el = el.parentNode;
          }
        }
        return null;
      }
    }

    Polymer.Templatize = Templatize;

  })();

</script>
<script>
  (function() {
    'use strict';

    let Templatizer = {
      templatize(template) {
        this._templatizerTemplate = template;
        this.ctor = Polymer.Templatize.templatize(template, this, {
          instanceProps: this._instanceProps,
          forwardHostProp: this._forwardHostPropV2,
          notifyInstanceProp: this._notifyInstancePropV2
        });
      },
      stamp(model) {
        return new this.ctor(model);
      },
      modelForElement(el) {
        return Polymer.Templatize.modelForElement(this._templatizerTemplate, el);
      }
    };

    Polymer.Templatizer = Templatizer;

  })();
</script>
<script>

  (function() {

    const mixin = Polymer.PropertyEffects(HTMLElement);

    class DomBind extends mixin {

      connectedCallback() {
        this.render();
      }

      disconnectedCallback() {
        this.__removeChildren();
      }

      __insertChildren() {
        this.parentNode.insertBefore(this.root, this);
      }

      __removeChildren() {
        if (this.__children) {
          for (let i=0; i<this.__children.length; i++) {
            this.root.appendChild(this.__children[i]);
          }
        }
      }

      /**
       * Forces the element to render its content. This is typically only
       * necessary to call if HTMLImports with the async attribute are used.
       */
      render() {
        let template;
        if (!this.__children) {
          template = template || this.querySelector('template');
          if (!template) {
            // Wait until childList changes and template should be there by then
            let observer = new MutationObserver(() => {
              template = this.querySelector('template');
              if (template) {
                observer.disconnect();
                this.render(template);
              } else {
                throw new Error('dom-bind requires a <template> child');
              }
            })
            observer.observe(this, {childList: true});
            return;
          }
          this._bindTemplate(template);
          this.root = this._stampTemplate(template);
          this.__children = [];
          for (let n=this.root.firstChild; n; n=n.nextSibling) {
            this.__children[this.__children.length] = n;
          }
          this._flushProperties();
        }
        this.__insertChildren();
        this.dispatchEvent(new CustomEvent('dom-change', {bubbles: true}));
      }

    }

    customElements.define('dom-bind', DomBind);

  })();

</script>
<script>
  Polymer.Element = Polymer.ElementMixin(HTMLElement);
</script><script>
(function() {
  'use strict';

  class DomRepeat extends Polymer.Element {

    static get template() { return null; }

    static get config() {

      return {

        /**
         * Fired whenever DOM is added or removed by this template (by
         * default, rendering occurs lazily).  To force immediate rendering, call
         * `render`.
         *
         * @event dom-change
         */

        properties: {

          /**
           * An array containing items determining how many instances of the template
           * to stamp and that that each template instance should bind to.
           */
          items: {
            type: Array
          },

          /**
           * The name of the variable to add to the binding scope for the array
           * element associated with a given template instance.
           */
          as: {
            type: String,
            value: 'item'
          },

          /**
           * The name of the variable to add to the binding scope with the index
           * for the inst.  If `sort` is provided, the index will reflect the
           * sorted order (rather than the original array order).
           */
          indexAs: {
            type: String,
            value: 'index'
          },

          /**
           * The name of the variable to add to the binding scope with the index
           * for the inst.  If `sort` is provided, the index will reflect the
           * sorted order (rather than the original array order).
           */
          itemsIndexAs: {
            type: String,
            value: 'itemsIndex'
          },

          /**
           * A function that should determine the sort order of the items.  This
           * property should either be provided as a string, indicating a method
           * name on the element's host, or else be an actual function.  The
           * function should match the sort function passed to `Array.sort`.
           * Using a sort function has no effect on the underlying `items` array.
           */
          sort: {
            type: Function,
            observer: '__sortChanged'
          },

          /**
           * A function that can be used to filter items out of the view.  This
           * property should either be provided as a string, indicating a method
           * name on the element's host, or else be an actual function.  The
           * function should match the sort function passed to `Array.filter`.
           * Using a filter function has no effect on the underlying `items` array.
           */
          filter: {
            type: Function,
            observer: '__filterChanged'
          },

          /**
           * When using a `filter` or `sort` function, the `observe` property
           * should be set to a space-separated list of the names of item
           * sub-fields that should trigger a re-sort or re-filter when changed.
           * These should generally be fields of `item` that the sort or filter
           * function depends on.
           */
          observe: {
            type: String,
            observer: '__observeChanged'
          },

          /**
           * When using a `filter` or `sort` function, the `delay` property
           * determines a debounce time after a change to observed item
           * properties that must pass before the filter or sort is re-run.
           * This is useful in rate-limiting shuffing of the view when
           * item changes may be frequent.
           */
          delay: Number,

          /**
           * Count of currently rendered items after `filter` (if any) has been applied.
           * If "chunking mode" is enabled, `renderedItemCount` is updated each time a
           * set of template instances is rendered.
           *
           */
          renderedItemCount: {
            type: Number,
            notify: true,
            readOnly: true
          },

          /**
           * Defines an initial count of template instances to render after setting
           * the `items` array, before the next paint, and puts the `dom-repeat`
           * into "chunking mode".  The remaining items will be created and rendered
           * incrementally at each animation frame therof until all instances have
           * been rendered.
           */
          initialCount: {
            type: Number,
            observer: '__initializeChunking'
          },

          /**
           * When `initialCount` is used, this property defines a frame rate to
           * target by throttling the number of instances rendered each frame to
           * not exceed the budget for the target frame rate.  Setting this to a
           * higher number will allow lower latency and higher throughput for
           * things like event handlers, but will result in a longer time for the
           * remaining items to complete rendering.
           */
          targetFramerate: {
            type: Number,
            value: 20
          },

          _targetFrameTime: {
            type: Number,
            computed: '__computeFrameTime(targetFramerate)'
          }

        },

        observers: [
          '__itemsChanged(items.*)'
        ]

      }

    }

    constructor() {
      super();
      this.__instances = [];
      this.__limit = Infinity;
      this.__pool = [];
      this.__renderDebouncer = null;
      this.__itemsIdxToInstIdx = {};
      this.__chunkCount = null;
      this.__lastChunkTime = null;
      this.__needFullRefresh = false;
      this.__sortFn = null;
      this.__filterFn = null;
      this.__observePaths = null;
      this.__ctor = null;
    }

    disconnectedCallback() {
      super.disconnectedCallback();
      this.__isDetached = true;
      for (var i=0; i<this.__instances.length; i++) {
        this.__detachInstance(i);
      }
    }

    connectedCallback() {
      super.connectedCallback();
      // only perform attachment if the element was previously detached.
      if (this.__isDetached) {
        this.__isDetached = false;
        var parent = this.parentNode;
        for (var i=0; i<this.__instances.length; i++) {
          this.__attachInstance(i, parent);
        }
      }
    }

    __ensureTemplatized() {
      // Templatizing (generating the instance constructor) needs to wait
      // until ready, since won't have its template content handed back to
      // it until then
      if (!this.__ctor) {
        var template = this.template = this.querySelector('template');
        if (!template) {
          // // Wait until childList changes and template should be there by then
          let observer = new MutationObserver(() => {
            if (this.querySelector('template')) {
              observer.disconnect();
              this.__render();
            } else {
              throw new Error('dom-repeat requires a <template> child');
            }
          })
          observer.observe(this, {childList: true});
          return false;
        }
        // Template instance props that should be excluded from forwarding
        var instanceProps = {};
        instanceProps[this.as] = true;
        instanceProps[this.indexAs] = true;
        instanceProps[this.itemsIndexAs] = true;
        this.__ctor = Polymer.Templatize.templatize(template, this, {
          instanceProps: instanceProps,
          forwardHostProp: function(prop, value) {
            var i$ = this.__instances;
            for (var i=0, inst; (i<i$.length) && (inst=i$[i]); i++) {
              inst.forwardHostProp(prop, value);
            }
          },
          notifyInstanceProp: function(inst, prop, value) {
            if (Polymer.Path.matches(this.as, prop)) {
              let idx = inst[this.itemsIndexAs];
              if (prop == this.as) {
                this.items[idx] = value;
              }
              let path = Polymer.Path.translate(this.as, 'items.' + idx, prop);
              this.notifyPath(path, value);
            }
          }
        });
      }
      return true;
    }

    __getMethodHost() {
      // Technically this should be the owner of the outermost template.
      // In shadow dom, this is always getRootNode().host, but we can
      // approximate this via cooperation with our dataHost always setting
      // `_methodHost` as long as there were bindings (or id's) on this
      // instance causing it to get a dataHost.
      return this.__dataHost._methodHost || this.__dataHost;
    }

    __sortChanged(sort) {
      var methodHost = this.__getMethodHost();
      this.__sortFn = sort && (typeof sort == 'function' ? sort :
        function() { return methodHost[sort].apply(methodHost, arguments); });
      this.__needFullRefresh = true;
      if (this.items) {
        this.__debounceRender(this.__render);
      }
    }

    __filterChanged(filter) {
      var methodHost = this.__getMethodHost();
      this.__filterFn = filter && (typeof filter == 'function' ? filter :
        function() { return methodHost[filter].apply(methodHost, arguments); });
      this.__needFullRefresh = true;
      if (this.items) {
        this.__debounceRender(this.__render);
      }
    }

    __computeFrameTime(rate) {
      return Math.ceil(1000/rate);
    }

    __initializeChunking() {
      if (this.initialCount) {
        this.__limit = this.initialCount;
        this.__chunkCount = this.initialCount;
        this.__lastChunkTime = performance.now();
      }
    }

    __tryRenderChunk() {
      // Debounced so that multiple calls through `_render` between animation
      // frames only queue one new rAF (e.g. array mutation & chunked render)
      if (this.items && this.__limit < this.items.length) {
        this.__debounceRender(this.__requestRenderChunk);
      }
    }

    __requestRenderChunk() {
      requestAnimationFrame(()=>this.__renderChunk());
    }

    __renderChunk() {
      // Simple auto chunkSize throttling algorithm based on feedback loop:
      // measure actual time between frames and scale chunk count by ratio
      // of target/actual frame time
      var currChunkTime = performance.now();
      var ratio = this._targetFrameTime / (currChunkTime - this.__lastChunkTime);
      this.__chunkCount = Math.round(this.__chunkCount * ratio) || 1;
      this.__limit += this.__chunkCount;
      this.__lastChunkTime = currChunkTime;
      this.__debounceRender(this.__render);
    }

    __observeChanged() {
      this.__observePaths = this.observe &&
        this.observe.replace('.*', '.').split(' ');
    }

    __itemsChanged(change) {
      if (this.items && !Array.isArray(this.items)) {
        console.warn('dom-repeat expected array for `items`, found', this.items);
      }
      // If path was to an item (e.g. 'items.3' or 'items.3.foo'), forward the
      // path to that instance synchronously (retuns false for non-item paths)
      if (!this.__handleItemPath(change.path, change.value)) {
        // Otherwise, the array was reset ('items') or spliced ('items.splices'),
        // so queue a full refresh
        this.__needFullRefresh = true;
        this.__initializeChunking();
        this.__debounceRender(this.__render);
      }
    }

    __handleObservedPaths(path) {
      if (this.__observePaths) {
        path = path.substring(path.indexOf('.') + 1);
        var paths = this.__observePaths;
        for (var i=0; i<paths.length; i++) {
          if (path.indexOf(paths[i]) === 0) {
            this.__needFullRefresh = true;
            this.__debounceRender(this.__render, this.delay);
            return true;
          }
        }
      }
    }

    /**
     * @param {function()} fn
     * @param {number=} delay
     */
    __debounceRender(fn, delay) {
      this.__renderDebouncer = Polymer.Debouncer.debounce(
            this.__renderDebouncer
          , delay > 0 ? Polymer.Async.timeOut.after(delay) : Polymer.Async.microTask
          , fn.bind(this));
      Polymer.enqueueDebouncer(this.__renderDebouncer);
    }

    /**
     * Forces the element to render its content. Normally rendering is
     * asynchronous to a provoking change. This is done for efficiency so
     * that multiple changes trigger only a single render. The render method
     * should be called if, for example, template rendering is required to
     * validate application state.
     */
    render() {
      // Queue this repeater, then flush all in order
      this.__needFullRefresh = true;
      this.__debounceRender(this.__render);
      Polymer.flush();
    }

    __render() {
      if (!this.__ensureTemplatized()) {
        // No template found yet
        return;
      }
      this.__applyFullRefresh();
      // Reset the pool
      // TODO(kschaaf): Reuse pool across turns and nested templates
      // Now that objects/arrays are re-evaluated when set, we can safely
      // reuse pooled instances across turns, however we still need to decide
      // semantics regarding how long to hold, how many to hold, etc.
      this.__pool.length = 0;
      // Set rendered item count
      this._setRenderedItemCount(this.__instances.length);
      // Notify users
      this.dispatchEvent(new CustomEvent('dom-change', {bubbles: true}));
      // Check to see if we need to render more items
      this.__tryRenderChunk();
    }

    __applyFullRefresh() {
      const items = this.items || [];
      let isntIdxToItemsIdx = new Array(items.length);
      for (let i=0; i<items.length; i++) {
        isntIdxToItemsIdx[i] = i;
      }
      // Apply user filter
      if (this.__filterFn) {
        isntIdxToItemsIdx = isntIdxToItemsIdx.filter((i, idx, array) =>
          this.__filterFn(items[i], idx, array));
      }
      // Apply user sort
      if (this.__sortFn) {
        isntIdxToItemsIdx.sort((a, b) => this.__sortFn(items[a], items[b]));
      }
      // items->inst map kept for item path forwarding
      const itemsIdxToInstIdx = this.__itemsIdxToInstIdx = {};
      let instIdx = 0;
      // Generate instances and assign items
      const limit = Math.min(isntIdxToItemsIdx.length, this.__limit);
      for (; instIdx<limit; instIdx++) {
        let inst = this.__instances[instIdx];
        let itemIdx = isntIdxToItemsIdx[instIdx];
        let item = items[itemIdx];
        itemsIdxToInstIdx[itemIdx] = instIdx;
        if (inst && instIdx < this.__limit) {
          inst._setPendingProperty(this.as, item);
          inst._setPendingProperty(this.indexAs, instIdx);
          inst._setPendingProperty(this.itemsIndexAs, itemIdx);
          inst._flushProperties();
        } else {
          this.__insertInstance(item, instIdx, itemIdx);
        }
      }
      // Remove any extra instances from previous state
      for (let i=this.__instances.length-1; i>=instIdx; i--) {
        this.__detachAndRemoveInstance(i);
      }
    }

    __detachInstance(idx) {
      var inst = this.__instances[idx];
      for (var i=0; i<inst.children.length; i++) {
        var el = inst.children[i];
        inst.root.appendChild(el);
      }
      return inst;
    }

    __attachInstance(idx, parent) {
      var inst = this.__instances[idx];
      parent.insertBefore(inst.root, this);
    }

    __detachAndRemoveInstance(idx) {
      var inst = this.__detachInstance(idx);
      if (inst) {
        this.__pool.push(inst);
      }
      this.__instances.splice(idx, 1);
    }

    __stampInstance(item, instIdx, itemIdx) {
      var model = {};
      model[this.as] = item;
      model[this.indexAs] = instIdx;
      model[this.itemsIndexAs] = itemIdx;
      return new this.__ctor(model);
    }

    __insertInstance(item, instIdx, itemIdx) {
      var inst = this.__pool.pop();
      if (inst) {
        // TODO(kschaaf): If the pool is shared across turns, hostProps
        // need to be re-set to reused instances in addition to item
        inst._setPendingProperty(this.as, item);
        inst._setPendingProperty(this.indexAs, instIdx);
        inst._setPendingProperty(this.itemsIndexAs, itemIdx);
        inst._flushProperties();
      } else {
        inst = this.__stampInstance(item, instIdx, itemIdx);
      }
      var beforeRow = this.__instances[instIdx + 1];
      var beforeNode = beforeRow ? beforeRow.children[0] : this;
      this.parentNode.insertBefore(inst.root, beforeNode);
      this.__instances[instIdx] = inst;
      return inst;
    }

    // Implements extension point from Templatize mixin
    _showHideChildren(hidden) {
      for (var i=0; i<this.__instances.length; i++) {
        this.__instances[i]._showHideChildren(hidden);
      }
    }

    // Called as a side effect of a host items.<key>.<path> path change,
    // responsible for notifying item.<path> changes to inst for key
    __handleItemPath(path, value) {
      var itemsPath = path.slice(6); // 'items.'.length == 6
      var dot = itemsPath.indexOf('.');
      var itemsIdx = dot < 0 ? itemsPath : itemsPath.substring(0, dot);
      // If path was index into array...
      if (itemsIdx == parseInt(itemsIdx, 10)) {
        var itemSubPath = dot < 0 ? '' : itemsPath.substring(dot+1);
        // See if the item subpath should trigger a full refresh...
        if (!this.__handleObservedPaths(itemSubPath)) {
          // If not, forward to the instance for that index
          var instIdx = this.__itemsIdxToInstIdx[itemsIdx];
          var inst = this.__instances[instIdx];
          if (inst) {
            let itemPath = this.as + (itemSubPath ? '.' + itemSubPath : '');
            // This is effectively `notifyPath`, but avoids some of the overhead
            // of the public API
            inst._setPendingPropertyOrPath(itemPath, value, false, true);
            inst._flushProperties();
          }
        }
        return true;
      }
    }

    /**
     * Returns the item associated with a given element stamped by
     * this `dom-repeat`.
     *
     * Note, to modify sub-properties of the item,
     * `modelForElement(el).set('item.<sub-prop>', value)`
     * should be used.
     *
     * @method itemForElement
     * @param {HTMLElement} el Element for which to return the item.
     * @return {*} Item associated with the element.
     */
    itemForElement(el) {
      var instance = this.modelForElement(el);
      return instance && instance[this.as];
    }

    /**
     * Returns the inst index for a given element stamped by this `dom-repeat`.
     * If `sort` is provided, the index will reflect the sorted order (rather
     * than the original array order).
     *
     * @method indexForElement
     * @param {HTMLElement} el Element for which to return the index.
     * @return {*} Row index associated with the element (note this may
     *   not correspond to the array index if a user `sort` is applied).
     */
    indexForElement(el) {
      var instance = this.modelForElement(el);
      return instance && instance[this.indexAs];
    }

    /**
     * Returns the template "model" associated with a given element, which
     * serves as the binding scope for the template instance the element is
     * contained in. A template model is an instance of `Polymer.Base`, and
     * should be used to manipulate data associated with this template instance.
     *
     * Example:
     *
     *   var model = modelForElement(el);
     *   if (model.index < 10) {
     *     model.set('item.checked', true);
     *   }
     *
     * @method modelForElement
     * @param {HTMLElement} el Element for which to return a template model.
     * @return {TemplateInstanceBase} Model representing the binding scope for
     *   the element.
     */
    modelForElement(el) {
      return Polymer.Templatize.modelForElement(this.template, el);
    }

  }

  customElements.define('dom-repeat', DomRepeat);

  Polymer.DomRepeat = DomRepeat;

})();

</script>
<script>

(function() {

  /**
   * Stamps the template iff the `if` property is truthy.
   *
   * When `if` becomes falsey, the stamped content is hidden but not
   * removed from dom. When `if` subsequently becomes truthy again, the content
   * is simply re-shown. This approach is used due to its favorable performance
   * characteristics: the expense of creating template content is paid only
   * once and lazily.
   *
   * Set the `restamp` property to true to force the stamped content to be
   * created / destroyed when the `if` condition changes.
   */
  class DomIf extends Polymer.Element {

    static get template() { return null; }

    static get config() {

      return {

        /**
         * Fired whenever DOM is added or removed/hidden by this template (by
         * default, rendering occurs lazily).  To force immediate rendering, call
         * `render`.
         *
         * @event dom-change
         */

        properties: {

          /**
           * A boolean indicating whether this template should stamp.
           */
          'if': {
            type: Boolean,
            observer: '__debounceRender'
          },

          /**
           * When true, elements will be removed from DOM and discarded when `if`
           * becomes false and re-created and added back to the DOM when `if`
           * becomes true.  By default, stamped elements will be hidden but left
           * in the DOM when `if` becomes false, which is generally results
           * in better performance.
           */
          restamp: {
            type: Boolean,
            observer: '__debounceRender'
          }

        }

      };

    }

    constructor() {
      super();
      this.__renderDebouncer = null;
      this.__invalidProps = null;
      this.__instance = null;
    }

    __debounceRender() {
      // Render is async for 2 reasons:
      // 1. To eliminate dom creation trashing if user code thrashes `if` in the
      //    same turn. This was more common in 1.x where a compound computed
      //    property could result in the result changing multiple times, but is
      //    mitigated to a large extent by batched property processing in 2.x.
      // 2. To avoid double object propagation when a bag including values bound
      //    to the `if` property as well as one or more hostProps could enqueue
      //    the <dom-if> to flush before the <template>'s host property
      //    forwarding. In that scenario creating an instance would result in
      //    the host props being set once, and then the enqueued changes on the
      //    template would set properties a second time, potentially causing an
      //    object to be set to an instance more than once.  Creating the
      //    instance async from flushing data ensures this doesn't happen. If
      //    we wanted a sync option in the future, simply having <dom-if> flush
      //    (or clear) its template's pending host properties before creating
      //    the instance would also avoid the problem.
      this.__renderDebouncer = Polymer.Debouncer.debounce(
            this.__renderDebouncer
          , Polymer.Async.microTask
          , () => this.__render());
      Polymer.enqueueDebouncer(this.__renderDebouncer);
    }

    disconnectedCallback() {
      super.disconnectedCallback();
      if (!this.parentNode ||
          (this.parentNode.nodeType == Node.DOCUMENT_FRAGMENT_NODE &&
           !this.parentNode.host)) {
        this.__teardownInstance();
      }
    }

    connectedCallback() {
      super.connectedCallback();
      if (this.if) {
        this.__debounceRender();
      }
    }

    /**
     * Forces the element to render its content. Normally rendering is
     * asynchronous to a provoking change. This is done for efficiency so
     * that multiple changes trigger only a single render. The render method
     * should be called if, for example, template rendering is required to
     * validate application state.
     */
    render() {
      Polymer.flush();
    }

    __render() {
      if (this.if) {
        if (!this.__ensureInstance()) {
          // No template found yet
          return;
        }
        this._showHideChildren();
      } else if (this.restamp) {
        this.__teardownInstance();
      }
      if (!this.restamp && this.__instance) {
        this._showHideChildren();
      }
      if (this.if != this._lastIf) {
        this.dispatchEvent(new CustomEvent('dom-change', {bubbles: true}));
        this._lastIf = this.if;
      }
    }

    __ensureInstance() {
      let parentNode = this.parentNode;
      // Guard against element being detached while render was queued
      if (parentNode) {
        if (!this.__ctor) {
          let template = this.querySelector('template');
          if (!template) {
            // Wait until childList changes and template should be there by then
            let observer = new MutationObserver(() => {
              if (this.querySelector('template')) {
                observer.disconnect();
                this.__render();
              } else {
                throw new Error('dom-if requires a <template> child');
              }
            })
            observer.observe(this, {childList: true});
            return false;
          }
          this.__ctor = Polymer.Templatize.templatize(template, this, {
            forwardHostProp: function(prop, value) {
              if (this.__instance) {
                if (this.if) {
                  this.__instance.forwardHostProp(prop, value);
                } else {
                  // If we have an instance but are squelching host property
                  // forwarding due to if being false, note the invalidated
                  // properties so `__syncHostProperties` can sync them the next
                  // time `if` becomes true
                  this.__invalidProps = this.__invalidProps || Object.create(null);
                  this.__invalidProps[Polymer.Path.root(prop)] = true;
                }
              }
            }
          });
        }
        if (!this.__instance) {
          this.__instance = new this.__ctor();
          parentNode.insertBefore(this.__instance.root, this);
        } else {
          this.__syncHostProperties();
          let c$ = this.__instance.children;
          if (c$ && c$.length) {
            // Detect case where dom-if was re-attached in new position
            let lastChild = this.previousSibling;
            if (lastChild !== c$[c$.length-1]) {
              for (let i=0, n; (i<c$.length) && (n=c$[i]); i++) {
                parentNode.insertBefore(n, this);
              }
            }
          }
        }
      }
      return true;
    }

    __syncHostProperties() {
      let props = this.__invalidProps;
      if (props) {
        for (let prop in props) {
          this.__instance._setPendingProperty(prop, this.__dataHost[prop]);
        }
        this.__invalidProps = null;
        this.__instance._flushProperties();
      }
    }

    __teardownInstance() {
      if (this.__instance) {
        let c$ = this.__instance.children;
        if (c$ && c$.length) {
          // use first child parent, for case when dom-if may have been detached
          let parent = c$[0].parentNode;
          for (let i=0, n; (i<c$.length) && (n=c$[i]); i++) {
            parent.removeChild(n);
          }
        }
        this.__instance = null;
        this.__invalidProps = null;
      }
    }

    _showHideChildren() {
      let hidden = this.__hideTemplateChildren__ || !this.if;
      if (this.__instance) {
        this.__instance._showHideChildren(hidden);
      }
    }

  }

  customElements.define('dom-if', DomIf);

  Polymer.DomIf = DomIf;

})();
</script>
<script>
(function() {

  let ArraySelectorMixin = Polymer.dedupingMixin(superClass => {

    return class extends superClass {

      static get config() {

        return {

          properties: {

            /**
             * An array containing items from which selection will be made.
             */
            items: {
              type: Array,
            },

            /**
             * When `true`, multiple items may be selected at once (in this case,
             * `selected` is an array of currently selected items).  When `false`,
             * only one item may be selected at a time.
             */
            multi: {
              type: Boolean,
              value: false,
            },

            /**
             * When `multi` is true, this is an array that contains any selected.
             * When `multi` is false, this is the currently selected item, or `null`
             * if no item is selected.
             */
            selected: {
              type: Object,
              notify: true
            },

            /**
             * When `multi` is false, this is the currently selected item, or `null`
             * if no item is selected.
             */
            selectedItem: {
              type: Object,
              notify: true
            },

            /**
             * When `true`, calling `select` on an item that is already selected
             * will deselect the item.
             */
            toggle: {
              type: Boolean,
              value: false
            }

          },

          observers: ['__updateSelection(multi, items.*)'],

        }

      }

      constructor() {
        super();
        this.__lastItems = null;
        this.__lastMulti = null;
        this.__selectedMap = null;
      }

      __updateSelection(multi, itemsInfo) {
        let path = itemsInfo.path;
        if (path == 'items') {
          // Case 1 - items array changed, so diff against previous array and
          // deselect any removed items and adjust selected indices
          let newItems = itemsInfo.base || [];
          let lastItems = this.__lastItems;
          let lastMulti = this.__lastMulti;
          if (multi !== lastMulti) {
            this.clearSelection();
          }
          if (lastItems) {
            let splices = Polymer.ArraySplice.calculateSplices(newItems, lastItems);
            this.__applySplices(splices);
          }
          this.__lastItems = newItems;
          this.__lastMulti = multi;
        } else if (itemsInfo.path == 'items.splices') {
          // Case 2 - got specific splice information describing the array mutation:
          // deselect any removed items and adjust selected indices
          this.__applySplices(itemsInfo.value.indexSplices);
        } else {
          // Case 3 - an array element was changed, so deselect the previous
          // item for that index if it was previously selected
          let part = path.slice('items.'.length);
          let idx = parseInt(part, 10);
          if ((part.indexOf('.') < 0) && part == idx) {
            this.__deselectChangedIdx(idx);
          }
        }
      }

      __applySplices(splices) {
        let selected = this.__selectedMap;
        // Adjust selected indices and mark removals
        for (let i=0; i<splices.length; i++) {
          let s = splices[i];
          selected.forEach((idx, item) => {
            if (idx < s.index) {
              // no change
            } else if (idx >= s.index + s.removed.length) {
              // adjust index
              selected.set(item, idx + s.addedCount - s.removed.length);
            } else {
              // remove index
              selected.set(item, -1);
            }
          });
          for (let j=0; j<s.addedCount; j++) {
            let idx = s.index + j;
            if (selected.has(this.items[idx])) {
              selected.set(this.items[idx], idx);
            }
          }
        }
        // Update linked paths
        this.__updateLinks();
        // Remove selected items that were removed from the items array
        let sidx = 0;
        selected.forEach((idx, item) => {
          if (idx < 0) {
            if (this.multi) {
              this.splice('selected', sidx, 1);
            } else {
              this.selected = this.selectedItem = null;
            }
            selected.delete(item);
          } else {
            sidx++;
          }
        });
      }

      __updateLinks() {
        this.__dataLinkedPaths = {};
        if (this.multi) {
          let sidx = 0;
          this.__selectedMap.forEach(idx => {
            if (idx >= 0) {
              this.linkPaths('items.' + idx, 'selected.' + sidx++);
            }
          });
        } else {
          this.__selectedMap.forEach(idx => {
            this.linkPaths('selected', 'items.' + idx);
            this.linkPaths('selectedItem', 'items.' + idx);
          });
        }
      }

      /**
       * Clears the selection state.
       *
       * @method clearSelection
       */
      clearSelection() {
        // Unbind previous selection
        this.__dataLinkedPaths = {};
        // The selected map stores 3 pieces of information:
        // key: items array object
        // value: items array index
        // order: selected array index
        this.__selectedMap = new Map();
        // Initialize selection
        this.selected = this.multi ? [] : null
        this.selectedItem = null;
      }

      /**
       * Returns whether the item is currently selected.
       *
       * @method isSelected
       * @param {*} item Item from `items` array to test
       * @return {boolean} Whether the item is selected
       */
      isSelected(item) {
        return this.__selectedMap.has(item);
      }

      /**
       * Returns whether the item is currently selected.
       *
       * @method isSelected
       * @param {*} idx Index from `items` array to test
       * @return {boolean} Whether the item is selected
       */
      isIndexSelected(idx) {
        return this.isSelected(this.items[idx]);
      }

      __deselectChangedIdx(idx) {
        let sidx = this.__selectedIndexForItemIndex(idx);
        if (sidx >= 0) {
          let i = 0;
          this.__selectedMap.forEach((idx, item) => {
            if (sidx == i++) {
              this.deselect(item);
            }
          });
        }
      }

      __selectedIndexForItemIndex(idx) {
        let selected = this.__dataLinkedPaths['items.' + idx];
        if (selected) {
          return parseInt(selected.slice('selected.'.length), 10);
        }
      }

      /**
       * Deselects the given item if it is already selected.
       *
       * @method deselect
       * @param {*} item Item from `items` array to deselect
       */
      deselect(item) {
        let idx = this.__selectedMap.get(item);
        if (idx >= 0) {
          this.__selectedMap.delete(item);
          let sidx;
          if (this.multi) {
            sidx = this.__selectedIndexForItemIndex(idx);
          }
          this.__updateLinks();
          if (this.multi) {
            this.splice('selected', sidx, 1);
          } else {
            this.selected = this.selectedItem = null;
          }
        }
      }

      /**
       * Deselects the given index if it is already selected.
       *
       * @method deselect
       * @param {number} idx Index from `items` array to deselect
       */
      deselectIndex(idx) {
        this.deselect(this.items[idx]);
      }

      /**
       * Selects the given item.  When `toggle` is true, this will automatically
       * deselect the item if already selected.
       *
       * @method select
       * @param {*} item Item from `items` array to select
       */
      select(item) {
        this.selectIndex(this.items.indexOf(item));
      }

      /**
       * Selects the given index.  When `toggle` is true, this will automatically
       * deselect the item if already selected.
       *
       * @method select
       * @param {number} idx Index from `items` array to select
       */
      selectIndex(idx) {
        let item = this.items[idx];
        if (!this.isSelected(item)) {
          if (!this.multi) {
            this.__selectedMap.clear();
          }
          this.__selectedMap.set(item, idx);
          this.__updateLinks();
          if (this.multi) {
            this.push('selected', item);
          } else {
            this.selected = this.selectedItem = item;
          }
        } else if (this.toggle) {
          this.deselectIndex(idx);
        }
      }

    }

  });

  // export mixin
  Polymer.ArraySelectorMixin = ArraySelectorMixin;

  // define element class & export
  const ArraySelector = ArraySelectorMixin(Polymer.Element);
  customElements.define('array-selector', ArraySelector);
  Polymer.ArraySelector = ArraySelector;

})();

</script>
<script>(function(){
/*

Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
*/
'use strict';var c=!(window.ShadyDOM&&window.ShadyDOM.inUse),f=!navigator.userAgent.match("AppleWebKit/601")&&window.CSS&&CSS.supports&&CSS.supports("box-shadow","0 0 0 var(--foo)");function g(a){a&&(f=f&&!a.nativeCss&&!a.shimcssproperties,c=c&&!a.nativeShadow&&!a.shimshadow)}window.ShadyCSS?g(window.ShadyCSS):window.WebComponents&&g(window.WebComponents.flags);var h=c,k=f;function l(a,b){for(var d in b)null===d?a.style.removeProperty(d):a.style.setProperty(d,b[d])};var m=null,n=window.HTMLImports&&window.HTMLImports.whenReady||null,r;function t(){var a=u;n?n(a):(m||(m=new Promise(function(a){r=a}),"complete"===document.readyState?r():document.addEventListener("readystatechange",function(){"complete"===document.readyState&&r()})),m.then(function(){a&&a()}))};var v=null,u=null;function x(){this.customStyles=[];this.enqueued=!1}function y(a){!a.enqueued&&u&&(a.enqueued=!0,t())}x.prototype.c=function(a){a.__seenByShadyCSS||(a.__seenByShadyCSS=!0,this.customStyles.push(a),y(this))};x.prototype.b=function(a){if(a.__shadyCSSCachedStyle)return a.__shadyCSSCachedStyle;var b;a.getStyle?b=a.getStyle():b=a;return b};
x.prototype.a=function(){for(var a=this.customStyles,b=0;b<a.length;b++){var d=a[b];if(!d.__shadyCSSCachedStyle){var e=this.b(d);if(e){var p=e.__appliedElement;if(p)for(var q=0;q<e.attributes.length;q++){var w=e.attributes[q];p.setAttribute(w.name,w.value)}e=p||e;v&&v(e);d.__shadyCSSCachedStyle=e}}}return a};x.prototype.addCustomStyle=x.prototype.c;x.prototype.getStyleForCustomStyle=x.prototype.b;x.prototype.processStyles=x.prototype.a;
Object.defineProperties(x.prototype,{transformCallback:{get:function(){return v},set:function(a){v=a}},validateCallback:{get:function(){return u},set:function(a){var b=!1;u||(b=!0);u=a;b&&y(this)}}});var z=new x;window.ShadyCSS||(window.ShadyCSS={prepareTemplate:function(){},styleSubtree:function(a,b){z.a();l(a,b)},styleElement:function(){z.a()},styleDocument:function(a){z.a();l(document.body,a)},getComputedStyleValue:function(a,b){return(a=window.getComputedStyle(a).getPropertyValue(b))?a.trim():""},nativeCss:k,nativeShadow:h});window.ShadyCSS.CustomStyleInterface=z;
}).call(self)

//# sourceMappingURL=custom-style-interface.min.js.map
</script>
<script>
(function() {
  'use strict';

  const attr = 'include';

  const CustomStyleInterface = window.ShadyCSS.CustomStyleInterface;

  class CustomStyle extends HTMLElement {
    constructor() {
      super();
      this._style = null;
      CustomStyleInterface.addCustomStyle(this);
    }
    getStyle() {
      if (this._style) {
        return this._style;
      }
      const style = this.querySelector('style');
      if (!style) {
        return;
      }
      this._style = style;
      const include = style.getAttribute(attr);
      if (include) {
        style.removeAttribute(attr);
        style.textContent = Polymer.StyleGather.cssFromModules(include) + style.textContent;
      }
      return this._style;
    }
  }

  window.CustomStyle = CustomStyle;
  window.customElements.define('custom-style', CustomStyle);
})();
</script>
<script>
  Polymer.LegacyElement = Polymer.LegacyElementMixin(HTMLElement);
  // bc
  Polymer.Base = Polymer.LegacyElement.prototype;
</script>

<script>
(function () {
  var _bindingRegex_patch = {
    // Issue with https://github.com/Polymer/polymer/issues/3349 
    _bindingRegex_1_2_4: (function() {
      var IDENT  = '(?:' + '[a-zA-Z_$][\\w.:$-*]*' + ')';
      var NUMBER = '(?:' + '[-+]?[0-9]*\\.?[0-9]+(?:[eE][-+]?[0-9]+)?' + ')';
      var SQUOTE_STRING = '(?:' + '\'(?:[^\'\\\\]|\\\\.)*\'' + ')';
      var DQUOTE_STRING = '(?:' + '"(?:[^"\\\\]|\\\\.)*"' + ')';
      var STRING = '(?:' + SQUOTE_STRING + '|' + DQUOTE_STRING + ')';
      var ARGUMENT = '(?:' + IDENT + '|' + NUMBER + '|' +  STRING + '\\s*' + ')';
      var ARGUMENTS = '(?:' + ARGUMENT + '(?:,\\s*' + ARGUMENT + ')*' + ')';
      var ARGUMENT_LIST = '(?:' + '\\(\\s*' +
                                    '(?:' + ARGUMENTS + '?' + ')' +
                                  '\\)\\s*' + ')';
      var BINDING = '(' + IDENT + '\\s*' + ARGUMENT_LIST + '?' + ')'; // Group 3
      var OPEN_BRACKET = '(\\[\\[|{{)' + '\\s*';
      var CLOSE_BRACKET = '(?:]]|}})';
      var NEGATE = '(?:(!)\\s*)?'; // Group 2
      var EXPRESSION = OPEN_BRACKET + NEGATE + BINDING + CLOSE_BRACKET;
      return new RegExp(EXPRESSION, "g");
    })(),

    // Fix from https://github.com/TimvdLippe/polymer/blob/fix-binding-with-dash/src/lib/annotations/annotations.html
    _bindingRegex_1_2_4_patched: (function() {
      var IDENT  = '(?:' + '[a-zA-Z_\\$][\\w\\.:\\$\\-\\*]*' + ')';
      var NUMBER = '(?:' + '[-+]?[0-9]*\\.?[0-9]+(?:[eE][-+]?[0-9]+)?' + ')';
      var SQUOTE_STRING = '(?:' + '\'(?:[^\'\\\\]|\\\\.)*\'' + ')';
      var DQUOTE_STRING = '(?:' + '"(?:[^"\\\\]|\\\\.)*"' + ')';
      var STRING = '(?:' + SQUOTE_STRING + '|' + DQUOTE_STRING + ')';
      var ARGUMENT = '(?:' + IDENT + '|' + NUMBER + '|' +  STRING + '\\s*' + ')';
      var ARGUMENTS = '(?:' + ARGUMENT + '(?:,\\s*' + ARGUMENT + ')*' + ')';
      var ARGUMENT_LIST = '(?:' + '\\(\\s*' +
                                    '(?:' + ARGUMENTS + '?' + ')' +
                                  '\\)\\s*' + ')';
      var BINDING = '(' + IDENT + '\\s*' + ARGUMENT_LIST + '?' + ')'; // Group 3
      var OPEN_BRACKET = '(\\[\\[|{{)' + '\\s*';
      var CLOSE_BRACKET = '(?:]]|}})';
      var NEGATE = '(?:(!)\\s*)?'; // Group 2
      var EXPRESSION = OPEN_BRACKET + NEGATE + BINDING + CLOSE_BRACKET;
      return new RegExp(EXPRESSION, "g");
    })()
  };
    
  if (!Polymer.ElementMixin && Polymer.Annotations._bindingRegex.toString() === 
      _bindingRegex_patch._bindingRegex_1_2_4.toString()) {
    console.log('Fixing Polymer issue#3349 by patching Polymer.Annotations._bindingRegex for Polymer 1.2.4');
    Polymer.Annotations._bindingRegex = _bindingRegex_patch._bindingRegex_1_2_4_patched;
  }
})();
</script>
<script>
  'use strict';

  Polymer({
    is: 'iron-request',

    hostAttributes: {
      hidden: true
    },

    properties: {

      /**
       * A reference to the XMLHttpRequest instance used to generate the
       * network request.
       *
       * @type {XMLHttpRequest}
       */
      xhr: {
        type: Object,
        notify: true,
        readOnly: true,
        value: function() {
          return new XMLHttpRequest();
        }
      },

      /**
       * A reference to the parsed response body, if the `xhr` has completely
       * resolved.
       *
       * @type {*}
       * @default null
       */
      response: {
        type: Object,
        notify: true,
        readOnly: true,
        value: function() {
          return null;
        }
      },

      /**
       * A reference to the status code, if the `xhr` has completely resolved.
       */
      status: {
        type: Number,
        notify: true,
        readOnly: true,
        value: 0
      },

      /**
       * A reference to the status text, if the `xhr` has completely resolved.
       */
      statusText: {
        type: String,
        notify: true,
        readOnly: true,
        value: ''
      },

      /**
       * A promise that resolves when the `xhr` response comes back, or rejects
       * if there is an error before the `xhr` completes.
       *
       * @type {Promise}
       */
      completes: {
        type: Object,
        readOnly: true,
        notify: true,
        value: function() {
          return new Promise(function (resolve, reject) {
            this.resolveCompletes = resolve;
            this.rejectCompletes = reject;
          }.bind(this));
        }
      },

      /**
       * An object that contains progress information emitted by the XHR if
       * available.
       *
       * @default {}
       */
      progress: {
        type: Object,
        notify: true,
        readOnly: true,
        value: function() {
          return {};
        }
      },

      /**
       * Aborted will be true if an abort of the request is attempted.
       */
      aborted: {
        type: Boolean,
        notify: true,
        readOnly: true,
        value: false,
      },

      /**
       * Errored will be true if the browser fired an error event from the
       * XHR object (mainly network errors).
       */
      errored: {
        type: Boolean,
        notify: true,
        readOnly: true,
        value: false
      },

      /**
       * TimedOut will be true if the XHR threw a timeout event.
       */
      timedOut: {
        type: Boolean,
        notify: true,
        readOnly: true,
        value: false
      }
    },

    /**
     * Succeeded is true if the request succeeded. The request succeeded if it
     * loaded without error, wasn't aborted, and the status code is ≥ 200, and
     * < 300, or if the status code is 0.
     *
     * The status code 0 is accepted as a success because some schemes - e.g.
     * file:// - don't provide status codes.
     *
     * @return {boolean}
     */
    get succeeded() {
      if (this.errored || this.aborted || this.timedOut) {
        return false;
      }
      var status = this.xhr.status || 0;

      // Note: if we are using the file:// protocol, the status code will be 0
      // for all outcomes (successful or otherwise).
      return status === 0 ||
        (status >= 200 && status < 300);
    },

    /**
     * Sends an HTTP request to the server and returns the XHR object.
     *
     * The handling of the `body` parameter will vary based on the Content-Type
     * header. See the docs for iron-ajax's `body` param for details.
     *
     * @param {{
     *   url: string,
     *   method: (string|undefined),
     *   async: (boolean|undefined),
     *   body: (ArrayBuffer|ArrayBufferView|Blob|Document|FormData|null|string|undefined|Object),
     *   headers: (Object|undefined),
     *   handleAs: (string|undefined),
     *   jsonPrefix: (string|undefined),
     *   withCredentials: (boolean|undefined)}} options -
     *     url The url to which the request is sent.
     *     method The HTTP method to use, default is GET.
     *     async By default, all requests are sent asynchronously. To send synchronous requests,
     *         set to false.
     *     body The content for the request body for POST method.
     *     headers HTTP request headers.
     *     handleAs The response type. Default is 'text'.
     *     withCredentials Whether or not to send credentials on the request. Default is false.
     *   timeout: (Number|undefined)
     * @return {Promise}
     */
    send: function (options) {
      var xhr = this.xhr;

      if (xhr.readyState > 0) {
        return null;
      }

      xhr.addEventListener('progress', function (progress) {
        this._setProgress({
          lengthComputable: progress.lengthComputable,
          loaded: progress.loaded,
          total: progress.total
        });
      }.bind(this))

      xhr.addEventListener('error', function (error) {
        this._setErrored(true);
        this._updateStatus();
        this.rejectCompletes(error);
      }.bind(this));

      xhr.addEventListener('timeout', function (error) {
        this._setTimedOut(true);
        this._updateStatus();
        this.rejectCompletes(error);
      }.bind(this));

      xhr.addEventListener('abort', function () {
        this._updateStatus();
        this.rejectCompletes(new Error('Request aborted.'));
      }.bind(this));

      // Called after all of the above.
      xhr.addEventListener('loadend', function () {
        this._updateStatus();
        this._setResponse(this.parseResponse());

        if (!this.succeeded) {
          this.rejectCompletes(new Error('The request failed with status code: ' + this.xhr.status));
          return;
        }

        this.resolveCompletes(this);
      }.bind(this));

      this.url = options.url;
      xhr.open(
        options.method || 'GET',
        options.url,
        options.async !== false
      );

      var acceptType = {
        'json': 'application/json',
        'text': 'text/plain',
        'html': 'text/html',
        'xml': 'application/xml',
        'arraybuffer': 'application/octet-stream'
      }[options.handleAs];
      var headers = options.headers || Object.create(null);
      var newHeaders = Object.create(null);
      for (var key in headers) {
        newHeaders[key.toLowerCase()] = headers[key];
      }
      headers = newHeaders;

      if (acceptType && !headers['accept']) {
        headers['accept'] = acceptType;
      }
      Object.keys(headers).forEach(function (requestHeader) {
        if (/[A-Z]/.test(requestHeader)) {
          Polymer.Base._error('Headers must be lower case, got', requestHeader);
        }
        xhr.setRequestHeader(
          requestHeader,
          headers[requestHeader]
        );
      }, this);

      if (options.async !== false) {
        if (options.async) {
          xhr.timeout = options.timeout;
        }

        var handleAs = options.handleAs;

        // If a JSON prefix is present, the responseType must be 'text' or the
        // browser won’t be able to parse the response.
        if (!!options.jsonPrefix || !handleAs) {
          handleAs = 'text';
        }

        // In IE, `xhr.responseType` is an empty string when the response
        // returns. Hence, caching it as `xhr._responseType`.
        xhr.responseType = xhr._responseType = handleAs;

        // Cache the JSON prefix, if it exists.
        if (!!options.jsonPrefix) {
          xhr._jsonPrefix = options.jsonPrefix;
        }
      }

      xhr.withCredentials = !!options.withCredentials;


      var body = this._encodeBodyObject(options.body, headers['content-type']);

      xhr.send(
        /** @type {ArrayBuffer|ArrayBufferView|Blob|Document|FormData|
                   null|string|undefined} */
        (body));

      return this.completes;
    },

    /**
     * Attempts to parse the response body of the XHR. If parsing succeeds,
     * the value returned will be deserialized based on the `responseType`
     * set on the XHR.
     *
     * @return {*} The parsed response,
     * or undefined if there was an empty response or parsing failed.
     */
    parseResponse: function () {
      var xhr = this.xhr;
      var responseType = xhr.responseType || xhr._responseType;
      var preferResponseText = !this.xhr.responseType;
      var prefixLen = (xhr._jsonPrefix && xhr._jsonPrefix.length) || 0;

      try {
        switch (responseType) {
          case 'json':
            // If the xhr object doesn't have a natural `xhr.responseType`,
            // we can assume that the browser hasn't parsed the response for us,
            // and so parsing is our responsibility. Likewise if response is
            // undefined, as there's no way to encode undefined in JSON.
            if (preferResponseText || xhr.response === undefined) {
              // Try to emulate the JSON section of the response body section of
              // the spec: https://xhr.spec.whatwg.org/#response-body
              // That is to say, we try to parse as JSON, but if anything goes
              // wrong return null.
              try {
                return JSON.parse(xhr.responseText);
              } catch (_) {
                return null;
              }
            }

            return xhr.response;
          case 'xml':
            return xhr.responseXML;
          case 'blob':
          case 'document':
          case 'arraybuffer':
            return xhr.response;
          case 'text':
          default: {
            // If `prefixLen` is set, it implies the response should be parsed
            // as JSON once the prefix of length `prefixLen` is stripped from
            // it. Emulate the behavior above where null is returned on failure
            // to parse.
            if (prefixLen) {
              try {
                return JSON.parse(xhr.responseText.substring(prefixLen));
              } catch (_) {
                return null;
              }
            }
            return xhr.responseText;
          }
        }
      } catch (e) {
        this.rejectCompletes(new Error('Could not parse response. ' + e.message));
      }
    },

    /**
     * Aborts the request.
     */
    abort: function () {
      this._setAborted(true);
      this.xhr.abort();
    },

    /**
     * @param {*} body The given body of the request to try and encode.
     * @param {?string} contentType The given content type, to infer an encoding
     *     from.
     * @return {*} Either the encoded body as a string, if successful,
     *     or the unaltered body object if no encoding could be inferred.
     */
    _encodeBodyObject: function(body, contentType) {
      if (typeof body == 'string') {
        return body;  // Already encoded.
      }
      var bodyObj = /** @type {Object} */ (body);
      switch(contentType) {
        case('application/json'):
          return JSON.stringify(bodyObj);
        case('application/x-www-form-urlencoded'):
          return this._wwwFormUrlEncode(bodyObj);
      }
      return body;
    },

    /**
     * @param {Object} object The object to encode as x-www-form-urlencoded.
     * @return {string} .
     */
    _wwwFormUrlEncode: function(object) {
      if (!object) {
        return '';
      }
      var pieces = [];
      Object.keys(object).forEach(function(key) {
        // TODO(rictic): handle array values here, in a consistent way with
        //   iron-ajax params.
        pieces.push(
            this._wwwFormUrlEncodePiece(key) + '=' +
            this._wwwFormUrlEncodePiece(object[key]));
      }, this);
      return pieces.join('&');
    },

    /**
     * @param {*} str A key or value to encode as x-www-form-urlencoded.
     * @return {string} .
     */
    _wwwFormUrlEncodePiece: function(str) {
      // Spec says to normalize newlines to \r\n and replace %20 spaces with +.
      // jQuery does this as well, so this is likely to be widely compatible.
      if (str === null) {
        return '';
      }
      return encodeURIComponent(str.toString().replace(/\r?\n/g, '\r\n'))
          .replace(/%20/g, '+');
    },

    /**
     * Updates the status code and status text.
     */
    _updateStatus: function() {
      this._setStatus(this.xhr.status);
      this._setStatusText((this.xhr.statusText === undefined) ? '' : this.xhr.statusText);
    }
  });
</script>
<script>
  'use strict';

  Polymer({

    is: 'iron-ajax',

    /**
     * Fired when a request is sent.
     *
     * @event request
     * @event iron-ajax-request
     */

    /**
     * Fired when a response is received.
     *
     * @event response
     * @event iron-ajax-response
     */

    /**
     * Fired when an error is received.
     *
     * @event error
     * @event iron-ajax-error
     */

    hostAttributes: {
      hidden: true
    },

    properties: {
      /**
       * The URL target of the request.
       */
      url: {
        type: String
      },

      /**
       * An object that contains query parameters to be appended to the
       * specified `url` when generating a request. If you wish to set the body
       * content when making a POST request, you should use the `body` property
       * instead.
       */
      params: {
        type: Object,
        value: function() {
          return {};
        }
      },

      /**
       * The HTTP method to use such as 'GET', 'POST', 'PUT', or 'DELETE'.
       * Default is 'GET'.
       */
      method: {
        type: String,
        value: 'GET'
      },

      /**
       * HTTP request headers to send.
       *
       * Example:
       *
       *     <iron-ajax
       *         auto
       *         url="http://somesite.com"
       *         headers='{"X-Requested-With": "XMLHttpRequest"}'
       *         handle-as="json"></iron-ajax>
       *
       * Note: setting a `Content-Type` header here will override the value
       * specified by the `contentType` property of this element.
       */
      headers: {
        type: Object,
        value: function() {
          return {};
        }
      },

      /**
       * Content type to use when sending data. If the `contentType` property
       * is set and a `Content-Type` header is specified in the `headers`
       * property, the `headers` property value will take precedence.
       *
       * Varies the handling of the `body` param.
       */
      contentType: {
        type: String,
        value: null
      },

      /**
       * Body content to send with the request, typically used with "POST"
       * requests.
       *
       * If body is a string it will be sent unmodified.
       *
       * If Content-Type is set to a value listed below, then
       * the body will be encoded accordingly.
       *
       *    * `content-type="application/json"`
       *      * body is encoded like `{"foo":"bar baz","x":1}`
       *    * `content-type="application/x-www-form-urlencoded"`
       *      * body is encoded like `foo=bar+baz&x=1`
       *
       * Otherwise the body will be passed to the browser unmodified, and it
       * will handle any encoding (e.g. for FormData, Blob, ArrayBuffer).
       *
       * @type (ArrayBuffer|ArrayBufferView|Blob|Document|FormData|null|string|undefined|Object)
       */
      body: {
        type: Object,
        value: null
      },

      /**
       * Toggle whether XHR is synchronous or asynchronous. Don't change this
       * to true unless You Know What You Are Doing™.
       */
      sync: {
        type: Boolean,
        value: false
      },

      /**
       * Specifies what data to store in the `response` property, and
       * to deliver as `event.detail.response` in `response` events.
       *
       * One of:
       *
       *    `text`: uses `XHR.responseText`.
       *
       *    `xml`: uses `XHR.responseXML`.
       *
       *    `json`: uses `XHR.responseText` parsed as JSON.
       *
       *    `arraybuffer`: uses `XHR.response`.
       *
       *    `blob`: uses `XHR.response`.
       *
       *    `document`: uses `XHR.response`.
       */
      handleAs: {
        type: String,
        value: 'json'
      },

      /**
       * Set the withCredentials flag on the request.
       */
      withCredentials: {
        type: Boolean,
        value: false
      },

      /**
       * Set the timeout flag on the request.
       */
      timeout: {
        type: Number,
        value: 0
      },

      /**
       * If true, automatically performs an Ajax request when either `url` or
       * `params` changes.
       */
      auto: {
        type: Boolean,
        value: false
      },

      /**
       * If true, error messages will automatically be logged to the console.
       */
      verbose: {
        type: Boolean,
        value: false
      },

      /**
       * The most recent request made by this iron-ajax element.
       */
      lastRequest: {
        type: Object,
        notify: true,
        readOnly: true
      },

      /**
       * True while lastRequest is in flight.
       */
      loading: {
        type: Boolean,
        notify: true,
        readOnly: true
      },

      /**
       * lastRequest's response.
       *
       * Note that lastResponse and lastError are set when lastRequest finishes,
       * so if loading is true, then lastResponse and lastError will correspond
       * to the result of the previous request.
       *
       * The type of the response is determined by the value of `handleAs` at
       * the time that the request was generated.
       *
       * @type {Object}
       */
      lastResponse: {
        type: Object,
        notify: true,
        readOnly: true
      },

      /**
       * lastRequest's error, if any.
       *
       * @type {Object}
       */
      lastError: {
        type: Object,
        notify: true,
        readOnly: true
      },

      /**
       * An Array of all in-flight requests originating from this iron-ajax
       * element.
       */
      activeRequests: {
        type: Array,
        notify: true,
        readOnly: true,
        value: function() {
          return [];
        }
      },

      /**
       * Length of time in milliseconds to debounce multiple automatically generated requests.
       */
      debounceDuration: {
        type: Number,
        value: 0,
        notify: true
      },

      /**
       * Prefix to be stripped from a JSON response before parsing it.
       *
       * In order to prevent an attack using CSRF with Array responses
       * (http://haacked.com/archive/2008/11/20/anatomy-of-a-subtle-json-vulnerability.aspx/)
       * many backends will mitigate this by prefixing all JSON response bodies
       * with a string that would be nonsensical to a JavaScript parser.
       *
       */
      jsonPrefix: {
        type: String,
        value: ''
      },

      /**
       * By default, iron-ajax's events do not bubble. Setting this attribute will cause its
       * request and response events as well as its iron-ajax-request, -response,  and -error
       * events to bubble to the window object. The vanilla error event never bubbles when
       * using shadow dom even if this.bubbles is true because a scoped flag is not passed with
       * it (first link) and because the shadow dom spec did not used to allow certain events,
       * including events named error, to leak outside of shadow trees (second link).
       * https://www.w3.org/TR/shadow-dom/#scoped-flag
       * https://www.w3.org/TR/2015/WD-shadow-dom-20151215/#events-that-are-not-leaked-into-ancestor-trees
       */
      bubbles: {
        type: Boolean,
        value: false
      },

      _boundHandleResponse: {
        type: Function,
        value: function() {
          return this._handleResponse.bind(this);
        }
      }
    },

    observers: [
      '_requestOptionsChanged(url, method, params.*, headers, contentType, ' +
          'body, sync, handleAs, jsonPrefix, withCredentials, timeout, auto)'
    ],

    /**
     * The query string that should be appended to the `url`, serialized from
     * the current value of `params`.
     *
     * @return {string}
     */
    get queryString () {
      var queryParts = [];
      var param;
      var value;

      for (param in this.params) {
        value = this.params[param];
        param = window.encodeURIComponent(param);

        if (Array.isArray(value)) {
          for (var i = 0; i < value.length; i++) {
            queryParts.push(param + '=' + window.encodeURIComponent(value[i]));
          }
        } else if (value !== null) {
          queryParts.push(param + '=' + window.encodeURIComponent(value));
        } else {
          queryParts.push(param);
        }
      }

      return queryParts.join('&');
    },

    /**
     * The `url` with query string (if `params` are specified), suitable for
     * providing to an `iron-request` instance.
     *
     * @return {string}
     */
    get requestUrl() {
      var queryString = this.queryString;
      var url = this.url || '';

      if (queryString) {
        var bindingChar = url.indexOf('?') >= 0 ? '&' : '?';
        return url + bindingChar + queryString;
      }

      return url;
    },

    /**
     * An object that maps header names to header values, first applying the
     * the value of `Content-Type` and then overlaying the headers specified
     * in the `headers` property.
     *
     * @return {Object}
     */
    get requestHeaders() {
      var headers = {};
      var contentType = this.contentType;
      if (contentType == null && (typeof this.body === 'string')) {
        contentType = 'application/x-www-form-urlencoded';
      }
      if (contentType) {
        headers['content-type'] = contentType;
      }
      var header;

      if (this.headers instanceof Object) {
        for (header in this.headers) {
          headers[header] = this.headers[header].toString();
        }
      }

      return headers;
    },

    /**
     * Request options suitable for generating an `iron-request` instance based
     * on the current state of the `iron-ajax` instance's properties.
     *
     * @return {{
     *   url: string,
     *   method: (string|undefined),
     *   async: (boolean|undefined),
     *   body: (ArrayBuffer|ArrayBufferView|Blob|Document|FormData|null|string|undefined|Object),
     *   headers: (Object|undefined),
     *   handleAs: (string|undefined),
     *   jsonPrefix: (string|undefined),
     *   withCredentials: (boolean|undefined)}}
     */
    toRequestOptions: function() {
      return {
        url: this.requestUrl || '',
        method: this.method,
        headers: this.requestHeaders,
        body: this.body,
        async: !this.sync,
        handleAs: this.handleAs,
        jsonPrefix: this.jsonPrefix,
        withCredentials: this.withCredentials,
        timeout: this.timeout
      };
    },

    /**
     * Performs an AJAX request to the specified URL.
     *
     * @return {!IronRequestElement}
     */
    generateRequest: function() {
      var request = /** @type {!IronRequestElement} */ (document.createElement('iron-request'));
      var requestOptions = this.toRequestOptions();

      this.push('activeRequests', request);

      request.completes.then(
        this._boundHandleResponse
      ).catch(
        this._handleError.bind(this, request)
      ).then(
        this._discardRequest.bind(this, request)
      );

      request.send(requestOptions);

      this._setLastRequest(request);
      this._setLoading(true);

      this.fire('request', {
        request: request,
        options: requestOptions
      }, {
        bubbles: this.bubbles,
        composed: true
      });

      this.fire('iron-ajax-request', {
        request: request,
        options: requestOptions
      }, {
        bubbles: this.bubbles,
        composed: true
      });

      return request;
    },

    _handleResponse: function(request) {
      if (request === this.lastRequest) {
        this._setLastResponse(request.response);
        this._setLastError(null);
        this._setLoading(false);
      }
      this.fire('response', request, {
        bubbles: this.bubbles,
        composed: true
      });
      this.fire('iron-ajax-response', request, {
        bubbles: this.bubbles,
        composed: true
      });
    },

    _handleError: function(request, error) {
      if (this.verbose) {
        Polymer.Base._error(error);
      }

      if (request === this.lastRequest) {
        this._setLastError({
          request: request,
          error: error,
          status: request.xhr.status,
          statusText: request.xhr.statusText,
          response: request.xhr.response
        });
        this._setLastResponse(null);
        this._setLoading(false);
      }

      // Tests fail if this goes after the normal this.fire('error', ...)
      this.fire('iron-ajax-error', {
        request: request,
        error: error
      }, {
        bubbles: this.bubbles,
        composed: true
      });

      this.fire('error', {
        request: request,
        error: error
      }, {
        bubbles: this.bubbles,
        composed: true
      });
    },

    _discardRequest: function(request) {
      var requestIndex = this.activeRequests.indexOf(request);

      if (requestIndex > -1) {
        this.splice('activeRequests', requestIndex, 1);
      }
    },

    _requestOptionsChanged: function() {
      this.debounce('generate-request', function() {
        if (this.url == null) {
          return;
        }

        if (this.auto) {
          this.generateRequest();
        }
      }, this.debounceDuration);
    },

  });
</script>



<dom-module id="i18n-number" assetpath="../../../i18n-number/">
  <template strip-whitespace="">
    <span id="number"></span>
  </template>
  <script>
  (function () {
  var intlLibraryScript;
  var intlLibraryLoadingStatus = 'initializing';
  var _setupIntlPolyfillCalled = false;

  /**
   * Set up Intl polyfill if required
   */
  function _setupIntlPolyfill () {
    // Polyfill Intl if required
    var intlLibraryUrl = this.resolveUrl('../intl/dist/Intl.min.js');
    if (window.Intl) {
      if (window.IntlPolyfill && window.Intl === window.IntlPolyfill) {
        intlLibraryLoadingStatus = 'loaded';
      }
      else {
        intlLibraryLoadingStatus = 'native';
      }
    }
    else {
      intlLibraryLoadingStatus = 'loading';
      intlLibraryScript = document.createElement('script');
      intlLibraryScript.setAttribute('src', intlLibraryUrl);
      intlLibraryScript.setAttribute('id', 'intl-js-library');
      intlLibraryScript.addEventListener('load', function intlLibraryLoaded (e) {
        intlLibraryLoadingStatus = 'loaded';
        e.target.removeEventListener('load', intlLibraryLoaded);
        return false;
      });
      var s = document.querySelector('script') || document.body;
      s.parentNode.insertBefore(intlLibraryScript, s);
    }
  }

  /**
   * Set up polyfill locale of Intl if required
   *
   * @param {String} locale Target locale to polyfill
   * @param {Function} callback Callback function to handle locale load
   * @return {Boolean} true if supported; false if callback will be called
   */
  function _setupIntlPolyfillLocale (locale, callback) {
    if (!window.IntlPolyfill) {
      switch (intlLibraryLoadingStatus) {
      case 'loading':
        if (intlLibraryScript) {
          var libraryLoadedBindThis = function (e) {
            _setupIntlPolyfillLocale.call(this, locale, callback);
            e.target.removeEventListener('load', libraryLoadedBindThis);
          }.bind(this);
          intlLibraryScript.addEventListener('load', libraryLoadedBindThis);
          return false;
        }
        else {
          console.error('Intl.js is not being loaded');
        }
        break;
      // impossible cases
      case 'initializing':
      case 'loaded':
      case 'native':
      default:
        /* istanbul ignore next: these cases are impossible */
        break;
      }
    }
    else {
      if (intlLibraryLoadingStatus !== 'native') {
        var supported = Intl.NumberFormat.supportedLocalesOf(locale, { localeMatcher: 'lookup' });
        var script;
        var intlScript;
        if (supported.length === 0) {
          // load the locale
          var fallbackLanguages = _enumerateFallbackLanguages(locale);
          locale = fallbackLanguages.shift();
          script = document.querySelector('script#intl-js-locale-' + locale);
          if (!script) {
            script = document.createElement('script');
            script.setAttribute('id', 'intl-js-locale-' + locale);
            script.setAttribute('src', this.resolveUrl('../intl/locale-data/jsonp/' + locale + '.js'));
            var intlLocaleLoadedBindThis = function (e) {
              if (e.target === script) {
                e.target.removeEventListener('load', intlLocaleLoadedBindThis);
                callback.call(this, locale);
              }
              return false;
            }.bind(this);
            var intlLocaleLoadErrorBindThis = function (e) {
              if (e.target === script) {
                e.target.removeEventListener('error', intlLocaleLoadErrorBindThis);
                script.setAttribute('loaderror','');
                locale = fallbackLanguages.shift();
                if (!locale) {
                  locale = this.DEFAULT_LANG;
                }
                var fallbackSupport = Intl.NumberFormat.supportedLocalesOf(locale, { localeMatcher: 'lookup'});
                if (fallbackSupport.length > 0) {
                  callback.call(this, locale);
                }
                else {
                  _setupIntlPolyfillLocale.call(this, locale, callback);
                }
                return false;
              }
            }.bind(this);
            script.addEventListener('load', intlLocaleLoadedBindThis);
            script.addEventListener('error', intlLocaleLoadErrorBindThis);
            intlScript = document.querySelector('script#intl-js-library') || document.body;
            intlScript.parentNode.insertBefore(script, intlScript.nextSibling);
          }
          else if (!script.hasAttribute('loaderror')) {
            // already loading
            var anotherIntlLocaleLoadedBindThis = function (e) {
              if (e.target === script) {
                callback.call(this, locale);
                e.target.removeEventListener('load', anotherIntlLocaleLoadedBindThis);
                return false;
              }
            }.bind(this);
            var anotherIntlLocaleLoadErrorBindThis = function (e) {
              if (e.target === script) {
                e.target.removeEventListener('error', anotherIntlLocaleLoadErrorBindThis);
                locale = fallbackLanguages.shift();
                if (!locale) {
                  locale = this.DEFAULT_LANG;
                }
                var fallbackSupport = Intl.NumberFormat.supportedLocalesOf(locale, { localeMatcher: 'lookup'});
                if (fallbackSupport.length > 0) {
                  callback.call(this, locale);
                }
                else {
                  _setupIntlPolyfillLocale.call(this, locale, callback);
                }
                return false;
              }
            }.bind(this);
            script.addEventListener('load', anotherIntlLocaleLoadedBindThis);
            script.addEventListener('error', anotherIntlLocaleLoadErrorBindThis);
          }
          else {
            var enSupport = Intl.NumberFormat.supportedLocalesOf(this.DEFAULT_LANG, { localeMatcher: 'lookup'});
            if (enSupport.length > 0) {
              callback.call(this, this.DEFAULT_LANG);
            }
            else {
              _setupIntlPolyfillLocale.call(this, this.DEFAULT_LANG, callback);
            }
          }
          return false;
        }
      }
    }
    return true;
  }

  /**
   * Enumerate fallback locales for the target locale.
   * 
   * Subset implementation of BCP47 (https://tools.ietf.org/html/bcp47).
   *
   * ### Examples:
   *
   *| Target Locale | Fallback 1 | Fallback 2 | Fallback 3 |
   *|:--------------|:-----------|:-----------|:-----------|
   *| ru            | N/A        | N/A        | N/A        |
   *| en-GB         | en         | N/A        | N/A        |
   *| en-Latn-GB    | en-GB      | en-Latn    | en         |
   *| fr-CA         | fr         | N/A        | N/A        |
   *| zh-Hans-CN    | zh-Hans    | zh         | N/A        |
   *| zh-CN         | zh-Hans    | zh         | N/A        |
   *| zh-TW         | zh-Hant    | zh         | N/A        |
   *
   * #### Note:
   *
   * For zh language, the script Hans or Hant is supplied as its default script when a country/region code is supplied.
   *
   * @param {string} lang Target locale.
   * @return {Array} List of fallback locales including the target locale at the index 0.
   */
  function _enumerateFallbackLanguages (lang) {
    var result = [];
    var parts;
    var match;
    var isExtLangCode = 0;
    var extLangCode;
    var isScriptCode = 0;
    var scriptCode;
    var isCountryCode = 0;
    var countryCode;
    var n;
    if (!lang || lang.length === 0) {
      result.push('');
    }
    else {
      parts = lang.split(/[-_]/);
      // normalize ISO-639-1 language codes
      if (parts.length > 0 &&
          parts[0].match(/^[A-Za-z]{2,3}$/)) {
        // language codes have to be lowercased
        // e.g. JA -> ja, FR -> fr
        // TODO: normalize 3-letter codes to 2-letter codes
        parts[0] = parts[0].toLowerCase();
      }
      // normalize ISO-639-3 extension language codes
      if (parts.length >= 2 &&
          parts[1].match(/^[A-Za-z]{3}$/) &&
          !parts[1].match(/^[Cc][Hh][SsTt]$/)) { // exclude CHS,CHT
        // extension language codes have to be lowercased
        // e.g. YUE -> yue
        isExtLangCode = 1;
        extLangCode = parts[1] = parts[1].toLowerCase();
      }
      // normalize ISO-15924 script codes
      if (parts.length >= isExtLangCode + 2 &&
          (match = parts[isExtLangCode + 1].match(/^([A-Za-z])([A-Za-z]{3})$/))) {
        // script codes have to be capitalized only at the first character
        // e.g. HANs -> Hans, lAtN -> Latn
        isScriptCode = 1;
        scriptCode = parts[isExtLangCode + 1] = match[1].toUpperCase() + match[2].toLowerCase();
      }
      // normalize ISO-3166-1 country/region codes
      if (parts.length >= isExtLangCode + isScriptCode + 2 &&
          (match = parts[isExtLangCode + isScriptCode + 1].match(/^[A-Za-z0-9]{2,3}$/))) {
        // country/region codes have to be capitalized
        // e.g. cn -> CN, jP -> JP
        isCountryCode = 1;
        countryCode = parts[isExtLangCode + isScriptCode + 1] = match[0].toUpperCase();
      }
      // extensions have to be in lowercases
      // e.g. U-cA-Buddhist -> u-ca-buddhist, X-LiNux -> x-linux
      if (parts.length >= isExtLangCode + isScriptCode + isCountryCode + 2) {
        for (n = isExtLangCode + isScriptCode + isCountryCode + 1; n < parts.length; n++) {
          parts[n] = parts[n].toLowerCase();
        }
      }
      // enumerate fallback languages
      while (parts.length > 0) {
        // normalize delimiters as -
        // e.g. ja_JP -> ja-JP
        result.push(parts.join('-'));
        if (isScriptCode &&
            isCountryCode &&
            parts.length == isExtLangCode + isScriptCode + 2) {
          // script code can be omitted to default
          // e.g. en-Latn-GB -> en-GB, zh-Hans-CN -> zh-CN
          parts.splice(isExtLangCode + isScriptCode, 1);
          result.push(parts.join('-'));
          parts.splice(isExtLangCode + isScriptCode, 0, scriptCode);
        }
        if (isExtLangCode &&
            isCountryCode &&
            parts.length == isExtLangCode + isScriptCode + 2) {
          // ext lang code can be omitted to default
          // e.g. zh-yue-Hans-CN -> zh-Hans-CN
          parts.splice(isExtLangCode, 1);
          result.push(parts.join('-'));
          parts.splice(isExtLangCode, 0, extLangCode);
        }
        if (isExtLangCode &&
            isScriptCode &&
            parts.length == isExtLangCode + isScriptCode + 1) {
          // ext lang code can be omitted to default
          // e.g. zh-yue-Hans -> zh-Hans
          parts.splice(isExtLangCode, 1);
          result.push(parts.join('-'));
          parts.splice(isExtLangCode, 0, extLangCode);
        }
        if (!isScriptCode &&
            !isExtLangCode &&
            isCountryCode &&
            parts.length == 2) {
          // default script code can be added in certain cases with country codes
          // e.g. zh-CN -> zh-Hans-CN, zh-TW -> zh-Hant-TW
          switch (result[result.length - 1]) {
          case 'zh-CN':
          case 'zh-CHS':
            result.push('zh-Hans');
            break;
          case 'zh-TW':
          case 'zh-SG':
          case 'zh-HK':
          case 'zh-CHT':
            result.push('zh-Hant');
            break;
          default:
            break;
          }
        }
        parts.pop();
      }
    }
    return result;
  }

  Polymer({
    is: 'i18n-number',

    /**
     * Fired whenever the formatted text is rendered.
     *
     * @event rendered
     */
    
    properties: {
      /**
       * The locale for the formatted number.
       * The typical value is bound to `{{effectiveLang}}` when the containing element has
       * `BehaviorsStore.I18nBehavior`.
       */
      _lang: {
        type: String,
        value: 'en',
        observer: '_langChanged',
        reflectToAttribute: false
      },

      /**
       * Options object for Intl.NumberFormat 
       * (https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/NumberFormat)
       */
      options: {
        type: Object,
        observer: '_optionsChanged',
        notify: true
      },

      /**
       * Raw string synchronized with textContent
       */
      raw: {
        type: String,
        observer: '_rawChanged'
      },

      /**
       * Offset for number
       *
       * Note: number = rawNumber - offset 
       */
      offset: {
        type: Number,
        value: 0,
        observer: '_offsetChanged'
      },

      /**
       * Raw number parsed from raw
       */
      rawNumber: {
        type: Number,
        notify: true
      },

      /**
       * Number calculated from rawNumber and offset
       */
      number: {
        type: Number,
        notify: true
      },

      /**
       * Formatted string rendered for UI
       *
       * Note:
       *   - While Intl.js Polyfill locale module is being loaded, the value is set as `undefined` until load completion.
       */
      formatted: {
        type: String,
        notify: true
      }
    },

    observers: [
      '_onOptionsPropertyChanged(options.*)'
    ],

    /**
     * Default locale constant 'en'
     */
    DEFAULT_LANG: 'en',

    /**
     * Start loading Intl polyfill only once
     */
    registered: function () {
      if (!_setupIntlPolyfillCalled) {
        _setupIntlPolyfillCalled = true;
        _setupIntlPolyfill.call(this);
      }
    },

    ready: function () {
      this._setupObservers();
      this.raw = this.textNode.data;
      if (!this.lang) {
        // Polyfill non-functional default value for lang property in Safari 7
        this.lang = this.DEFAULT_LANG;
      }
    },

    attached: function () {
      this.raw = this.textNode.data;
    },

    /**
     * Set up observers of textContent mutations
     */
    _setupObservers: function () {
      this.textNode = Polymer.dom(this).childNodes[0];
      if (!this.textNode) {
        Polymer.dom(this).appendChild(document.createTextNode(''));
        this.textNode = Polymer.dom(this).childNodes[0];
      }
      this.observer = new MutationObserver(this._textMutated.bind(this));
      this.observer.observe(this.textNode, { characterData: true });
      this.observer.observe(this, { attributes: true, attributeFilter: [ 'lang' ] });
      this.nodeObserver = Polymer.dom(this).observeNodes(function (info) {
        if (info.addedNodes[0] && 
            info.addedNodes[0].nodeType === info.addedNodes[0].TEXT_NODE) {
          this.textNode = info.addedNodes[0];
          this.raw = this.textNode.data;
          //console.log('i18n-number: text node added with ' + this.raw);
          this.observer.observe(this.textNode, { characterData: true });
        }
      }.bind(this));
    },

    /**
     * MutationObserver callback of the child text node to re-render on text mutations.
     *
     * @param {Array} mutations Array of MutationRecord (https://developer.mozilla.org/en-US/docs/Web/API/MutationObserver).
     */
    _textMutated: function (mutations) {
      mutations.forEach(function(mutation) {
        switch (mutation.type) {
        case 'characterData':
          //console.log('i18n-number: _textMutated: raw = ' + mutation.target.data);
          if (this.raw !== mutation.target.data) {
            this.raw = mutation.target.data;
          }
          break;
        case 'attributes':
          if (mutation.attributeName === 'lang') {
            this._lang = this.lang;
          }
          break;
        default:
          /* istanbul ignore next: mutation.type is characterData or attributes */
          break;
        }
      }, this);
    },

    /**
     * Observer of `raw` property to re-render the formatted number.
     *
     * @param {string} raw New raw number string.
     */
    _rawChanged: function (raw) {
      if (this.textNode) {
        if (raw !== this.textNode.data) {
          this.textNode.data = raw;
        }
        //console.log('i18n-number: _rawChanged: raw = ' + raw);
        this._render(this.lang, this.options, raw, this.offset);
      }
    },

    /**
     * Observer of `lang` property to re-render the formatted number.
     *
     * @param {string} lang New locale.
     */
    _langChanged: function (lang) {
      if (!lang) {
        this.lang = this.DEFAULT_LANG;
        lang = this.lang;
      }
      if (this.textNode) {
        //console.log('i18n-number: _langChanged: lang = ' + lang);
        this._render(lang, this.options, this.raw, this.offset);
      }
    },

    /**
     * Observer of `options` property to re-render the formatted number.
     *
     * @param {Object} options New options for Intl.NumberFormat.
     */
    _optionsChanged: function (options) {
      if (this.textNode) {
        //console.log('i18n-number: _optionsChanged: options = ' + JSON.stringify(options));
        this._render(this.lang, options, this.raw, this.offset);
      }
    },

    /**
     * Observer of `options` sub-properties to re-render the formatted number.
     */
    _onOptionsPropertyChanged: function (/* changeRecord */) {
      if (this.textNode) {
        //console.log('_onOptionsPropertyChanged: path = ' + changeRecord.path + ' value = ' + JSON.stringify(changeRecord.value));
        this._render(this.lang, this.options, this.raw, this.offset);
      }
    },

    /**
     * Observer of `offset` property to re-render the formatted number.
     *
     * @param {number} offset New offset.
     */
    _offsetChanged: function (offset) {
      if (this.textNode) {
        //console.log('i18n-number: _offsetChanged: offset = ' + offset);
        this._render(this.lang, this.options, this.raw, offset);
      }
    },

    /**
     * Formats the number
     *
     * @param {string} lang Locale for formatting.
     * @param {Object} options Options for Intl.NumberFormat.
     * @param {number} number Number to format.
     * @return {string} Formatted number string.
     */
    _formatNumber: function (lang, options, number) {
      if (!lang) {
        lang = this.DEFAULT_LANG;
      }
      switch (intlLibraryLoadingStatus) {
      case 'loaded':
      case 'loading':
      default:
        try {
          if (_setupIntlPolyfillLocale.call(this, lang, function (locale) {
            this.effectiveLang = locale;
            this._render.call(this, locale, this.options, this.raw, this.offset);
          }.bind(this))) {
            return new Intl.NumberFormat(lang, options).format(number);
          }
          else {
            // waiting for callback
            return undefined;
          }
        }
        catch (e) {
          return number.toString();
        }
        /* istanbul ignore next: unreachable code due to returns in the same case */
        break;
      case 'native':
        // native
        try {
          return new Intl.NumberFormat(lang, options).format(number);
        }
        catch (e) {
          return number.toString();
        }
        /* istanbul ignore next: unreachable code due to returns in the same case */
        break;
      }
    },

    /**
     * Renders the formatted number
     *
     * @param {string} lang Locale for formatting.
     * @param {Object} options Options for Intl.NumberFormat.
     * @param {string} raw Raw number string.
     * @param {number} offset Offset for number.
     */
    _render: function (lang, options, raw, offset) {
      // TODO: rendering may be done redundantly on property initializations
      raw = raw.trim();
      if (!raw && !this.formatted) {
        //console.log('i18n-number: skipping _render as raw is null');
        return;
      }
      if (raw) {
        this.rawNumber = Number(raw);
        this.number = this.rawNumber - offset;
        this.formatted = this._formatNumber(lang, options, this.number);
      }
      else {
        this.rawNumber = undefined;
        this.number = undefined;
        this.formatted = '';
      }
      this.$.number.textContent = this.formatted ? this.formatted : '';
      //console.log('i18n-number: _render ' + this.formatted);
      if (typeof this.formatted !== 'undefined') {
        this.fire('rendered');
      }
    },

    /**
     * Renders the formatted number with the current parameters
     *
     * Note: (As of Polymer 1.2.3)
     *   Explicit render() call is needed whenever the observer 
     *   `_onOptionsPropertyChanged(options.*)` is NOT invoked 
     *   after a property of `options` is changed.  An explicit call 
     *   `this.notifyPath('options', this.options, true)` can also 
     *   trigger re-rendering.
     *
     *   If the changed property of `options` is bound in an annotation
     *   like `{{options.currency}}`, the observer `_onOptionsPropertyChanged(options.*)`
     *   is automatically called whenever the property value is changed
     *   and thus no explicit call of `render()` or `notifyPath()` is
     *   required.
     */
    render: function () {
      this._render(this.lang, this.options, this.raw, this.offset);
    }
  });
  })();
  </script>
</dom-module><script>var _cp = [
function(n, ord) {
  if (ord) return 'other';
  return 'other';
},
function(n, ord) {
  if (ord) return 'other';
  return (n == 1) ? 'one' : 'other';
},
function(n, ord) {
  if (ord) return 'other';
  return ((n == 0
          || n == 1)) ? 'one' : 'other';
},
function(n, ord) {
  var s = String(n).split('.'), v0 = !s[1];
  if (ord) return 'other';
  return (n == 1 && v0) ? 'one' : 'other';
}
];

(function (root, plurals) {
  if (typeof define === 'function' && define.amd) {
    define(plurals);
  } else if (typeof exports === 'object') {
    module.exports = plurals;
  } else {
    root.plurals = plurals;
  }
}(this, {
af: _cp[1],

ak: _cp[2],

am: function(n, ord) {
  if (ord) return 'other';
  return (n >= 0 && n <= 1) ? 'one' : 'other';
},

ar: function(n, ord) {
  var s = String(n).split('.'), t0 = Number(s[0]) == n,
      n100 = t0 && s[0].slice(-2);
  if (ord) return 'other';
  return (n == 0) ? 'zero'
      : (n == 1) ? 'one'
      : (n == 2) ? 'two'
      : ((n100 >= 3 && n100 <= 10)) ? 'few'
      : ((n100 >= 11 && n100 <= 99)) ? 'many'
      : 'other';
},

as: function(n, ord) {
  if (ord) return ((n == 1 || n == 5 || n == 7 || n == 8 || n == 9
          || n == 10)) ? 'one'
      : ((n == 2
          || n == 3)) ? 'two'
      : (n == 4) ? 'few'
      : (n == 6) ? 'many'
      : 'other';
  return (n >= 0 && n <= 1) ? 'one' : 'other';
},

asa: _cp[1],

ast: _cp[3],

az: function(n, ord) {
  var s = String(n).split('.'), i = s[0], i10 = i.slice(-1),
      i100 = i.slice(-2), i1000 = i.slice(-3);
  if (ord) return ((i10 == 1 || i10 == 2 || i10 == 5 || i10 == 7 || i10 == 8)
          || (i100 == 20 || i100 == 50 || i100 == 70
          || i100 == 80)) ? 'one'
      : ((i10 == 3 || i10 == 4) || (i1000 == 100 || i1000 == 200
          || i1000 == 300 || i1000 == 400 || i1000 == 500 || i1000 == 600 || i1000 == 700
          || i1000 == 800
          || i1000 == 900)) ? 'few'
      : (i == 0 || i10 == 6 || (i100 == 40 || i100 == 60
          || i100 == 90)) ? 'many'
      : 'other';
  return (n == 1) ? 'one' : 'other';
},

be: function(n, ord) {
  var s = String(n).split('.'), t0 = Number(s[0]) == n,
      n10 = t0 && s[0].slice(-1), n100 = t0 && s[0].slice(-2);
  if (ord) return ((n10 == 2
          || n10 == 3) && n100 != 12 && n100 != 13) ? 'few' : 'other';
  return (n10 == 1 && n100 != 11) ? 'one'
      : ((n10 >= 2 && n10 <= 4) && (n100 < 12
          || n100 > 14)) ? 'few'
      : (t0 && n10 == 0 || (n10 >= 5 && n10 <= 9)
          || (n100 >= 11 && n100 <= 14)) ? 'many'
      : 'other';
},

bem: _cp[1],

bez: _cp[1],

bg: _cp[1],

bh: _cp[2],

bm: _cp[0],

bn: function(n, ord) {
  if (ord) return ((n == 1 || n == 5 || n == 7 || n == 8 || n == 9
          || n == 10)) ? 'one'
      : ((n == 2
          || n == 3)) ? 'two'
      : (n == 4) ? 'few'
      : (n == 6) ? 'many'
      : 'other';
  return (n >= 0 && n <= 1) ? 'one' : 'other';
},

bo: _cp[0],

br: function(n, ord) {
  var s = String(n).split('.'), t0 = Number(s[0]) == n,
      n10 = t0 && s[0].slice(-1), n100 = t0 && s[0].slice(-2),
      n1000000 = t0 && s[0].slice(-6);
  if (ord) return 'other';
  return (n10 == 1 && n100 != 11 && n100 != 71 && n100 != 91) ? 'one'
      : (n10 == 2 && n100 != 12 && n100 != 72 && n100 != 92) ? 'two'
      : (((n10 == 3 || n10 == 4) || n10 == 9) && (n100 < 10
          || n100 > 19) && (n100 < 70 || n100 > 79) && (n100 < 90
          || n100 > 99)) ? 'few'
      : (n != 0 && t0 && n1000000 == 0) ? 'many'
      : 'other';
},

brx: _cp[1],

bs: function(n, ord) {
  var s = String(n).split('.'), i = s[0], f = s[1] || '', v0 = !s[1],
      i10 = i.slice(-1), i100 = i.slice(-2), f10 = f.slice(-1), f100 = f.slice(-2);
  if (ord) return 'other';
  return (v0 && i10 == 1 && i100 != 11
          || f10 == 1 && f100 != 11) ? 'one'
      : (v0 && (i10 >= 2 && i10 <= 4) && (i100 < 12 || i100 > 14)
          || (f10 >= 2 && f10 <= 4) && (f100 < 12
          || f100 > 14)) ? 'few'
      : 'other';
},

ca: function(n, ord) {
  var s = String(n).split('.'), v0 = !s[1];
  if (ord) return ((n == 1
          || n == 3)) ? 'one'
      : (n == 2) ? 'two'
      : (n == 4) ? 'few'
      : 'other';
  return (n == 1 && v0) ? 'one' : 'other';
},

ce: _cp[1],

cgg: _cp[1],

chr: _cp[1],

ckb: _cp[1],

cs: function(n, ord) {
  var s = String(n).split('.'), i = s[0], v0 = !s[1];
  if (ord) return 'other';
  return (n == 1 && v0) ? 'one'
      : ((i >= 2 && i <= 4) && v0) ? 'few'
      : (!v0) ? 'many'
      : 'other';
},

cy: function(n, ord) {
  if (ord) return ((n == 0 || n == 7 || n == 8
          || n == 9)) ? 'zero'
      : (n == 1) ? 'one'
      : (n == 2) ? 'two'
      : ((n == 3
          || n == 4)) ? 'few'
      : ((n == 5
          || n == 6)) ? 'many'
      : 'other';
  return (n == 0) ? 'zero'
      : (n == 1) ? 'one'
      : (n == 2) ? 'two'
      : (n == 3) ? 'few'
      : (n == 6) ? 'many'
      : 'other';
},

da: function(n, ord) {
  var s = String(n).split('.'), i = s[0], t0 = Number(s[0]) == n;
  if (ord) return 'other';
  return (n == 1 || !t0 && (i == 0
          || i == 1)) ? 'one' : 'other';
},

de: _cp[3],

dsb: function(n, ord) {
  var s = String(n).split('.'), i = s[0], f = s[1] || '', v0 = !s[1],
      i100 = i.slice(-2), f100 = f.slice(-2);
  if (ord) return 'other';
  return (v0 && i100 == 1
          || f100 == 1) ? 'one'
      : (v0 && i100 == 2
          || f100 == 2) ? 'two'
      : (v0 && (i100 == 3 || i100 == 4) || (f100 == 3
          || f100 == 4)) ? 'few'
      : 'other';
},

dv: _cp[1],

dz: _cp[0],

ee: _cp[1],

el: _cp[1],

en: function(n, ord) {
  var s = String(n).split('.'), v0 = !s[1], t0 = Number(s[0]) == n,
      n10 = t0 && s[0].slice(-1), n100 = t0 && s[0].slice(-2);
  if (ord) return (n10 == 1 && n100 != 11) ? 'one'
      : (n10 == 2 && n100 != 12) ? 'two'
      : (n10 == 3 && n100 != 13) ? 'few'
      : 'other';
  return (n == 1 && v0) ? 'one' : 'other';
},

eo: _cp[1],

es: _cp[1],

et: _cp[3],

eu: _cp[1],

fa: function(n, ord) {
  if (ord) return 'other';
  return (n >= 0 && n <= 1) ? 'one' : 'other';
},

ff: function(n, ord) {
  if (ord) return 'other';
  return (n >= 0 && n < 2) ? 'one' : 'other';
},

fi: _cp[3],

fil: function(n, ord) {
  var s = String(n).split('.'), i = s[0], f = s[1] || '', v0 = !s[1],
      i10 = i.slice(-1), f10 = f.slice(-1);
  if (ord) return (n == 1) ? 'one' : 'other';
  return (v0 && (i == 1 || i == 2 || i == 3)
          || v0 && i10 != 4 && i10 != 6 && i10 != 9
          || !v0 && f10 != 4 && f10 != 6 && f10 != 9) ? 'one' : 'other';
},

fo: _cp[1],

fr: function(n, ord) {
  if (ord) return (n == 1) ? 'one' : 'other';
  return (n >= 0 && n < 2) ? 'one' : 'other';
},

fur: _cp[1],

fy: _cp[3],

ga: function(n, ord) {
  var s = String(n).split('.'), t0 = Number(s[0]) == n;
  if (ord) return (n == 1) ? 'one' : 'other';
  return (n == 1) ? 'one'
      : (n == 2) ? 'two'
      : ((t0 && n >= 3 && n <= 6)) ? 'few'
      : ((t0 && n >= 7 && n <= 10)) ? 'many'
      : 'other';
},

gd: function(n, ord) {
  var s = String(n).split('.'), t0 = Number(s[0]) == n;
  if (ord) return 'other';
  return ((n == 1
          || n == 11)) ? 'one'
      : ((n == 2
          || n == 12)) ? 'two'
      : (((t0 && n >= 3 && n <= 10)
          || (t0 && n >= 13 && n <= 19))) ? 'few'
      : 'other';
},

gl: _cp[3],

gsw: _cp[1],

gu: function(n, ord) {
  if (ord) return (n == 1) ? 'one'
      : ((n == 2
          || n == 3)) ? 'two'
      : (n == 4) ? 'few'
      : (n == 6) ? 'many'
      : 'other';
  return (n >= 0 && n <= 1) ? 'one' : 'other';
},

guw: _cp[2],

gv: function(n, ord) {
  var s = String(n).split('.'), i = s[0], v0 = !s[1], i10 = i.slice(-1),
      i100 = i.slice(-2);
  if (ord) return 'other';
  return (v0 && i10 == 1) ? 'one'
      : (v0 && i10 == 2) ? 'two'
      : (v0 && (i100 == 0 || i100 == 20 || i100 == 40 || i100 == 60
          || i100 == 80)) ? 'few'
      : (!v0) ? 'many'
      : 'other';
},

ha: _cp[1],

haw: _cp[1],

he: function(n, ord) {
  var s = String(n).split('.'), i = s[0], v0 = !s[1], t0 = Number(s[0]) == n,
      n10 = t0 && s[0].slice(-1);
  if (ord) return 'other';
  return (n == 1 && v0) ? 'one'
      : (i == 2 && v0) ? 'two'
      : (v0 && (n < 0
          || n > 10) && t0 && n10 == 0) ? 'many'
      : 'other';
},

hi: function(n, ord) {
  if (ord) return (n == 1) ? 'one'
      : ((n == 2
          || n == 3)) ? 'two'
      : (n == 4) ? 'few'
      : (n == 6) ? 'many'
      : 'other';
  return (n >= 0 && n <= 1) ? 'one' : 'other';
},

hr: function(n, ord) {
  var s = String(n).split('.'), i = s[0], f = s[1] || '', v0 = !s[1],
      i10 = i.slice(-1), i100 = i.slice(-2), f10 = f.slice(-1), f100 = f.slice(-2);
  if (ord) return 'other';
  return (v0 && i10 == 1 && i100 != 11
          || f10 == 1 && f100 != 11) ? 'one'
      : (v0 && (i10 >= 2 && i10 <= 4) && (i100 < 12 || i100 > 14)
          || (f10 >= 2 && f10 <= 4) && (f100 < 12
          || f100 > 14)) ? 'few'
      : 'other';
},

hsb: function(n, ord) {
  var s = String(n).split('.'), i = s[0], f = s[1] || '', v0 = !s[1],
      i100 = i.slice(-2), f100 = f.slice(-2);
  if (ord) return 'other';
  return (v0 && i100 == 1
          || f100 == 1) ? 'one'
      : (v0 && i100 == 2
          || f100 == 2) ? 'two'
      : (v0 && (i100 == 3 || i100 == 4) || (f100 == 3
          || f100 == 4)) ? 'few'
      : 'other';
},

hu: function(n, ord) {
  if (ord) return ((n == 1
          || n == 5)) ? 'one' : 'other';
  return (n == 1) ? 'one' : 'other';
},

hy: function(n, ord) {
  if (ord) return (n == 1) ? 'one' : 'other';
  return (n >= 0 && n < 2) ? 'one' : 'other';
},

id: _cp[0],

ig: _cp[0],

ii: _cp[0],

"in": _cp[0],

is: function(n, ord) {
  var s = String(n).split('.'), i = s[0], t0 = Number(s[0]) == n,
      i10 = i.slice(-1), i100 = i.slice(-2);
  if (ord) return 'other';
  return (t0 && i10 == 1 && i100 != 11
          || !t0) ? 'one' : 'other';
},

it: function(n, ord) {
  var s = String(n).split('.'), v0 = !s[1];
  if (ord) return ((n == 11 || n == 8 || n == 80
          || n == 800)) ? 'many' : 'other';
  return (n == 1 && v0) ? 'one' : 'other';
},

iu: function(n, ord) {
  if (ord) return 'other';
  return (n == 1) ? 'one'
      : (n == 2) ? 'two'
      : 'other';
},

iw: function(n, ord) {
  var s = String(n).split('.'), i = s[0], v0 = !s[1], t0 = Number(s[0]) == n,
      n10 = t0 && s[0].slice(-1);
  if (ord) return 'other';
  return (n == 1 && v0) ? 'one'
      : (i == 2 && v0) ? 'two'
      : (v0 && (n < 0
          || n > 10) && t0 && n10 == 0) ? 'many'
      : 'other';
},

ja: _cp[0],

jbo: _cp[0],

jgo: _cp[1],

ji: _cp[3],

jmc: _cp[1],

jv: _cp[0],

jw: _cp[0],

ka: function(n, ord) {
  var s = String(n).split('.'), i = s[0], i100 = i.slice(-2);
  if (ord) return (i == 1) ? 'one'
      : (i == 0 || ((i100 >= 2 && i100 <= 20) || i100 == 40 || i100 == 60
          || i100 == 80)) ? 'many'
      : 'other';
  return (n == 1) ? 'one' : 'other';
},

kab: function(n, ord) {
  if (ord) return 'other';
  return (n >= 0 && n < 2) ? 'one' : 'other';
},

kaj: _cp[1],

kcg: _cp[1],

kde: _cp[0],

kea: _cp[0],

kk: function(n, ord) {
  var s = String(n).split('.'), t0 = Number(s[0]) == n,
      n10 = t0 && s[0].slice(-1);
  if (ord) return (n10 == 6 || n10 == 9
          || t0 && n10 == 0 && n != 0) ? 'many' : 'other';
  return (n == 1) ? 'one' : 'other';
},

kkj: _cp[1],

kl: _cp[1],

km: _cp[0],

kn: function(n, ord) {
  if (ord) return 'other';
  return (n >= 0 && n <= 1) ? 'one' : 'other';
},

ko: _cp[0],

ks: _cp[1],

ksb: _cp[1],

ksh: function(n, ord) {
  if (ord) return 'other';
  return (n == 0) ? 'zero'
      : (n == 1) ? 'one'
      : 'other';
},

ku: _cp[1],

kw: function(n, ord) {
  if (ord) return 'other';
  return (n == 1) ? 'one'
      : (n == 2) ? 'two'
      : 'other';
},

ky: _cp[1],

lag: function(n, ord) {
  var s = String(n).split('.'), i = s[0];
  if (ord) return 'other';
  return (n == 0) ? 'zero'
      : ((i == 0
          || i == 1) && n != 0) ? 'one'
      : 'other';
},

lb: _cp[1],

lg: _cp[1],

lkt: _cp[0],

ln: _cp[2],

lo: function(n, ord) {
  if (ord) return (n == 1) ? 'one' : 'other';
  return 'other';
},

lt: function(n, ord) {
  var s = String(n).split('.'), f = s[1] || '', t0 = Number(s[0]) == n,
      n10 = t0 && s[0].slice(-1), n100 = t0 && s[0].slice(-2);
  if (ord) return 'other';
  return (n10 == 1 && (n100 < 11
          || n100 > 19)) ? 'one'
      : ((n10 >= 2 && n10 <= 9) && (n100 < 11
          || n100 > 19)) ? 'few'
      : (f != 0) ? 'many'
      : 'other';
},

lv: function(n, ord) {
  var s = String(n).split('.'), f = s[1] || '', v = f.length,
      t0 = Number(s[0]) == n, n10 = t0 && s[0].slice(-1),
      n100 = t0 && s[0].slice(-2), f100 = f.slice(-2), f10 = f.slice(-1);
  if (ord) return 'other';
  return (t0 && n10 == 0 || (n100 >= 11 && n100 <= 19)
          || v == 2 && (f100 >= 11 && f100 <= 19)) ? 'zero'
      : (n10 == 1 && n100 != 11 || v == 2 && f10 == 1 && f100 != 11
          || v != 2 && f10 == 1) ? 'one'
      : 'other';
},

mas: _cp[1],

mg: _cp[2],

mgo: _cp[1],

mk: function(n, ord) {
  var s = String(n).split('.'), i = s[0], f = s[1] || '', v0 = !s[1],
      i10 = i.slice(-1), i100 = i.slice(-2), f10 = f.slice(-1);
  if (ord) return (i10 == 1 && i100 != 11) ? 'one'
      : (i10 == 2 && i100 != 12) ? 'two'
      : ((i10 == 7
          || i10 == 8) && i100 != 17 && i100 != 18) ? 'many'
      : 'other';
  return (v0 && i10 == 1
          || f10 == 1) ? 'one' : 'other';
},

ml: _cp[1],

mn: _cp[1],

mo: function(n, ord) {
  var s = String(n).split('.'), v0 = !s[1], t0 = Number(s[0]) == n,
      n100 = t0 && s[0].slice(-2);
  if (ord) return (n == 1) ? 'one' : 'other';
  return (n == 1 && v0) ? 'one'
      : (!v0 || n == 0
          || n != 1 && (n100 >= 1 && n100 <= 19)) ? 'few'
      : 'other';
},

mr: function(n, ord) {
  if (ord) return (n == 1) ? 'one'
      : ((n == 2
          || n == 3)) ? 'two'
      : (n == 4) ? 'few'
      : 'other';
  return (n >= 0 && n <= 1) ? 'one' : 'other';
},

ms: function(n, ord) {
  if (ord) return (n == 1) ? 'one' : 'other';
  return 'other';
},

mt: function(n, ord) {
  var s = String(n).split('.'), t0 = Number(s[0]) == n,
      n100 = t0 && s[0].slice(-2);
  if (ord) return 'other';
  return (n == 1) ? 'one'
      : (n == 0
          || (n100 >= 2 && n100 <= 10)) ? 'few'
      : ((n100 >= 11 && n100 <= 19)) ? 'many'
      : 'other';
},

my: _cp[0],

nah: _cp[1],

naq: function(n, ord) {
  if (ord) return 'other';
  return (n == 1) ? 'one'
      : (n == 2) ? 'two'
      : 'other';
},

nb: _cp[1],

nd: _cp[1],

ne: function(n, ord) {
  var s = String(n).split('.'), t0 = Number(s[0]) == n;
  if (ord) return ((t0 && n >= 1 && n <= 4)) ? 'one' : 'other';
  return (n == 1) ? 'one' : 'other';
},

nl: _cp[3],

nn: _cp[1],

nnh: _cp[1],

no: _cp[1],

nqo: _cp[0],

nr: _cp[1],

nso: _cp[2],

ny: _cp[1],

nyn: _cp[1],

om: _cp[1],

or: _cp[1],

os: _cp[1],

pa: _cp[2],

pap: _cp[1],

pl: function(n, ord) {
  var s = String(n).split('.'), i = s[0], v0 = !s[1], i10 = i.slice(-1),
      i100 = i.slice(-2);
  if (ord) return 'other';
  return (n == 1 && v0) ? 'one'
      : (v0 && (i10 >= 2 && i10 <= 4) && (i100 < 12
          || i100 > 14)) ? 'few'
      : (v0 && i != 1 && (i10 == 0 || i10 == 1)
          || v0 && (i10 >= 5 && i10 <= 9)
          || v0 && (i100 >= 12 && i100 <= 14)) ? 'many'
      : 'other';
},

prg: function(n, ord) {
  var s = String(n).split('.'), f = s[1] || '', v = f.length,
      t0 = Number(s[0]) == n, n10 = t0 && s[0].slice(-1),
      n100 = t0 && s[0].slice(-2), f100 = f.slice(-2), f10 = f.slice(-1);
  if (ord) return 'other';
  return (t0 && n10 == 0 || (n100 >= 11 && n100 <= 19)
          || v == 2 && (f100 >= 11 && f100 <= 19)) ? 'zero'
      : (n10 == 1 && n100 != 11 || v == 2 && f10 == 1 && f100 != 11
          || v != 2 && f10 == 1) ? 'one'
      : 'other';
},

ps: _cp[1],

pt: function(n, ord) {
  var s = String(n).split('.'), t0 = Number(s[0]) == n;
  if (ord) return 'other';
  return ((t0 && n >= 0 && n <= 2) && n != 2) ? 'one' : 'other';
},

"pt-PT": _cp[3],

rm: _cp[1],

ro: function(n, ord) {
  var s = String(n).split('.'), v0 = !s[1], t0 = Number(s[0]) == n,
      n100 = t0 && s[0].slice(-2);
  if (ord) return (n == 1) ? 'one' : 'other';
  return (n == 1 && v0) ? 'one'
      : (!v0 || n == 0
          || n != 1 && (n100 >= 1 && n100 <= 19)) ? 'few'
      : 'other';
},

rof: _cp[1],

root: _cp[0],

ru: function(n, ord) {
  var s = String(n).split('.'), i = s[0], v0 = !s[1], i10 = i.slice(-1),
      i100 = i.slice(-2);
  if (ord) return 'other';
  return (v0 && i10 == 1 && i100 != 11) ? 'one'
      : (v0 && (i10 >= 2 && i10 <= 4) && (i100 < 12
          || i100 > 14)) ? 'few'
      : (v0 && i10 == 0 || v0 && (i10 >= 5 && i10 <= 9)
          || v0 && (i100 >= 11 && i100 <= 14)) ? 'many'
      : 'other';
},

rwk: _cp[1],

sah: _cp[0],

saq: _cp[1],

sdh: _cp[1],

se: function(n, ord) {
  if (ord) return 'other';
  return (n == 1) ? 'one'
      : (n == 2) ? 'two'
      : 'other';
},

seh: _cp[1],

ses: _cp[0],

sg: _cp[0],

sh: function(n, ord) {
  var s = String(n).split('.'), i = s[0], f = s[1] || '', v0 = !s[1],
      i10 = i.slice(-1), i100 = i.slice(-2), f10 = f.slice(-1), f100 = f.slice(-2);
  if (ord) return 'other';
  return (v0 && i10 == 1 && i100 != 11
          || f10 == 1 && f100 != 11) ? 'one'
      : (v0 && (i10 >= 2 && i10 <= 4) && (i100 < 12 || i100 > 14)
          || (f10 >= 2 && f10 <= 4) && (f100 < 12
          || f100 > 14)) ? 'few'
      : 'other';
},

shi: function(n, ord) {
  var s = String(n).split('.'), t0 = Number(s[0]) == n;
  if (ord) return 'other';
  return (n >= 0 && n <= 1) ? 'one'
      : ((t0 && n >= 2 && n <= 10)) ? 'few'
      : 'other';
},

si: function(n, ord) {
  var s = String(n).split('.'), i = s[0], f = s[1] || '';
  if (ord) return 'other';
  return ((n == 0 || n == 1)
          || i == 0 && f == 1) ? 'one' : 'other';
},

sk: function(n, ord) {
  var s = String(n).split('.'), i = s[0], v0 = !s[1];
  if (ord) return 'other';
  return (n == 1 && v0) ? 'one'
      : ((i >= 2 && i <= 4) && v0) ? 'few'
      : (!v0) ? 'many'
      : 'other';
},

sl: function(n, ord) {
  var s = String(n).split('.'), i = s[0], v0 = !s[1], i100 = i.slice(-2);
  if (ord) return 'other';
  return (v0 && i100 == 1) ? 'one'
      : (v0 && i100 == 2) ? 'two'
      : (v0 && (i100 == 3 || i100 == 4)
          || !v0) ? 'few'
      : 'other';
},

sma: function(n, ord) {
  if (ord) return 'other';
  return (n == 1) ? 'one'
      : (n == 2) ? 'two'
      : 'other';
},

smi: function(n, ord) {
  if (ord) return 'other';
  return (n == 1) ? 'one'
      : (n == 2) ? 'two'
      : 'other';
},

smj: function(n, ord) {
  if (ord) return 'other';
  return (n == 1) ? 'one'
      : (n == 2) ? 'two'
      : 'other';
},

smn: function(n, ord) {
  if (ord) return 'other';
  return (n == 1) ? 'one'
      : (n == 2) ? 'two'
      : 'other';
},

sms: function(n, ord) {
  if (ord) return 'other';
  return (n == 1) ? 'one'
      : (n == 2) ? 'two'
      : 'other';
},

sn: _cp[1],

so: _cp[1],

sq: function(n, ord) {
  var s = String(n).split('.'), t0 = Number(s[0]) == n,
      n10 = t0 && s[0].slice(-1), n100 = t0 && s[0].slice(-2);
  if (ord) return (n == 1) ? 'one'
      : (n10 == 4 && n100 != 14) ? 'many'
      : 'other';
  return (n == 1) ? 'one' : 'other';
},

sr: function(n, ord) {
  var s = String(n).split('.'), i = s[0], f = s[1] || '', v0 = !s[1],
      i10 = i.slice(-1), i100 = i.slice(-2), f10 = f.slice(-1), f100 = f.slice(-2);
  if (ord) return 'other';
  return (v0 && i10 == 1 && i100 != 11
          || f10 == 1 && f100 != 11) ? 'one'
      : (v0 && (i10 >= 2 && i10 <= 4) && (i100 < 12 || i100 > 14)
          || (f10 >= 2 && f10 <= 4) && (f100 < 12
          || f100 > 14)) ? 'few'
      : 'other';
},

ss: _cp[1],

ssy: _cp[1],

st: _cp[1],

sv: function(n, ord) {
  var s = String(n).split('.'), v0 = !s[1], t0 = Number(s[0]) == n,
      n10 = t0 && s[0].slice(-1), n100 = t0 && s[0].slice(-2);
  if (ord) return ((n10 == 1
          || n10 == 2) && n100 != 11 && n100 != 12) ? 'one' : 'other';
  return (n == 1 && v0) ? 'one' : 'other';
},

sw: _cp[3],

syr: _cp[1],

ta: _cp[1],

te: _cp[1],

teo: _cp[1],

th: _cp[0],

ti: _cp[2],

tig: _cp[1],

tk: _cp[1],

tl: function(n, ord) {
  var s = String(n).split('.'), i = s[0], f = s[1] || '', v0 = !s[1],
      i10 = i.slice(-1), f10 = f.slice(-1);
  if (ord) return (n == 1) ? 'one' : 'other';
  return (v0 && (i == 1 || i == 2 || i == 3)
          || v0 && i10 != 4 && i10 != 6 && i10 != 9
          || !v0 && f10 != 4 && f10 != 6 && f10 != 9) ? 'one' : 'other';
},

tn: _cp[1],

to: _cp[0],

tr: _cp[1],

ts: _cp[1],

tzm: function(n, ord) {
  var s = String(n).split('.'), t0 = Number(s[0]) == n;
  if (ord) return 'other';
  return ((n == 0 || n == 1)
          || (t0 && n >= 11 && n <= 99)) ? 'one' : 'other';
},

ug: _cp[1],

uk: function(n, ord) {
  var s = String(n).split('.'), i = s[0], v0 = !s[1], t0 = Number(s[0]) == n,
      n10 = t0 && s[0].slice(-1), n100 = t0 && s[0].slice(-2), i10 = i.slice(-1),
      i100 = i.slice(-2);
  if (ord) return (n10 == 3 && n100 != 13) ? 'few' : 'other';
  return (v0 && i10 == 1 && i100 != 11) ? 'one'
      : (v0 && (i10 >= 2 && i10 <= 4) && (i100 < 12
          || i100 > 14)) ? 'few'
      : (v0 && i10 == 0 || v0 && (i10 >= 5 && i10 <= 9)
          || v0 && (i100 >= 11 && i100 <= 14)) ? 'many'
      : 'other';
},

ur: _cp[3],

uz: _cp[1],

ve: _cp[1],

vi: function(n, ord) {
  if (ord) return (n == 1) ? 'one' : 'other';
  return 'other';
},

vo: _cp[1],

vun: _cp[1],

wa: _cp[2],

wae: _cp[1],

wo: _cp[0],

xh: _cp[1],

xog: _cp[1],

yi: _cp[3],

yo: _cp[0],

zh: _cp[0],

zu: function(n, ord) {
  if (ord) return 'other';
  return (n >= 0 && n <= 1) ? 'one' : 'other';
}
}));
</script>

<dom-module id="i18n-format" assetpath="../../../i18n-format/">
  <template>
  </template>
</dom-module>
<script>
Polymer({
  is: 'i18n-format',

  /**
   * Fired whenever the formatted text is rendered.
   *
   * @event rendered
   */

  properties: {
    /**
     * The locale for the template text.
     * The typical value is bound to `{{effectiveLang}}` when the containing element has
     * `BehaviorsStore.I18nBehavior`.
     */
    _lang: {
      type: String,
      value: 'en',
      reflectToAttribute: false,
      observer: '_langChanged'
    },

    /**
     * The parameter attribute name to identify parameters.
     * No need to change in a normal usage.
     */
    paramAttribute: {
      type: String,
      value: (function () { return Polymer.Element ? 'slot' : 'param'; })(),
      observer: '_paramAttributeChanged'
    },

    /**
     * The parameter format in the template text.
     * The `'n'` in the format means n-th parameter.
     * No need to change in a normal usage.
     */
    paramFormat: {
      type: String,
      value: '{n}',
      observer: '_paramFormatChanged'
    },

    /**
     * When the boolean attribute `observe-params` is specified, 
     * the template is re-rendered on every parameter mutation.
     * If not specified, the template is re-rendered only on `lang` changes and template text changes.
     *
     * Note: If true, re-rendering may be performed muiltiple times redundantly on a locale change.
     */
    observeParams: {
      type: Boolean,
      value: true // TODO: optimize re-rendering
    }
  },

  /**
   * Default locale constant 'en'
   */
  DEFAULT_LANG: 'en',

  ready: function () {
    this._setupParams();
    if (this.root === this) {
      this.attachShadow({ mode: 'open' });
      this.root = this.shadowRoot;
      this.render();
    }
    if (!this.lang) {
      // Polyfill non-functional default value for lang property in Safari 7
      this.lang = this.DEFAULT_LANG;
    }
  },

  attached: function () {
    this.render();
  },

  /**
   * Traverse the local DOM and set up parameters and observers.
   */
  _setupParams: function () {
    var n;
    this.elements = Array.prototype.filter.call(
      Polymer.dom(this).childNodes,
      function (node) {
        return node.nodeType === node.ELEMENT_NODE;
      }
    );
    var needParamObservation = this.observeParams &&
                               this.elements.length > 0 && 
                               this.elements[0].tagName.toLowerCase() === 'json-data';
    this.observer = new MutationObserver(this._templateMutated.bind(this));
    this.observer.observe(this, { attributes: true, attributeFilter: [ 'lang' ] });
    for (n = 0; n < this.elements.length; n++) {
      if (n === 0) {
        this.templateElement = this.elements[n];
        this.templateTextNode = Polymer.dom(this.templateElement).childNodes[0];
        this.observer.observe(this.templateTextNode, { characterData: true });
      }
      else {
        if (!this.elements[n].hasAttribute(this.paramAttribute)) {
          this.elements[n].setAttribute(this.paramAttribute, '' + n);
        }
        if (needParamObservation) {
          // TODO: childNodes[0] may not be a text node
          this.observer.observe(Polymer.dom(this.elements[n]).childNodes[0], { characterData: true });
          if (this.elements[n].tagName.toLowerCase() === 'i18n-number') {
            this.listen(this.elements[n], 'rendered', 'render');
          }
        }
      }
    }
    //console.log('i18n-format: _setupParams: elements = ' + this.elements);
  },

  /**
   * MutationObserver callback of child text nodes to re-render on template text or parameter mutations.
   *
   * @param {Array} mutations Array of MutationRecord (https://developer.mozilla.org/en-US/docs/Web/API/MutationObserver).
   */
  _templateMutated: function (mutations) {
    mutations.forEach(function(mutation) {
      switch (mutation.type) {
      case 'characterData':
        //console.log('i18n-format: ' + this.id + '._templateMutated(): characterData: tag = ' + 
        //            Polymer.dom(mutation.target).parentNode.tagName.toLowerCase() + 
        //            ' data = ' + mutation.target.data);
        if ((Polymer.Element ? mutation.target : Polymer.dom(mutation.target)).parentNode.tagName.toLowerCase() !== 'i18n-number' ||
            typeof (Polymer.Element ? mutation.target : Polymer.dom(mutation.target)).parentNode.formatted !== 'undefined') {
          this.render();
        }
        break;
      case 'attributes':
        if (mutation.attributeName === 'lang') {
          this._lang = this.lang;
        }
        break;
      default:
        /* istanbul ignore next: mutation.type is always characterData or attributes */
        break;
      }
    }, this);
  },

  /**
   * Observer of `lang` property to re-render the template text.
   *
   * @param {string} lang New locale.
   */
  _langChanged: function (lang /*, oldLang */) {
    //console.log('i18n-format: ' + this.id + '._langChanged() lang = ' + lang + ' oldLang = ' + oldLang);
    if (this.elements &&
        lang !== undefined &&
        lang !== null &&
        !lang.match(/^{{.*}}$/) &&
        !lang.match(/^\[\[.*\]\]$/)) {
      this.render();
    }
    //else {
    //  console.log('i18n-format: skipping render()');
    //}
  },

  /**
   * Observer of `paramFormat` property to re-render the template text.
   *
   * @param {string} paramFormat New paramFormat.
   * @param {string} oldParamFormat Old paramFormat.
   */
  _paramFormatChanged: function (paramFormat, oldParamFormat) {
    //console.log('i18n-format: ' + this.id + '._paramFormatChanged() new = ' + paramFormat + ' old = ' + oldParamFormat);
    if (this.elements &&
        oldParamFormat !== undefined &&
        paramFormat &&
        this.lang !== undefined &&
        this.lang !== null &&
        !this.lang.match(/^{{.*}}$/) &&
        !this.lang.match(/^\[\[.*\]\]$/)) {
      this.lastTemplateText = undefined;
      this.render();
    }
  },

  /**
   * Observer of `paramAttribute` property to reset parameter attributes.
   *
   * @param {string} paramAttribute New paramAttribute.
   * @param {string} oldParamAttribute Old paramAttribute.
   */
  _paramAttributeChanged: function (paramAttribute, oldParamAttribute) {
    //console.log('i18n-format: ' + this.id + '._paramAttributeChanged() new = ' + paramAttribute + ' old = ' + oldParamAttribute);
    var n;
    if (this.elements &&
        oldParamAttribute !== undefined &&
        paramAttribute &&
        this.lang !== undefined &&
        this.lang !== null &&
        !this.lang.match(/^{{.*}}$/) &&
        !this.lang.match(/^\[\[.*\]\]$/)) {
      for (n = 1; n < this.elements.length; n++) {
        this.elements[n].removeAttribute(oldParamAttribute);
        if (!this.elements[n].hasAttribute(paramAttribute)) {
          this.elements[n].setAttribute(paramAttribute, '' + n);
        }
      }
      this.lastTemplateText = undefined;
      this.render();
    }
  },

  /**
   * Detect the CLDR plural category of a number 
   * with [`make-plural` library](https://github.com/eemeli/make-plural.js).
   *
   * @param {number} n The number to get the plural category for.
   * @return {string} Plural category of the number. 
   */
  _getPluralCategory: function (n) {
    var category = 'other';
    var lang = this.lang || this.DEFAULT_LANG;
    lang = lang.split(/[-_]/)[0];
    if (window.plurals[lang]) {
      category = window.plurals[lang](n);
    }
    else {
      category = window.plurals.en(n);
    }
    //console.log('i18n-format: _getPluralCategory(' + n + ') = ' + category);
    return category;
  },

  /**
   * Select a template text by parameters.
   *
   * @return {string} Selected template text. 
   */
  _selectTemplateText: function () {
    var templateText = '';
    if (!this.templateElement) {
      return templateText;
    }
    else if (this.templateElement.tagName.toLowerCase() === 'json-data') {
      var templateObject;
      try {
        templateObject = JSON.parse(this.templateTextNode.data);
      }
      catch (ex) {
        if (this.templateTextNode.data) {
          console.warn('i18n-format: parse error in json-data');
        }
        return templateText;
      }
      var n;
      for (n = 1;
           typeof templateObject === 'object' && n < this.elements.length;
           n++) {
        var param = this.elements[n];
        if (param.tagName.toLowerCase() === 'i18n-number') {
          // plural selector
          var category = this._getPluralCategory(param.number);
          if (typeof param.number === 'undefined' ||
              typeof param.formatted === 'undefined') {
            // i18n-number is not ready
            //console.log('i18n-format: i18n-number is not ready');
            templateObject = undefined;
          }
          else if (templateObject[param.rawNumber]) {
            templateObject = templateObject[param.rawNumber];
          }
          else if (templateObject[category]) {
            // plural category matched
            templateObject = templateObject[category];
          }
          else if (templateObject.other) {
            // other
            templateObject = templateObject.other;
          }
          else {
            // default
            templateObject = '';
            console.warn('i18n-format: cannot find a template');
          }
        }
        else {
          // string selector
          if (templateObject[param.textContent]) {
            // template found
            templateObject = templateObject[param.textContent];
          }
          else if (templateObject.other) {
            // other
            templateObject = templateObject.other;
          }
          else {
            // default
            templateObject = '';
            console.warn('i18n-format: cannot find a template');
          }
        }
      }
      if (typeof templateObject === 'string') {
        templateText = templateObject;
      }
      else if (typeof templateObject === 'undefined') {
        templateText = undefined;
      }
      else {
        templateText = '';
        console.warn('i18n-format: cannot find a template');
      }
    }
    else {
      templateText = this.templateTextNode.data;
    }
    return templateText;
  },

  /**
   * Render the template text.
   */
  render: function () {
    var templateText = this._selectTemplateText();
    var tmpNode = document.createElement('span');
    var paramPlaceholder;
    var childNodes = [];
    var i;
    var shadowDomV1 = !!Polymer.Element;
    var shadyDomV1 = !!window.ShadyDOM;

    if (templateText === this.lastTemplateText) {
      //console.log('i18n-format: skipping rendering as the templateText has not changed');
      return;
    }
    else if (typeof templateText === 'undefined') {
      return;
    }
    else {
      this.lastTemplateText = templateText;
      //console.log('i18n-format: ' + this.id + '.render() templateText = ' + templateText);
    }

    i = 1;
    while (i < this.elements.length) {
      paramPlaceholder = this.paramFormat.replace('n', i);
      templateText = templateText.replace(paramPlaceholder, 
                      shadowDomV1 ? '<slot name="' + i + '"></slot>' :
                      '<content select="[' + this.paramAttribute + '=\'' + i + '\']"></content>');
      i++;
    }
    
    tmpNode.innerHTML = templateText;

    if (Polymer.Element) {
      if (this.root === this) {
        this.attachShadow({ mode: 'open' });
        this.root = this.shadowRoot;
      }
      this.root.innerHTML = ''; // Polymer 2.x
    }
    else {
      Polymer.dom(this.root).innerHTML = '';
    }

    // References of childNodes have to be copied for Shady DOM compatibility
    for (i = 0; i < tmpNode.childNodes.length; i++) {
      childNodes[i] = tmpNode.childNodes[i];
    }

    for (i = 0; i < childNodes.length; i++) {
      // each node has to be appended via Polymer.dom()
      Polymer.dom(this.root).appendChild(childNodes[i]);
    }

    if (shadyDomV1) {
      ShadyDOM.flush();
    }
    this.fire('rendered');
  }
});
</script>

<dom-module id="iron-localstorage" assetpath="../../../iron-localstorage/"></dom-module>
<script>

  Polymer({
    is: 'iron-localstorage',

    properties: {
      /**
       * localStorage item key
       */
      name: {
        type: String,
        value: ''
      },
      /**
       * The data associated with this storage.
       * If set to null item will be deleted.
       * @type {*}
       */
      value: {
        type: Object,
        notify: true
      },

      /**
       * If true: do not convert value to JSON on save/load
       */
      useRaw: {
        type: Boolean,
        value: false
      },

      /**
       * Value will not be saved automatically if true. You'll have to do it manually with `save()`
       */
      autoSaveDisabled: {
        type: Boolean,
        value: false
      },
      /**
       * Last error encountered while saving/loading items
       */
      errorMessage: {
        type: String,
        notify: true
      },

      /** True if value has been loaded */
      _loaded: {
        type: Boolean,
        value: false
      }
    },

    observers: [
      '_debounceReload(name,useRaw)',
      '_trySaveValue(autoSaveDisabled)',
      '_trySaveValue(value.*)'
    ],

    ready: function() {
      this._boundHandleStorage = this._handleStorage.bind(this);
    },

    attached: function() {
      window.addEventListener('storage', this._boundHandleStorage);
    },

    detached: function() {
      window.removeEventListener('storage', this._boundHandleStorage);
    },

    _handleStorage: function(ev) {
      if (ev.key == this.name) {
        this._load(true);
      }
    },

    _trySaveValue: function() {
      if (this._doNotSave) {
        return;
      }
      if (this._loaded && !this.autoSaveDisabled) {
        this.debounce('save', this.save);
      }
    },

    _debounceReload: function() {
      this.debounce('reload', this.reload);
    },

    /**
     * Loads the value again. Use if you modify
     * localStorage using DOM calls, and want to
     * keep this element in sync.
     */
    reload: function() {
      this._loaded = false;
      this._load();
    },

    /**
     * loads value from local storage
     * @param {boolean=} externalChange true if loading changes from a different window
     */
    _load: function(externalChange) {
      try {
        var v = window.localStorage.getItem(this.name);
      } catch (ex) {
        this.errorMessage = ex.message;

        this._error("Could not save to localStorage.  Try enabling cookies for this page.", ex);
      };

      if (v === null) {
        this._loaded = true;
        this._doNotSave = true;  // guard for save watchers
        this.value = null;
        this._doNotSave = false;
        this.fire('iron-localstorage-load-empty', { externalChange: externalChange});
      } else {
        if (!this.useRaw) {
          try { // parse value as JSON
            v = JSON.parse(v);
          } catch(x) {
            this.errorMessage = "Could not parse local storage value";
            Polymer.Base._error("could not parse local storage value", v);
            v = null;
          }
        }
        this._loaded = true;
        this._doNotSave = true;
        this.value = v;
        this._doNotSave = false;
        this.fire('iron-localstorage-load', { externalChange: externalChange});
      }
    },

    /**
     * Saves the value to localStorage. Call to save if autoSaveDisabled is set.
     * If `value` is null or undefined, deletes localStorage.
     */
    save: function() {
      var v = this.useRaw ? this.value : JSON.stringify(this.value);
      try {
        if (this.value === null || this.value === undefined) {
          window.localStorage.removeItem(this.name);
        } else {
          window.localStorage.setItem(this.name, /** @type {string} */ (v));
        }
      }
      catch(ex) {
        // Happens in Safari incognito mode,
        this.errorMessage = ex.message;
        Polymer.Base._error("Could not save to localStorage. Incognito mode may be blocking this action", ex);
      }
    }

    /**
     * Fired when value loads from localStorage.
     *
     * @event iron-localstorage-load
     * @param {{externalChange:boolean}} detail -
     *     externalChange: true if change occured in different window.
     */

    /**
     * Fired when loaded value does not exist.
     * Event handler can be used to initialize default value.
     *
     * @event iron-localstorage-load-empty
     * @param {{externalChange:boolean}} detail -
     *     externalChange: true if change occured in different window.
     */
  });

</script>

<template id="i18n-preference">
  <iron-localstorage id="storage" name="i18n-behavior-preference" on-iron-localstorage-load-empty="_onLoadEmptyStorage" on-iron-localstorage-load="_onLoadStorage" on-value-changed="_onStorageValueChange">
  </iron-localstorage>
</template>
<div id="dom-module-placeholder"></div>
<script>
(function(document) {
  'use strict';

  // html element of this document
  var html = document.querySelector('html');
  // app global default language
  var defaultLang = html.hasAttribute('lang') ? html.getAttribute('lang') : '';

  // imperative synchronous registration of the template for Polymer 2.x
  var template = ((!window.HTMLImports || HTMLImports.hasNative || HTMLImports.useNative) ? document.currentScript : (document._currentScript || document.currentScript))
    .ownerDocument.querySelector('template#i18n-preference');
  var domModule = document.createElement('dom-module');
  var currentScript = (!window.HTMLImports || HTMLImports.hasNative || HTMLImports.useNative) ? document.currentScript : (document._currentScript || document.currentScript);
  var registerI18nPreference = function () {

  currentScript.ownerDocument.querySelector('div#dom-module-placeholder').appendChild(domModule);
  domModule.appendChild(template);
  domModule.register('i18n-preference');

  Polymer({
    is: 'i18n-preference',

    properties: {
      /**
       * Persistence of preference 
       */
      persist: {
        type: Boolean,
        value: false,
        reflectToAttribute: true,
        notify: true,
        observer: '_onPersistChange'
      }
    },

    /**
     * Ready callback to initialize this.lang
     */
    ready: function () {
      if (this.persist) {
        // delay this.lang update
      }
      else {
        //this.$.storage.value = undefined;
      }
      this.isReady = true;
    },

    /**
     * Attached callback to initialize html.lang and its observation
     */
    attached: function () {
      this._observe();
      if (this.persist) {
        // delay html.lang update
      }
      else {
        if (!html.hasAttribute('preferred')) {
          html.setAttribute('lang', navigator.language || navigator.browserLanguage);
        }
      }
    },

    /**
     * Detached callback to diconnect html.lang observation
     */
    detached: function () {
      this._disconnect();
    },

    /**
     * Initialize an empty localstorage
     */
    _onLoadEmptyStorage: function () {
      if (this.isReady) {
        if (this.persist) {
          if (this.isInitialized) {
            // store html.lang value
            this.$.storage.value = html.getAttribute('lang');
          }
          else {
            if (html.hasAttribute('preferred')) {
              this.$.storage.value = html.getAttribute('lang');
            }
            else {
              this.$.storage.value = navigator.language || navigator.browserLanguage;
              if (html.getAttribute('lang') !== this.$.storage.value) {
                html.setAttribute('lang', this.$.storage.value);
              }
            }
            this.isInitialized = true;
          }
        }
        else {
          // leave the empty storage as it is
        }
      }
    },


    /**
     * Handle the loaded storage value
     */
    _onLoadStorage: function () {
      if (this.isReady) {
        if (this.persist) {
          // preferred attribute in html to put higher priority
          // in the default html language than navigator.language
          if (html.hasAttribute('preferred')) {
            if (this.$.storage.value !== defaultLang) {
              // overwrite the storage by the app default language
              this.$.storage.value = defaultLang;
            }
          }
          else {
            // load the value from the storage
            html.setAttribute('lang', this.$.storage.value);
          }
        }
        else {
          // empty the storage
          this.$.storage.value = undefined;
        }
      }
    },

    /**
     * Handle persist changes
     *
     * @param {Boolean} value new this.persist value
     */
    _onPersistChange: function (value) {
      if (this.isReady) {
        if (value) {
          if (this.$.storage.value !== html.getAttribute('lang')) {
            // save to the storage
            this.$.storage.value = html.getAttribute('lang');
          }
        }
        else {
          // empty the storage
          this.$.storage.value = undefined;
        }
      }
    },

    /**
     * Handle storage value changes
     *
     * @param {Event} e value-changed event on the storage
     */
    _onStorageValueChange: function (e) {
      var value = e.detail.value;
      if (this.isReady) {
        if (this.persist) {
          if (value) {
            if (value !== html.getAttribute('lang')) {
              // save to the lang
              html.setAttribute('lang', value);
            }
          }
          else {
            // update the storage
            this.$.storage.value = html.getAttribute('lang');
          }
        }
        else {
          if (value) {
            // empty the storage
            this.$.storage.value = undefined;
          }
        }
      }
    },

    /**
     * Handle value changes on localstorage
     *
     * @param {MutationRecord[]} mutations Array of MutationRecords for html.lang
     *
     * Note: 
     *   - Bound to this element
     */
    _htmlLangMutationObserverCallback: function (mutations) {
      mutations.forEach(function(mutation) {
        switch (mutation.type) {
        case 'attributes':
          if (mutation.attributeName === 'lang') {
            if (this.$.storage.value !== mutation.target.getAttribute('lang')) {
              this.$.storage.value = mutation.target.getAttribute('lang');
            }
          }
          break;
        default:
          break;
        }
      }.bind(this));
    },

    /**
     * Set up html.lang mutation observer
     */
    _observe: function () {
      // observe html lang mutations
      if (!this._htmlLangMutationObserver) {
        this._htmlLangMutationObserverCallbackBindThis = 
          this._htmlLangMutationObserverCallback.bind(this);
        this._htmlLangMutationObserver =
          new MutationObserver(this._htmlLangMutationObserverCallbackBindThis);
      }
      this._htmlLangMutationObserver.observe(html, { attributes: true });
    },

    /**
     * Disconnect html.lang mutation observer
     */
    _disconnect: function () {
      if (this._htmlLangMutationObserver) {
        this._htmlLangMutationObserver.disconnect();
      }
    }
  });
  }
  if ((!window.HTMLImports || HTMLImports.hasNative || HTMLImports.useNative)) {
    registerI18nPreference();
  }
  else {
    HTMLImports.whenReady(registerI18nPreference);
  }
})(document);
</script><template id="i18n-attr-repo">
    <template id="standard">
      
      <input placeholder="" value="type=button|submit">
      <any-elements title="" aria-label="$" aria-valuetext="$"></any-elements>

      
      <paper-input label="" error-message="" placeholder=""></paper-input>
      <paper-textarea label="" error-message="" placeholder=""></paper-textarea>
      <paper-dropdown-menu label=""></paper-dropdown-menu>
      <paper-toast text=""></paper-toast>
      <paper-badge label=""></paper-badge>
      <google-chart options="" cols="" rows="" data=""></google-chart>
      <google-signin label-signin="" label-signout="" label-additional=""></google-signin>
      <platinum-push-messaging title="" message=""></platinum-push-messaging>

      
      <json-data any-attributes=""></json-data>
    </template>
</template>
<script>
(function () {
  // shared data
  var sharedData = {};

  // imperative synchronous registration of the template for Polymer 2.x
  var template = ((!window.HTMLImports || HTMLImports.hasNative || HTMLImports.useNative) ? document.currentScript : (document._currentScript || document.currentScript))
    .ownerDocument.querySelector('template#i18n-attr-repo');
  var domModule = document.createElement('dom-module');
  domModule.appendChild(template);
  domModule.register('i18n-attr-repo');
  window.BehaviorsStore = window.BehaviorsStore || {};
  // Polymer function for iron-component-page documentation
  var Polymer = function (proto) {
    BehaviorsStore._I18nAttrRepo = proto;
    BehaviorsStore._I18nAttrRepo._created();
    return window.Polymer(proto);
  };

/*
`<i18n-attr-repo>` maintains a list of attributes targeted for UI localization.  
It judges whether a specific attribute of an element requires localization or not. 

    var attrRepository = 
      document.createElement('i18n-attr-repo');

    attrRepository.registerLocalizableAttributes(
      'custom-element',
      Polymer.DomModule.import('custom-element', 'template')
    );
    attrRepository.isLocalizableAttribute(inputElement, 'placeholder');

### Interactions with `BehaviorsStore.I18nBehavior`

The element is not meant for DOM attachment. The object is
a singleton object dedicated for `BehaviorsStore.I18nBehavior`.
`I18nBehavior` interacts with the localizable attributes repository in these 3 ways.

### 1) Construct the repository for the standard elements from its own static template at the object creation.

```
    // i18n-behavior.html
    var attrRepository = 
      document.createElement('i18n-attr-repo');
```

Pre-defined I18N-target attributes in the static template of `i18n-attr-repo`:

```
    <dom-module id="i18n-attr-repo">
      <template>
        <template id="standard">
          <input placeholder>
          <any-elements title aria-label="$" aria-valuetext="$"></any-elements>

          <paper-input label error-message placeholder></paper-input>
          <paper-textarea label error-message placeholder></paper-textarea>
          <paper-dropdown-menu label></paper-dropdown-menu>
          <paper-toast text></paper-toast>
          <google-chart options cols rows data></google-chart>
          <google-signin label-signin label-signout label-additional></google-signin>
          <platinum-push-messaging title message></platinum-push-messaging>

          <json-data any-attributes></json-data>
        </template>
      </template>
    </dom-module>
```

This static list is also referenced by [`gulp-i18n-preprocess`](https://github.com/t2ym/gulp-i18n-preprocess) filter for
build-time automatic I18N of hard-coded string attributes.

### 2) Register I18N-target attributes of custom elements from a template with id="custom" in its light DOM.

I18N-target attributes for custom elements without I18nBehavior can be registered to the respository by this method. 

Example I18N-target attributes in a static template in the light DOM of `i18n-attr-repo`:

```
    <i18n-attr-repo>
      <template id="custom">
        <shop-md-decorator error-message="$"></shop-md-decorator>
        <input value="type=submit|button">
        <my-element i18n-target-attr="attr=value,boolean-attr,!boolean-attr"></my-element>
        <my-element i18n-target-attr="attr1=value1,attr2=value2,type-name"></my-element>
        <my-element i18n-target-attr="boolean-attr="></my-element>
        <my-element i18n-target-attr="type-name2"></my-element>
      </template>
    </i18n-attr-repo>
```

This list is also referenced by [`gulp-i18n-preprocess`](https://github.com/t2ym/gulp-i18n-preprocess) filter for
build-time automatic I18N of hard-coded string attributes.

Note: Type name feature is currently ineffective and reserved for further expansion of the attribute I18N features.

### 3) Register localizable attributes of the newly registered elements from the `text-attr` attribute of the element's template.

```
    // i18n-behavior.html, scanning custom-element template
    var id = 'custom-element';
    attrRepository.registerLocalizableAttributes(
      id, 
      Polymer.DomModule.import(id, 'template')
    );
```
```
    // custom-element.html
    <dom-module id="custom-element">
      <template text-attr="localizable-attr1 localizable-attr2">
        <span>{{localizableAttr1}}</span>
        <span>{{localizableAttr2}}</span>
      </template>
      <script>
        Polymer({
          is: 'custom-element',
          behaviors: [ BehaviorsStore.I18nBehavior ],
          properties: {
            localizableAttr1: {
              type: String
            },
            localizableAttr2: {
              type: String
            }
          }
        });
      </ script>
    </dom-module>
```

`text-attr` attributes are also traversed for build-time automatic I18N of 
hard-coded UI string attributes by [`gulp-i18n-preprocess`](https://github.com/t2ym/gulp-i18n-preprocess) filter.

### 4) Judge localizability of attributes for the local DOM elements of the newly registered element.

```
    // i18n-behavior.html, scanning custom-element-user template
    var element; // target element
    var attr;
    if (attrRepository.isLocalizableAttribute(element, attr.name)) {
      // make localizalbe-attr1 localizable
    }
```
```
    // custom-element-user.html
    <dom-module id="custom-element-user">
      <template>
        <custom-element id="custom"
                        localizable-attr1="UI Text Label 1"
                        localizable-attr2="UI Text Label 2">
        </custom-element>
      </template>
      <script>
        Polymer({
          is: 'custom-element-user',
          behaviors: [ BehaviorsStore.I18nBehavior ]
        });
      </ script>
    </dom-module>
```
```
    // template for custom-element-user after localization binding
    <template>
      <custom-element id="custom"
                      localizable-attr1="{{model.custom.localizable-attr1}}"
                      localizable-attr2="{{model.custom.localizable-attr2}}">
      </custom-element>
    </template>
```
```
    // extracted localizable texts in custom-element-user element
    this.model = {
      "custom": {
        "localizable-attr1": "UI Text Label 1",
        "localizable-attr2": "UI Text Label 2"
      }
    }
```

Since dependent elements should be registered prior to a custom element being registered,
the repository can always maintain the complete list of localizable attributes for registered custom elements.

- - -

### Note

The described processes above are for debug builds with runtime localization traversal of templates
by `I18nBehavior`.

For production builds, the build system can perform the same processes at build time so that 
`I18nBehavior` at clients can skip runtime traversal of templates.

- - -

### TODO

Handle and judge JSON object attributes.

@group I18nBehavior
@element i18n-attr-repo
@hero hero.svg
@demo demo/index.html
*/
  Polymer({
    is: 'i18n-attr-repo',

    created: function () {
      this.data = sharedData;

      var customAttributes = window.Polymer.dom(this).querySelector('template#custom');
      // traverse custom attributes repository
      if (customAttributes && !this.hasAttribute('processed')) {
        this._traverseTemplateTree(customAttributes._content || customAttributes.content);
        this.setAttribute('processed', '');
      }

      this._created();
    },

    _created: function () {
      this.data = sharedData;

      if (this.data.__ready__) {
        return; // traverse standard attributes only once
      }
      this.data.__ready__ = true;
      var standardTemplate;
      if (!this.$) {
        var t = window.Polymer.DomModule.import(this.is, 'template');
        standardTemplate = (t._content || t.content).querySelector('template#standard');
      }
      else {
        standardTemplate = this.$.standard;
      }
      this._traverseTemplateTree(standardTemplate._content || standardTemplate.content);
    },

    /**
     * Judge if a specific attribute of an element requires localization.
     *
     * @param {HTMLElement} element Target element.
     * @param {string} attr Target attribute name.
     * @return {string or boolean} true - property, '$' - attribute, false - not targeted, 'type-name' - type name
     */
    isLocalizableAttribute: function (element, attr) {
      var tagName = element.tagName.toLowerCase();
      if (!this.data) {
        this._created();
        this.data = sharedData;
      }
      attr = attr.replace(/\$$/, '');
      if (this.data['any-elements'] &&
          this.data['any-elements'][attr]) {
        return this.data['any-elements'][attr];
      }
      else if (this.data[tagName]) {
        return this.data[tagName]['any-attributes'] ||
               this._getType(element, this.data[tagName][attr]);
      }
      else {
        return false;
      }
    },

    /**
     * Get the type name or '$' for a specific attribute of an element from the attributes repository
     *
     * @param {HTMLElement} element Target element.
     * @param {object} value this.data[tagName][attr]
     * @return {string or boolean} true - property, '$' - attribute, false - not targeted, 'type-name' - type name
     */
    _getType: function (element, value) {
      var selector;
      var result;
      if (typeof value === 'object') {
        for (selector in value) {
          if (selector) {
            if (this._matchAttribute(element, selector)) {
              result = this._getType(element, value[selector]);
              if (result) {
                return result;
              }
            }
          }
        }
        if (value['']) {
          if (this._matchAttribute(element, '')) {
            result = this._getType(element, value['']);
            if (result) {
              return result;
            }
          }
        }
        return false;
      }
      else {
        return value;
      }
    },

    /**
     * Get the type name or '$' for a specific attribute of an element from the attributes repository
     *
     * Format for selectors:
     *  - `attr=value` - Value of `attr` matches Regex `^value$`
     *  - `!boolean-attr` - Boolean attribute does not exist
     *  - `boolean-attr` - Boolean attribute exists with empty value
     *  - empty string `''` - Always matches
     *
     * @param {HTMLElement} element Target element.
     * @param {string} selector Matching condition for target attribute.
     * @return {boolean} true - matching, false - not matching
     */
    _matchAttribute: function (element, selector) {
      var value;
      var match;
      // default ''
      if (selector === '') {
        return true;
      }
      // attr=value Regex ^value$
      match = selector.match(/^([^!=]*)=(.*)$/);
      if (match) {
        if (element.hasAttribute(match[1])) {
          value = element.getAttribute(match[1]);
          return !!value.match(new RegExp('^' + match[2] + '$'));
        }
        else {
          return false;
        }
      }
      // !boolean-attr
      match = selector.match(/^!([^!=]*)$/);
      if (match) {
        return !element.hasAttribute(match[1]);
      }
      // boolean-attr or empty-attr
      match = selector.match(/^([^!=]*)$/);
      if (match) {
        if (element.hasAttribute(match[1])) {
          value = element.getAttribute(match[1]);
          return !value;
        }
        else {
          return false;
        }
      }
      // no matching
      return false;
    },

    /**
     * Comparator for attribute selectors
     *
     * @param {string} s1 selector 1
     * @param {string} s2 selector 2
     * @return {number} comparison result as -1, 0, or 1
     */
    _compareSelectors: function (s1, s2) {
      var name1 = s1.replace(/^!/, '').replace(/=.*$/, '').toLowerCase();
      var name2 = s2.replace(/^!/, '').replace(/=.*$/, '').toLowerCase();
      return name1.localeCompare(name2);
    },

    /**
     * Add a new localizable attribute of an element to the repository.
     *
     * Format for selector values for defining I18N-target attributes:
     *   - `attr1=value1,attr2=value2,boolean-attr,!boolean-attr` - Attribute value matching condition for property
     *   - `attr1=value1,attr2=value2,$` - Attribute value matching condition for attribute
     *   - `boolean-attr=` - Boolean attribute condition
     *   - `attr1=value1,type` - Attribute value condition with type name (type is currently ineffective)
     *
     * @param {string} element Target element name.
     * @param {string} attr Target attribute name.
     * @param {?*} value Selector value
     */
    setLocalizableAttribute: function (element, attr, value) {
      this.data[element] = this.data[element] || {};
      var cursor = this.data[element];
      var prev = attr;
      var type = true;
      var selectors = [];

      if (typeof value === 'string' && value) {
        selectors = value.split(',');
        if (selectors[selectors.length - 1].match(/^[^!=][^=]*$/)) {
          type = selectors.pop();
        }
        selectors = selectors.map(function (selector) {
          return selector.replace(/=$/, '');
        });
        selectors.sort(this._compareSelectors);
        while (selectors[0] === '') {
          selectors.shift();
        }
      }

      selectors.forEach(function (selector, index) {
        if (typeof cursor[prev] !== 'object') {
          cursor[prev] = cursor[prev] ? { '': cursor[prev] } : {};
        }
        cursor[prev][selector] = cursor[prev][selector] || {};
        cursor = cursor[prev];
        prev = selector;
      });

      if (typeof cursor[prev] === 'object' &&
          cursor[prev] &&
          Object.keys(cursor[prev]).length) {
        cursor = cursor[prev];
        prev = '';
      }
      cursor[prev] = type;
    },

    /**
     * Pick up localizable attributes description for a custom element 
     * from `text-attr` attribute and register them to the repository.
     * The `text-attr` attribute is used in the template of a custom
     * element to declare localizable attributes of its own element.
     *
     * Format:
     *
     *  Type 1: `<template text-attr="localizable-attr1 attr2">`
     *
     *  Type 2: `<template text-attr localizable-attr1 attr2="value2">`
     *
     * @param {string} element Target element name.
     * @param {HTMLTemplateElement} template Template of the element.
     */
    registerLocalizableAttributes: function (element, template) {
      if (!this.data) {
        this._created();
        this.data = sharedData;
      }
      if (!element) {
        element = template.getAttribute('id');
      }
      if (element) {
        var attrs = (template.getAttribute('text-attr') || '').split(' ');
        var textAttr = false;
        attrs.forEach(function (attr) {
          if (attr) {
            this.setLocalizableAttribute(element, attr, true);
          }
        }, this);
        Array.prototype.forEach.call(template.attributes, function (attr) {
          switch (attr.name) {
          case 'id':
          case 'lang':
          case 'localizable-text':
          case 'assetpath':
            break;
          case 'text-attr':
            textAttr = true;
            break;
          default:
            if (textAttr) {
              this.setLocalizableAttribute(element, attr.name, attr.value);
            }
            break;
          }
        }.bind(this));
      }
    },

    /**
     * Traverse the template of `i18n-attr-repo` in the ready() callback
     * and construct the localizable attributes repository object. The method calls itself
     * recursively for traversal.
     *
     * @param {HTMLElement} node The target HTML node for traversing.
     */    
    _traverseTemplateTree: function (node) {
      var name;
      if (node.nodeType === node.ELEMENT_NODE) {
        name = node.nodeName.toLowerCase();
        Array.prototype.forEach.call(node.attributes, function (attribute) {
          this.data[name] = this.data[name] || {};
          this.setLocalizableAttribute(name, attribute.name, attribute.value);
        }, this);
      }
      if (node.childNodes.length > 0) {
        for (var i = 0; i < node.childNodes.length; i++) {
          this._traverseTemplateTree(node.childNodes[i]);
        }
      }
    }
  });
})();
</script>
<i18n-attr-repo></i18n-attr-repo>

<script>/*!
 * @license deepcopy.js Copyright(c) 2013 sasa+1
 * https://github.com/sasaplus1/deepcopy.js
 * Released under the MIT license.
 */
!function(t,e){"object"==typeof exports&&"object"==typeof module?module.exports=e():"function"==typeof define&&define.amd?define([],e):"object"==typeof exports?exports.deepcopy=e():t.deepcopy=e()}(this,function(){return function(t){function e(o){if(n[o])return n[o].exports;var r=n[o]={exports:{},id:o,loaded:!1};return t[o].call(r.exports,r,r.exports,e),r.loaded=!0,r.exports}var n={};return e.m=t,e.c=n,e.p="",e(0)}([function(t,e,n){"use strict";t.exports=n(3)},function(t,e){"use strict";function n(t,e){if("[object Array]"!==o.call(t))throw new TypeError("array must be an Array");var n=void 0,r=void 0,u=void 0;for(n=0,r=t.length;r>n;++n)if(u=t[n],u===e||u!==u&&e!==e)return n;return-1}e.__esModule=!0;var o=Object.prototype.toString,r="undefined"!=typeof Buffer?function(t){return Buffer.isBuffer(t)}:function(){return!1},u="function"==typeof Object.keys?function(t){return Object.keys(t)}:function(t){var e=typeof t;if(null===t||"function"!==e&&"object"!==e)throw new TypeError("obj must be an Object");var n=[],o=void 0;for(o in t)Object.prototype.hasOwnProperty.call(t,o)&&n.push(o);return n},i="function"==typeof Symbol?function(t){return Object.getOwnPropertySymbols(t)}:function(){return[]};e.getKeys=u,e.getSymbols=i,e.indexOf=n,e.isBuffer=r},function(t,e,n){"use strict";function o(t,e){var n=u(t);return null!==n?n:r(t,e)}function r(t,e){if("function"!=typeof e)throw new TypeError("customizer is must be a Function");if("function"==typeof t){var n=String(t);return/^\s*function\s*\S*\([^\)]*\)\s*{\s*\[native code\]\s*}/.test(n)?t:new Function("return "+String(n))()}var o=c.call(t);if("[object Array]"===o)return[];if("[object Object]"===o&&t.constructor===Object)return{};if("[object Date]"===o)return new Date(t.getTime());if("[object RegExp]"===o){var r=String(t),u=r.lastIndexOf("/");return new RegExp(r.slice(1,u),r.slice(u+1))}if((0,i.isBuffer)(t)){var f=new Buffer(t.length);return t.copy(f),f}var l=e(t);return void 0!==l?l:null}function u(t){var e=typeof t;return null!==t&&"object"!==e&&"function"!==e?t:null}e.__esModule=!0,e.copyValue=e.copyCollection=e.copy=void 0;var i=n(1),c=Object.prototype.toString;e.copy=o,e.copyCollection=r,e.copyValue=u},function(t,e,n){"use strict";function o(t){}function r(t){var e=arguments.length<=1||void 0===arguments[1]?o:arguments[1];if(null===t)return null;var n=(0,i.copyValue)(t);if(null!==n)return n;var r=(0,i.copyCollection)(t,e),c=null!==r?r:t,f=[t],l=[c];return u(t,e,c,f,l)}function u(t,e,n,o,r){if(null===t)return null;var f=(0,i.copyValue)(t);if(null!==f)return f;var l=(0,c.getKeys)(t).concat((0,c.getSymbols)(t)),p=void 0,s=void 0,a=void 0,y=void 0,d=void 0,v=void 0,b=void 0,j=void 0;for(p=0,s=l.length;s>p;++p)a=l[p],y=t[a],d=(0,c.indexOf)(o,y),v=void 0,b=void 0,j=void 0,-1===d?(v=(0,i.copy)(y,e),b=null!==v?v:y,null!==y&&/^(?:function|object)$/.test(typeof y)&&(o.push(y),r.push(b))):j=r[d],n[a]=j||u(y,e,b,o,r);return n}e.__esModule=!0;var i=n(2),c=n(1);e["default"]=r,t.exports=e["default"]}])});</script>

<script>
/* jshint -W100 */
(function(document) {
  'use strict';

  var html = document.querySelector('html');
  if (window.ShadowDOMPolyfill) {
    // Fix #38. Add reflectToAttribute effect on html.lang property
    // for supplementing Shadow DOM MutationObserver polyfill
    Object.defineProperty(html, 'lang', {
      get: function () {
        return this.getAttribute('lang');
      },
      set: function (value) {
        this.setAttribute('lang', value);
      }
    });
  }

  // Safari 7 predefines non-configurable standard properties
  // Note: They become configurable with ShadowDOMPolyfill, which wraps them.
  var isStandardPropertyConfigurable = (function () {
    var langPropertyDescriptor = Object.getOwnPropertyDescriptor(document.createElement('span'), 'lang');
    return !langPropertyDescriptor || langPropertyDescriptor.configurable;
  })();
  // Polymer 1.4.0 on Safari 7 inserts extra unexpected whitepace node at the beginning of template
  var extraWhiteSpaceNode = !isStandardPropertyConfigurable;
  if (Polymer.ElementMixin) {
    isStandardPropertyConfigurable = false;
  }

  // app global bundle storage
  var bundles = { '': {} }; // with an empty default bundle
  // app global default language
  var defaultLang = html.hasAttribute('lang') ? html.getAttribute('lang') : '';
  // shared fetching instances for bundles
  var bundleFetchingInstances = {};

  // path for start URL
  var startUrl = (function () {
    var path = window.location.pathname;
    if (document.querySelector('meta[name=app-root]') &&
        document.querySelector('meta[name=app-root]').getAttribute('content')) {
      // <meta name="app-root" content="/"> to customize application root
      path = document.querySelector('meta[name=app-root]').getAttribute('content');
    }
    else if (document.querySelector('link[rel=manifest]') &&
             document.querySelector('link[rel=manifest]').getAttribute('href') &&
             document.querySelector('link[rel=manifest]').getAttribute('href').match(/^\//)) {
      // assume manifest is located at the application root folder
      path = document.querySelector('link[rel=manifest]').getAttribute('href');
    }
    return path.replace(/\/[^\/]*$/,'/');
  })();

  // path for locales from <html locales-path="locales">
  var localesPath = html.hasAttribute('locales-path') ? 
                      html.getAttribute('locales-path') : 'locales';

  // Support ShadowDOM V1 on Polymer 2.x
  var paramAttribute = Polymer.ElementMixin ? 'slot' : 'param';

  var attributesRepository = ((!window.HTMLImports || HTMLImports.hasNative || HTMLImports.useNative) ? document.currentScript : (document._currentScript || document.currentScript))
    .ownerDocument.querySelector('i18n-attr-repo');

  // set up userPreference
  var userPreference = document.querySelector('i18n-preference');
  if (!userPreference) {
    userPreference = document.createElement('i18n-preference');
    // append to body
    document.querySelector('body').appendChild(userPreference);
  }

  // debug log when <html debug> attribute exists
  var debuglog = html.hasAttribute('debug') ?
    function (arg) {
      console.log(arg);
    } :
    function () {};

  window.BehaviorsStore = window.BehaviorsStore || {};
  /**
   * Apply `BehaviorsStore.I18nControllerBehavior` to manipulate internal variables for I18N
   *
   * Note: This behavior is not for normal custom elements to apply I18N. UI is not expected.
   */
  BehaviorsStore.I18nControllerBehavior = {
    properties: {

      /**
       * Flag for detection of `I18nControllerBehavior`
       *
       * `true` if I18nControllerBehavior is applied
       *
       * Note: Module-specific JSON resources are NOT fetched for `I18nControllerBehavior`
       */
      isI18nController: {
        type: Boolean,
        value: true,
        readOnly: true
      },

      /**
       * HTML element object for the current document
       */
      html: {
        type: Object,
        value: html
      },

      /**
       * Master bundles object for storing all the localized and default resources
       */
      masterBundles: {
        type: Object,
        value: bundles
      },

      /**
       * Default lang for the document, i.e., the initial value of `<html lang>` attribute
       */
      defaultLang: {
        type: String,
        value: defaultLang,
        readOnly: true
      },

      /**
       * List of elements which are fetching bundles
       */
      bundleFetchingInstances: {
        type: Object,
        value: bundleFetchingInstances
      },

      /**
       * Root URL path of the application ends with '/' to fetch bundles
       */
      startUrl: {
        type: String,
        value: startUrl,
        readOnly: true
      },

      /**
       * Path for locales
       *
       * Default value is `'locales'`
       */
      localesPath: {
        type: String,
        value: localesPath,
        readOnly: true
      },

      /**
       * <i18n-attr-repo> element to store attributes repository
       */
      attributesRepository: {
        type: Object,
        value: attributesRepository,
        readOnly: true
      },

      /**
       * <i18n-preference> element
       */
      userPreference: {
        type: Object,
        value: userPreference,
        readOnly: true
      }
    }
  };
  /**
   * Apply `BehaviorsStore.I18nBehavior` to implement localizable elements.
   *
   *     <dom-module id="custom-element">
   *       <template>
   *         <span>Hard-coded UI texts are automatically made localizable</span>
   *       </template>
   *       <﻿﻿script﻿﻿>
   *         Polymer({
   *           is: 'custom-element',
   *           behaviors: [ 
   *             BehaviorsStore.I18nBehavior  // Add this behavior
   *           ]
   *         });
   *       <﻿﻿/script﻿﻿>
   *     </dom-module>
   *
   * `I18nBehavior` automatically extracts UI texts from `template` and 
   * binds them to localizable variables in `this.text` object.
   *
   * According to the `lang` attribute value, `this.text`, and thus the bound UI texts,
   * dynamically mutates by loading localized values from a JSON file in the `locales` directory.
   * By default, `lang` attribute values of all the localizable elements with `I18nBehavior` are
   * automatically updated according to `<html lang>` attribute value.
   *
   * The UI text externalization can be processed at build time as well by `gulp-*` task
   * so that `I18nBehavior` can immediately recognize the extracted texts in JSON and 
   * skip run-time externalization.
   *
   * Run-time externalization is suitable for development and debugging 
   * since the code changes are immediately reflected at reloading without build-time preprocesses.
   * In contrast, build-time externalization is suitable for production builds 
   * since it eliminates run-time externalization overheads.
   * 
   * ### Steps to localize a custom element
   *
   * 1. [JavaScript] Add `BehaviorsStore.I18nBehavior` to `behaviors`
   * 1. [gulp] Add `gulp-*` filter for `custom-element.html` and generate `custom-element.json`
   * 1. [locales] Put `custom-element.lang.json` in `locales` directory
   * 1. [translation] Translate `locales/custom-element.lang.json`
   *
   * - - -
   *
   * ### Directory structure of bundle files
   *
   * Normal bundles (`/element-root/locales/element-name.*.json`) for elements
   * are stored under their root directories.
   *
   * Shared bundles (`/locales/bundle.*.json`) are generated at build time 
   * by merging all the targeted bundles of the localizable elements. 
   *
   * Once the shared bundles are loaded, there should be no need to search for 
   * normal bundles per element unless the element is intentionally excluded 
   * from the shared bundles.
   *
   * ```
   *      /bundle.json 
   *      /locales/bundle.ja.json
   *              /bundle.fr.json
   *              /bundle.zh-Hans.json
   *
   *      /elements/my-list/my-list.json
   *                       /locales/my-list.ja.json
   *                               /my-list.zh-Hans.json
   *
   *               /google-chart-demo/google-chart-demo.json
   *                                 /locales/google-chart-demo.ja.json
   *                                         /google-chart-demo.fr.json
   * ```
   *
   * - - -
   *
   * ### Localizable `<template is="i18n-dom-bind" id="app">` element
   *
   * `<template is="i18n-dom-bind">` template element extends 
   * `<template is="dom-bind">` template element with all the capabilities of 
   * `I18nBehavior`.  
   *
   * The `id` attribute value is used for naming bundle files instead of the element name.
   * 
   * The bundle files are stored at the locales directory under the application root. 
   *
   * ```
   *      /app.json
   *      /locales/app.ja.json
   *              /app.fr.json
   *              /app.zh-Hans.json
   * ```
   *
   * - - -
   *
   * ### TODOs
   *
   * - Support user locale preference per user
   *
   * @polymerBehavior BehaviorsStore.I18nBehavior
   * @group I18nBehavior
   * @hero hero.svg
   * @demo demo/index.html
   */
  BehaviorsStore.I18nBehavior = {

    /**
     * Fired when the text message bundle object (`this.text`) is updated after `this.lang` is changed.
     *
     * @event lang-updated
     */

    /**
     * Fired when a shared bundle is fetched.
     *
     * @event bundle-fetched
     */

    properties: {
      /**
       * The locale of the element.
       * The default value is copied from `<html lang>` attribute of the current page.
       * If `<html lang>` is not specified, `''` is set to use the template default language.
       *
       * The value is synchronized with `<html lang>` attribute of the current page by default.
       *
       * ### Note:
       *  - The value may not reflect the current UI locale until the localized texts are loaded.
       */
      lang: {
        type: String,
        value: defaultLang,
        reflectToAttribute: true,
        observer: '_langChanged'
      },

      /**
       * Text message bundle object for the current locale.
       * The object is shared among all the instances of the same element.
       * The value is updated when `lang-updated` event is fired.
       */
      text: {
        type: Object,
        computed: '_getBundle(lang)'
      },

      /**
       * Data model bundle object for the current locale.
       * The data are bound to localizable attribute values in the element template.
       * The object is cloned from `this.text.model` per instance.
       * The value is NOT automatically updated in sync with `this.text`.
       * 
       * How to manually update the model object when `lang-updated` event is fired:
       * ```
       *     this.model = deepcopy(this.text.model);
       * ```
       */
      model: {
        type: Object,
        notify: true
      },

      /**
       * The locale of the hard-coded texts in the element's template.
       * The read-only value can be specified by the `lang` attribute of the element's `template`.
       * The default value is 'en' if not specified in the `template` element.
       *
       * ```
       *  <dom-module id="custom-element">
       *    <template lang="en">
       *      <span>Hard-coded text in English</span>
       *    </template>
       *  <dom-module>
       * ```
       */
      templateDefaultLang: {
        type: String,
        value: 'en'
      },

      /**
       * The effective locale of the element.
       * The value is updated when the localized texts are loaded and `lang-updated` event is fired.
       */
      effectiveLang: {
        type: String
      },

      /**
       * Boolean flag to synchronize with the value of  `<html lang>` attribute.
       */
      observeHtmlLang: {
        type: Boolean,
        value: true,
        observer: '_observeHtmlLangChanged'
      }
    },

    listeners: {
      'lang-updated': '_updateEffectiveLang'
    },

    /* 
       bundles = 
       {
        "": {},
        "en": {
          "my-list": {
            "p_2": "You now have:",
            "model": {
              "list": {
                "items": [
                  "item 1", "item 2"
                ]
              }
            }
          },
          "google-chart-demo": {
            "simple-chart-desc": [
              "template {1} string", "param 1"
            ]
            "model": {
              "simple-chart": {
                "options": { "title": "Simple Chart" },
                "rows": []
              }
            }
          }
        },
        "ja": {
          "my-list": {},
          "google-chart-demo": {}
        }
      }

      bundles[lang]
      /bundle.json - fallback
      /locales/bundle.en.json
              /bundle.ja.json
              /bundle.fr.json
              /bundle.zh-Hans.json

      bundles[lang][is]
      /elements/my-list/my-list.json - fallback
                       /locales/my-list.en.json
                               /my-list.ja.json
                               /my-list.zh-Hans.json

               /google-chart-demo/google-chart-demo.json - fallback
                                 /locales/google-chart-demo.en.json
                                         /google-chart-demo.ja.json
                                         /google-chart-demo.zh-Hans.json

      app/elements/my-list/my-list.json
                          /locales/my-list.fr.json
                                  /my-list.ja.json
                                  /my-list.zh-Hans.json

      dist/elements/my-list/my-list.json
                           /locales/my-list.fr.json
                                   /my-list.ja.json
                                   /my-list.zh-Hans.json

    */


    /**
     * The backend logic for `this.text` object.
     *
     * @param {string} lang Locale for the text message bundle.
     * @return {Object} Text message bundle for the locale.
     */
    _getBundle: function (lang) {
      //console.log('_getBundle called for ' + this.is + ' with lang = ' + lang);

      var resolved;
      var id = this.is === 'i18n-dom-bind' || (Polymer.ElementMixin && this.constructor.is === 'i18n-dom-bind') ? this.id : this.is;

      if (lang && lang.length > 0) {
        var fallbackLanguageList = this._enumerateFallbackLanguages(lang);
        var tryLang;
        while ((tryLang = fallbackLanguageList.shift())) {
          if (!bundles[tryLang]) {
            // set up an empty bundle for the language if missing
            bundles[tryLang] = {};
          }
          if (bundles[tryLang][id]) {
            // bundle found
            resolved = bundles[tryLang][id];
            break;
          }
        }
      }
      else {
        // lang is not specified
        lang = '';
        resolved = bundles[lang][id];
      }

      // Fallback priorities: last > app default > element default > fallback > {}
      // TODO: need more research on fallback priorities
      if (!resolved) { 
        if (this._fetchStatus && bundles[this._fetchStatus.lastLang] && bundles[this._fetchStatus.lastLang][id]) {
          // old bundle for now (no changes should be shown)
          resolved = bundles[this._fetchStatus.lastLang][id]; 
        }
        else if (defaultLang && defaultLang.length > 0 &&
                 bundles[defaultLang] && bundles[defaultLang][id]) {
          // app default language for now
          resolved = bundles[defaultLang][id]; 
        }
        else if (this.templateDefaultLang && this.templateDefaultLang.length > 0 &&
                 bundles[this.templateDefaultLang] && bundles[this.templateDefaultLang][id]) {
          // element default language for now
          resolved = bundles[this.templateDefaultLang][id]; 
        }
        /* no more fallback should happen */
        /* istanbul ignore else */
        else if (bundles[''][id]) {
          // fallback language for now (this should be the same as element default)
          resolved = bundles[''][id];
        }
        else {
          // give up providing a bundle (this should not happen)
          resolved = {};
        }
      }

      return resolved;
    },

    /**
     * Enumerate fallback locales for the target locale.
     * 
     * Subset implementation of BCP47 (https://tools.ietf.org/html/bcp47).
     *
     * ### Examples:
     *
     *| Target Locale | Fallback 1 | Fallback 2 | Fallback 3 |
     *|:--------------|:-----------|:-----------|:-----------|
     *| ru            | N/A        | N/A        | N/A        |
     *| en-GB         | en         | N/A        | N/A        |
     *| en-Latn-GB    | en-GB      | en-Latn    | en         |
     *| fr-CA         | fr         | N/A        | N/A        |
     *| zh-Hans-CN    | zh-Hans    | zh         | N/A        |
     *| zh-CN         | zh-Hans    | zh         | N/A        |
     *| zh-TW         | zh-Hant    | zh         | N/A        |
     *
     * #### Note:
     *
     * For zh language, the script Hans or Hant is supplied as its default script when a country/region code is supplied.
     *
     * @param {string} lang Target locale.
     * @return {Array} List of fallback locales including the target locale at the index 0.
     */
    _enumerateFallbackLanguages: function (lang) {
      var result = [];
      var parts;
      var match;
      var isExtLangCode = 0;
      var extLangCode;
      var isScriptCode = 0;
      var scriptCode;
      var isCountryCode = 0;
      var countryCode;
      var n;
      if (!lang || lang.length === 0) {
        result.push('');
      }
      else {
        parts = lang.split(/[-_]/);
        // normalize ISO-639-1 language codes
        if (parts.length > 0 &&
            parts[0].match(/^[A-Za-z]{2,3}$/)) {
          // language codes have to be lowercased
          // e.g. JA -> ja, FR -> fr
          // TODO: normalize 3-letter codes to 2-letter codes
          parts[0] = parts[0].toLowerCase();
        }
        // normalize ISO-639-3 extension language codes
        if (parts.length >= 2 &&
            parts[1].match(/^[A-Za-z]{3}$/) &&
            !parts[1].match(/^[Cc][Hh][SsTt]$/)) { // exclude CHS,CHT
          // extension language codes have to be lowercased
          // e.g. YUE -> yue
          isExtLangCode = 1;
          extLangCode = parts[1] = parts[1].toLowerCase();
        }
        // normalize ISO-15924 script codes
        if (parts.length >= isExtLangCode + 2 &&
            (match = parts[isExtLangCode + 1].match(/^([A-Za-z])([A-Za-z]{3})$/))) {
          // script codes have to be capitalized only at the first character
          // e.g. HANs -> Hans, lAtN -> Latn
          isScriptCode = 1;
          scriptCode = parts[isExtLangCode + 1] = match[1].toUpperCase() + match[2].toLowerCase();
        }
        // normalize ISO-3166-1 country/region codes
        if (parts.length >= isExtLangCode + isScriptCode + 2 &&
            (match = parts[isExtLangCode + isScriptCode + 1].match(/^[A-Za-z0-9]{2,3}$/))) {
          // country/region codes have to be capitalized
          // e.g. cn -> CN, jP -> JP
          isCountryCode = 1;
          countryCode = parts[isExtLangCode + isScriptCode + 1] = match[0].toUpperCase();
        }
        // extensions have to be in lowercases
        // e.g. U-cA-Buddhist -> u-ca-buddhist, X-LiNux -> x-linux
        if (parts.length >= isExtLangCode + isScriptCode + isCountryCode + 2) {
          for (n = isExtLangCode + isScriptCode + isCountryCode + 1; n < parts.length; n++) {
            parts[n] = parts[n].toLowerCase();
          }
        }
        // enumerate fallback languages
        while (parts.length > 0) {
          // normalize delimiters as -
          // e.g. ja_JP -> ja-JP
          result.push(parts.join('-'));
          if (isScriptCode &&
              isCountryCode &&
              parts.length == isExtLangCode + isScriptCode + 2) {
            // script code can be omitted to default
            // e.g. en-Latn-GB -> en-GB, zh-Hans-CN -> zh-CN
            parts.splice(isExtLangCode + isScriptCode, 1);
            result.push(parts.join('-'));
            parts.splice(isExtLangCode + isScriptCode, 0, scriptCode);
          }
          if (isExtLangCode &&
              isCountryCode &&
              parts.length == isExtLangCode + isScriptCode + 2) {
            // ext lang code can be omitted to default
            // e.g. zh-yue-Hans-CN -> zh-Hans-CN
            parts.splice(isExtLangCode, 1);
            result.push(parts.join('-'));
            parts.splice(isExtLangCode, 0, extLangCode);
          }
          if (isExtLangCode &&
              isScriptCode &&
              parts.length == isExtLangCode + isScriptCode + 1) {
            // ext lang code can be omitted to default
            // e.g. zh-yue-Hans -> zh-Hans
            parts.splice(isExtLangCode, 1);
            result.push(parts.join('-'));
            parts.splice(isExtLangCode, 0, extLangCode);
          }
          if (!isScriptCode &&
              !isExtLangCode &&
              isCountryCode &&
              parts.length == 2) {
            // default script code can be added in certain cases with country codes
            // e.g. zh-CN -> zh-Hans-CN, zh-TW -> zh-Hant-TW
            switch (result[result.length - 1]) {
            case 'zh-CN':
            case 'zh-CHS':
              result.push('zh-Hans');
              break;
            case 'zh-TW':
            case 'zh-SG':
            case 'zh-HK':
            case 'zh-CHT':
              result.push('zh-Hant');
              break;
            default:
              break;
            }
          }
          parts.pop();
        }
      }
      return result;
    },

    /**
     * Get the next fallback locale for the target locale.
     * 
     * Subset implementation of BCP47 (https://tools.ietf.org/html/bcp47).
     *
     * ### Examples:
     *
     *| Target Locale | Next Fallback |
     *|:--------------|:--------------|
     *| ru            | null          |
     *| en-GB         | en            |
     *| fr-CA         | fr            |
     *| zh-Hans-CN    | zh-Hans       |
     *
     * @param {string} lang Target locale.
     * @return {string} Next fallback locale. `null` if there are no fallback languages.
     */
    /*
    _getNextFallbackLanguage: function (lang) {
      var fallbackLanguageList = this._enumerateFallbackLanguages(lang);
      fallbackLanguageList.shift();
      var nextFallbackLanguage = fallbackLanguageList.shift();
      return nextFallbackLanguage ? nextFallbackLanguage : null;
    },
    */

    /**
     * MutationObserver callback of `lang` attribute for Safari 7
     *
     * @param {Array} mutations Array of MutationRecord (https://developer.mozilla.org/en-US/docs/Web/API/MutationObserver).
     */
    _handleLangAttributeChange: function (mutations) {
      mutations.forEach(function(mutation) {
        switch (mutation.type) {
        case 'attributes':
          if (mutation.attributeName === 'lang') {
            //console.log('_handleLangAttributeChange lang = ' + this.lang + ' oldValue = ' + mutation.oldValue +
            //            ' typeof oldValue = ' + typeof mutation.oldValue);
            if (!(typeof mutation.oldValue === 'object' && !mutation.oldValue) &&
                mutation.oldValue !== this.lang) {
              if (this._lang !== mutation.oldValue) {
                //console.log('assigning this._lang = ' + mutation.oldValue + ' from old value');
                this._lang = mutation.oldValue;
              }
              //console.log('assigning this._lang = ' + this.lang);
              this._lang = this.lang;
            }
            else if (mutation.oldValue != this.lang && this._lang !== this.lang) {
              //console.log('assigning this._lang = ' + this.lang);
              this._lang = this.lang;
            }
          }
          break;
        default:
          /* istanbul ignore next: mutation.type is always attributes */
          break;
        }
      }, this);
    },

    /**
     * Observer of `this.lang` changes.
     *
     * Update `this.text` object if the text message bundle of the new `lang` is locally available.
     *
     * Trigger fetching of the text message bundle of the new `lang` if the bundle is not locally available.
     *
     * @param {string} lang New value of `lang`.
     * @param {string} oldLang Old value of `lang`.
     */
    _langChanged: function (lang, oldLang) {
      //console.log(this.id + ':_langChanged lang = ' + lang + ' oldLang = ' + oldLang);
      var id = (this.is || this.getAttribute('is')) === 'i18n-dom-bind' ? this.id : this.is;
      lang = lang || ''; // undefined and null are treated as default ''
      oldLang = oldLang || '';
      if (lang !== oldLang &&
          bundles[oldLang] && bundles[oldLang][id]) {
        this._fetchStatus.lastLang = oldLang;
      }
      if (bundles[lang] && bundles[lang][id]) {
        // bundle available for the new language
        if (this._fetchStatus && lang !== this._fetchStatus.ajaxLang) {
          // reset error status
          this._fetchStatus.error = null;
        }
        if (!Polymer.ElementMixin || (Polymer.ElementMixin && this.__data)) {
          this.notifyPath('text', this._getBundle(this.lang));
        }
        this.effectiveLang = lang;
        this.fire('lang-updated', { 
          lang: this.lang, 
          oldLang: oldLang, 
          lastLang: this._fetchStatus.lastLang 
        });
      }
      else {
        // fetch the missing bundle
        this._fetchLanguage(lang);
      }
    },

    /**
     * Called on `lang-updated` events and update `this.effectiveLang` with the value of `this.lang`.
     */
    _updateEffectiveLang: function (event) {
      if (Polymer.dom(event).rootTarget === this) {
        //console.log('_updateEffectiveLang: lang = ' + this.lang);
        this.effectiveLang = this.lang;
      }
    },

    /**
     * Trigger fetching of the appropriate text message bundle of the target locale.
     *
     * ### Two Layers of Fallbacks:
     *
     * 1. Missing bundles fall back to those of their fallback locales.
     * 1. Missing texts in the non-default bundles fall back to those in the default bundle. 
     *
     * ### Fallback Examples:
     *
     *| Locale      | Bundle Status                    |
     *|:------------|:---------------------------------|
     *| fr-CA       | existent with sparse texts       |
     *| fr          | existent with full texts         |
     *| ja          | existent with some missing texts |
     *| zh-Hans-CN  | missing                          |
     *| zh-Hans     | existent with some missing texts |
     *| zh          | missing                          |
     *| en          | existent with full texts         |
     *| ''(default) | existent with full texts         |
     *
     *| Target      | Fallback bundle       | Resolved locale |
     *|:------------|:----------------------|:----------------|
     *| en          | en                    | en              |
     *| ja          | ja + ''(default)      | ja              |
     *| fr-CA       | fr-CA + fr            | fr-CA           |
     *| zh-Hans-CN  | zh-Hans + ''(default) | zh-Hans         |
     *
     * @param {string} lang Target locale.
     */
    _fetchLanguage: function (lang) {
      if (this._fetchStatus) {
        this._fetchStatus.fallbackLanguageList = this._enumerateFallbackLanguages(lang);
        this._fetchStatus.fallbackLanguageList.push('');
        this._fetchStatus.targetLang = this._fetchStatus.fallbackLanguageList.shift();
        this._fetchBundle(this._fetchStatus.targetLang);
      }
    },

    /**
     * Fetch the text message bundle of the target locale 
     * cooperatively with other instances.
     *
     * @param {string} lang Target locale.
     */
    _fetchBundle: function (lang) {
      //console.log('_fetchBundle lang = ' + lang);
      if (!lang || lang.length === 0) {
        // handle empty cases
        if (defaultLang && defaultLang.length > 0) {
          lang = defaultLang; // app default language
        }
        else if (this.templateDefaultLang && this.templateDefaultLang.length > 0) {
          lang = this.templateDefaultLang; // element default language
        }
        else {
          lang = ''; // fallback default language
        }
      }

      // set up an empty bundle if inexistent
      bundles[lang] = bundles[lang] || {};
      var id = this.is === 'i18n-dom-bind' || (Polymer.ElementMixin && this.constructor.is === 'i18n-dom-bind') ? this.id : this.is;

      if (bundles[lang][id]) {
        // bundle is available; no need to fetch
        if (this._fetchStatus.targetLang === lang) {
          // reset error status
          this._fetchStatus.error = null;
          if (this.lang === lang) {
            this.notifyPath('text', this._getBundle(this.lang));
            this.fire('lang-updated', { 
              lang: this.lang, 
              lastLang: this._fetchStatus.lastLang
            });
          }
          else {
            this.lang = lang; // trigger lang-updated event
          }
        }
        else {
          var nextFallbackLanguage = this._fetchStatus.fallbackLanguageList.shift();
          // bundle is available; no need to fetch
          this._fetchStatus.fetchingInstance = null;
          if (nextFallbackLanguage) {
            this._fetchBundle(nextFallbackLanguage);
          }
          else {
            this._constructBundle(this._fetchStatus.targetLang);
            // reset error status
            this._fetchStatus.error = null;
            if (this.lang === this._fetchStatus.targetLang) {
              this.notifyPath('text', this._getBundle(this.lang));
              this.fire('lang-updated', { 
                lang: this.lang,
                lastLang: this._fetchStatus.lastLang
              });
            }
            else {
              this.lang = this._fetchStatus.targetLang; // trigger lang-updated event
            }
          }
        }
      }
      else if (this._fetchStatus.fetchingInstance) {
        if (this._fetchStatus.fetchingInstance !== this) {
          // fetching in progress by another instance
          // TODO: redundant addEventListener multiple times
          this._forwardLangEventBindThis = this._forwardLangEventBindThis ||
                                            this._forwardLangEvent.bind(this);
          this._fetchStatus.fetchingInstance
              .addEventListener('lang-updated', this._forwardLangEventBindThis);
        }
      }
      else if (bundleFetchingInstances[lang]) {
        // fetching bundle.lang.json in progress by an instance of another element
        this._fetchStatus.fetchingInstance = this;
        this._fetchStatus.ajaxLang = lang;
        this._handleBundleFetchedBindThis = this._handleBundleFetchedBindThis ||
                                            this._handleBundleFetched.bind(this);
        bundleFetchingInstances[lang]
          .addEventListener('bundle-fetched', this._handleBundleFetchedBindThis);
        //console.log(this.is + ' addEventListener bundle-fetched');
      }
      else {
        // proceed to fetch
        this._fetchStatus.fetchingInstance = this;
        if (!this._fetchStatus.ajax) {
          // set up ajax client
          this._fetchStatus.ajax = Polymer.Base.create('iron-ajax');
          this._fetchStatus.ajax.handleAs = 'json';
          this._fetchStatus._handleResponseBindFetchingInstance = this._handleResponse.bind(this);
          this._fetchStatus._handleErrorBindFetchingInstance = this._handleError.bind(this);
          this._fetchStatus.ajax.addEventListener('response', this._fetchStatus._handleResponseBindFetchingInstance);
          this._fetchStatus.ajax.addEventListener('error', this._fetchStatus._handleErrorBindFetchingInstance);
        }
        else {
          if (this._fetchStatus._handleResponseBindFetchingInstance) {
            this._fetchStatus.ajax.removeEventListener('response', this._fetchStatus._handleResponseBindFetchingInstance);
          }
          if (this._fetchStatus._handleErrorBindFetchingInstance) {
            this._fetchStatus.ajax.removeEventListener('error', this._fetchStatus._handleErrorBindFetchingInstance);
          }
          this._fetchStatus._handleResponseBindFetchingInstance = this._handleResponse.bind(this);
          this._fetchStatus._handleErrorBindFetchingInstance = this._handleError.bind(this);
          this._fetchStatus.ajax.addEventListener('response', this._fetchStatus._handleResponseBindFetchingInstance);
          this._fetchStatus.ajax.addEventListener('error', this._fetchStatus._handleErrorBindFetchingInstance);
        }
        // TODO: app global bundles have to be handled
        var url;
        var skipFetching = false;

        if (lang === '') {
          url = this.resolveUrl(id + '.json');
        }
        else {
          if (bundles[lang] && bundles[lang].bundle) {
            // missing in the bundle
            url = this.resolveUrl(localesPath + '/' + id + '.' + lang + '.json');
            skipFetching = !!this.isI18nController;
          }
          else {
            // fetch the bundle
            bundleFetchingInstances[lang] = this;
            url = this.resolveUrl(startUrl + localesPath + '/bundle.' + lang + '.json');
          }
        }
        this._fetchStatus.ajax.url = url;
        this._fetchStatus.ajaxLang = lang;
        try {
          this._fetchStatus.error = null;
          if (skipFetching) {
            this._handleError({ detail: { error: 'skip fetching for I18nController' }});
          }
          else {
            this._fetchStatus.ajax.generateRequest();
          }
        }
        catch (e) {
          // TODO: extract error message from the exception e
          this._handleError({ detail: { error: 'ajax request failed: ' + e }});
        }
      }
    },

    /**
     * Handle Ajax success response for a bundle.
     *
     * @param {Object} event `iron-ajax` success event.
     */
    _handleResponse: function (event) {
      //console.log('_handleResponse ajaxLang = ' + this._fetchStatus.ajaxLang);
      if (this._fetchStatus.ajax.url.indexOf('/' + localesPath + '/bundle.') >= 0) {
        bundles[this._fetchStatus.ajaxLang] = bundles[this._fetchStatus.ajaxLang] || {};
        this._deepMap(bundles[this._fetchStatus.ajaxLang],
                      event.detail.response,
                      function (text) { return text; });
        bundles[this._fetchStatus.ajaxLang].bundle = true;
        bundleFetchingInstances[this._fetchStatus.ajaxLang] = null;
        //console.log('bundle-fetched ' + this.is + ' ' + this._fetchStatus.ajaxLang);
        this.fire('bundle-fetched', { success: true, lang: this._fetchStatus.ajaxLang });
        var id = this.is === 'i18n-dom-bind' ? this.id : this.is;
        if (bundles[this._fetchStatus.ajaxLang][id]) {
          this._fetchStatus.lastResponse = bundles[this._fetchStatus.ajaxLang][id];
        }
        else {
          // bundle does not contain text for this.is
          this._fetchStatus.fetchingInstance = null;
          this._fetchBundle(this._fetchStatus.ajaxLang);
          return;
        }
      }
      else {
        this._fetchStatus.lastResponse = event.detail.response;
      }
      if (this._fetchStatus.lastResponse) {
        var nextFallbackLanguage = this._fetchStatus.fallbackLanguageList.shift();
        // store the raw response
        this._fetchStatus.rawResponses[this._fetchStatus.ajaxLang] = 
          this._fetchStatus.lastResponse;

        this._fetchStatus.fetchingInstance = null;
        if (nextFallbackLanguage) {
          this._fetchBundle(nextFallbackLanguage);        
        }
        else {
          this._fetchBundle('');
        }
      }
      else {
        event.detail.error = 'empty response for ' + this._fetchStatus.ajax.url;
        this._handleError(event);
      }
    },

    /**
     * Handle Ajax error response for a bundle.
     *
     * @param {Object} event `iron-ajax` error event.
     */
    _handleError: function (event) {
      var nextFallbackLanguage;
      this._fetchStatus.fetchingInstance = null;
      if (this._fetchStatus.ajax.url.indexOf('/' + localesPath + '/bundle.') >= 0) {
        bundles[this._fetchStatus.ajaxLang] = bundles[this._fetchStatus.ajaxLang] || {};
        bundles[this._fetchStatus.ajaxLang].bundle = true;
        bundleFetchingInstances[this._fetchStatus.ajaxLang] = null;
        // falls back to its element-specific bundle
        this._fetchBundle(this._fetchStatus.ajaxLang);
        //console.log('bundle-fetched ' + this.is + ' ' + this._fetchStatus.ajaxLang);
        this.fire('bundle-fetched', { success: false, lang: this._fetchStatus.ajaxLang });
        return;
      }
      nextFallbackLanguage = this._fetchStatus.fallbackLanguageList.shift();
      if (this._fetchStatus.ajaxLang === this._fetchStatus.targetLang) {
        if (nextFallbackLanguage) {
          //console.log(this.is + ': ' + this._fetchStatus.ajaxLang +
          //            ' falls back to ' + nextFallbackLanguage);
          this._fetchStatus.targetLang = nextFallbackLanguage;
          this._fetchBundle(nextFallbackLanguage);
        }
        else {
          this._fetchStatus.error = event.detail.error;
          //console.log(this._fetchStatus.error);
          // falls back to default
          this.lang = '';
        }
      }
      else {
        // fetching dependent fallback languages
        if (nextFallbackLanguage) {
          //console.log(this.is + ': ' + this._fetchStatus.ajaxLang +
          //            ' is missing and skipped');
          //console.log(this.is + ': step to the next dependent fallback ' +
          //            nextFallbackLanguage);
          this._fetchBundle(nextFallbackLanguage);
        }
        else {
          this._fetchBundle('');
        }
      }
    },

    /**
     * Forward `lang-updated` event to other instances of the same element.
     *
     * @param {Object} event `lang-updated` event object.
     */
    _forwardLangEvent: function (event) {
      //console.log('_forwardLangEvent ' + this.is + ' ' + event.detail.lang);
      event.target.removeEventListener(event.type, this._forwardLangEventBindThis);
      if (this.lang === event.detail.lang) {
        this.notifyPath('text', this._getBundle(this.lang));
        this.fire(event.type, event.detail);
      }
      else {
        this.lang = event.detail.lang;
        this.notifyPath('text', this._getBundle(this.lang));
      }
    },

    /**
     * Handle `bundle-fetched` event.
     *
     * @param {Object} event `bundle-fetched` event object.
     */
    _handleBundleFetched: function (event) {
      var detail = event.detail;
      //console.log('_handleBundleFetched ' + this.is + ' ' + detail.lang);
      event.target.removeEventListener(event.type, this._handleBundleFetchedBindThis);
      if (this._fetchStatus.ajaxLang === detail.lang) {
        this._fetchStatus.fetchingInstance = null;
        this._fetchBundle(this._fetchStatus.ajaxLang);
      }
    },

    /**
     * Handle changes of `observeHtmlLang` property.
     *
     * @param {Boolean} value Value of `observeHtmlLang`
     */
    _observeHtmlLangChanged: function (value) {
      if (value) {
        this._htmlLangObserver = this._htmlLangObserver || 
          new MutationObserver(this._handleHtmlLangChange.bind(this));
        this._htmlLangObserver.observe(html, { attributes: true });
      }
      else {
        if (this._htmlLangObserver) {
          this._htmlLangObserver.disconnect();
        }
      }
    },

    /**
     * MutationObserver callback of `<html lang>` attribute.
     *
     * @param {Array} mutations Array of MutationRecord (https://developer.mozilla.org/en-US/docs/Web/API/MutationObserver).
     */
    _handleHtmlLangChange: function (mutations) {
      mutations.forEach(function(mutation) {
        switch (mutation.type) {
        case 'attributes':
          if (mutation.attributeName === 'lang') {
            this.lang = html.lang;
          }
          break;
        default:
          break;
        }
      }, this);
    },

    /**
     * Construct the text message bundle of the target locale with fallback of missing texts.
     *
     * @param {strings} lang Target locale.
     */
    _constructBundle: function (lang) {
      var fallbackLanguageList = this._enumerateFallbackLanguages(lang);
      var bundle = {};
      var raw;
      var baseLang;
      var id = this.is === 'i18n-dom-bind' ? this.id : this.is;
      var i;
      fallbackLanguageList.push('');
      for (i = 0; i < fallbackLanguageList.length; i++) {
        if (bundles[fallbackLanguageList[i]] &&
            bundles[fallbackLanguageList[i]][id]) {
          break;
        }
      }
      fallbackLanguageList.splice(i + 1, fallbackLanguageList.length);
      while ((baseLang = fallbackLanguageList.pop()) !== undefined) {
        if (bundles[baseLang][id]) {
          bundle = deepcopy(bundles[baseLang][id]);
        }
        else {
          raw = this._fetchStatus.rawResponses[baseLang];
          if (raw) {
            this._deepMap(bundle, raw, function (text) { return text; });
          }
        }
      }
      // store the constructed bundle
      if (!bundles[lang]) {
        bundles[lang] = {};
      }
      bundles[lang][id] = bundle;
    },

    /**
     * Construct a pseudo-bundle for the target locale. (Not used for now)
     *
     * @param {string} lang Target locale.
     */
    /*
    _constructPseudoBundle: function (lang) {
      var bundle = {};
      var id = this.is === 'i18n-dom-bind' ? this.id : this.is;
      this._deepMap(bundle, bundles[''][id], function (value) {
        return typeof value === 'string' ? lang + ' ' + value : value;
      });
      bundles[lang] = bundles[lang] || {};
      bundles[lang][id] = bundle;
      return bundle;
    },
    */

    /**
     * Recursively map the source object onto the target object with the specified map function.
     * 
     * The method is used to merge a bundle into its fallback bundle.
     *
     * @param {Object} target Target object.
     * @param {Object} source Source object.
     * @param {Function} map Mapping function.
     */
    _deepMap: function (target, source, map) {
      var value;
      for (var prop in source) {
        value = source[prop];
        switch (typeof value) {
        case 'string':
        case 'number':
        case 'boolean':
          if (typeof target === 'object') {
            target[prop] = map(value, prop);
          }
          break;
        case 'object':
          if (typeof target === 'object') {
            if (Array.isArray(value)) {
              // TODO: cannot handle deep objects properly
              target[prop] = target[prop] || [];
              this._deepMap(target[prop], value, map);
            }
            else {
              target[prop] = target[prop] || {};
              this._deepMap(target[prop], value, map);
            }
          }
          break;
        default:
          if (typeof target === 'object') {
            target[prop] = value;
          }
          break;
        }
      }
    },

    /**
     * Construct the default bundle from the element's template.
     *
     * Extract the default bundle from the template if it is embedded as JSON at build time.
     *
     * ### Hard-coded UI text example:
     * ```
     *   <dom-module id="custom-element">
     *     <template>
     *       <span id="label">UI Text Label:</span>
     *       <input id="input-el"
     *              value="{{keyword}}"
     *              placeholder="Keyword">
     *     </template>
     *   </dom-module>
     * ```
     *
     * ### Constructed default bundle for the above example:
     * ```
     *   {
     *     "model" : {
     *       "input-el": {
     *         "placeholder": "Keyword"
     *       }
     *     },
     *     "label": "UI Text Label:"
     *   }
     * ```
     *
     * ### Processed template with bound annotations for the above example:
     * ```
     *   <dom-module id="custom-element">
     *     <template localizable-text="embedded">
     *       <span id="label">{{text.label}}</span>
     *       <input id="input-el"
     *         value="{{keyword}}"
     *         placeholder="{{model.input-el.placeholder}}">
     *     </template>
     *   </dom-module>
     * ```
     *
     * ### Embedded JSON bundle format for the above example:
     * ```
     *   <dom-module id="custom-element">
     *     <template localizable-text="embedded">
     *       <span id="label">{{text.label}}</span>
     *       <input id="input-el"
     *         value="{{keyword}}"
     *         placeholder="{{model.input-el.placeholder}}">
     *       <template id="localizable-text">
     *         <json-data>{
     *           "model" : {
     *             "input-el": {
     *               "placeholder": "Keyword"
     *             }
     *           },
     *           "label": "UI Text Label:"
     *         }</json-data>
     *       </template>
     *     </template>
     *   </dom-module>
     * ```
     */
    _constructDefaultBundle: function (_template, _id) {
      var template;
      var id = _id || this.is;
      if (this.is === 'i18n-dom-bind') {
        template = _template || this;
        id = this.id;
        /* istanbul ignore if */
        if (template.content && template.content.childNodes.length === 0) {
          // Find the real template in Internet Explorer 11 when i18n-dom-bind is concealed in a parent template
          // This does not happen on Polymer 1.3.1 or later.  So ignore this 'if' statement in code coverage.
          template = Array.prototype.map.call(document.querySelectorAll('template'), function (parentTemplate) {
            return parentTemplate.content.querySelector('template#' + id + '[is="i18n-dom-bind"]');
          }).reduce(function (prev, current) {
            return prev || current;
          });
          // Patch this.content with the real one
          if (template) {
            this.content = template.content;
          }
        }
      }
      else {
        template = _template || Polymer.DomModule.import(id, 'template');
      }
      if (template) {
        this.templateDefaultLang = template.hasAttribute('lang') ? template.lang : 'en';
      }
      else {
        this.templateDefaultLang = 'en';
      }
      var bundle = { model: {} };
      var path = [];
      var templateDefaultLang = this.templateDefaultLang;
      var localizableText, jsonData;

      if (template) {
        // register localizable attributes of the element itself
        if (attributesRepository.registerLocalizableAttributes) {
          attributesRepository.registerLocalizableAttributes(id, template);
        }
        else {
          BehaviorsStore._I18nAttrRepo._created();
          BehaviorsStore._I18nAttrRepo.registerLocalizableAttributes(id, template);
        }
        if (template.getAttribute('localizable-text') === 'embedded') {
          // pick up embedded JSON from the template
          localizableText = template.content.querySelector('#localizable-text');
          if (localizableText) {
            jsonData = localizableText.content.querySelector('json-data');
            if (jsonData) {
              bundle = JSON.parse(jsonData.textContent);
            }
            else {
              console.error('<json-data> not found in <template id=\"localizable-text\">');
            }
          }
          else {
            console.error('<template id=\"localizable-text\"> not found');
          }
        }
        else {
          if (extraWhiteSpaceNode) {
            template.setAttribute('strip-whitespace', '');
          }
          // traverse template to generate bundle
          this._traverseTemplateTree(template.content, path, bundle, 0);
        }
      }

      bundles[''][id] = bundle;
      bundles[templateDefaultLang] = bundles[templateDefaultLang] || {};
      bundles[templateDefaultLang][id] = bundle;
      //console.log('text = ');
      //console.log(JSON.stringify(bundle, null, 2));

      return true;
    },

    /**
     * Traverse localizable attributes of the target element node and 
     * add them to the target bundle under the `model` object.
     * 
     * The `<i18n-attr-repo>` object is used 
     * to judge if the target attributes are localizable.
     *
     * @param {Object} node Target element node.
     * @param {string} path Path to the target node.
     * @param {Object} bundle Default bundle.
     */
    _traverseAttributes: function (node, path, bundle) {
      var name = node.nodeName.toLowerCase();
      var id = node.getAttribute ?
                 (node.getAttribute('text-id') ||
                  node.getAttribute('id')) : null;
      var text;
      var messageId;
      var attrId;
      var isLocalizable;
      var dummy;
      // pick up element attributes
      Array.prototype.forEach.call(node.attributes, function (attribute) {
        text = attribute.value;
        switch (attribute.name) {
        case 'id':
        case 'text-id':
        case 'is':
        case 'lang':
        case 'class':
        // verification required before removing these attributes
        case 'href':
        case 'src':
        case 'style':
        case 'url':
        case 'selected':
          break;
        default:
          if (!(isLocalizable = BehaviorsStore._I18nAttrRepo.isLocalizableAttribute(node, attribute.name))) {
            break;
          }
          if (text.length === 0) {
            // skip empty value attribute
          }
          else if (text.match(/^{{[^{}]*}}$/) || text.match(/^\[\[[^\[\]]*\]\]$/)) {
            // skip annotation attribute
          }
          else if (text.replace(/\n/g, ' ').match(/^{.*}|\[.*\]$/g) &&
                  !text.match(/^{{[^{}]*}}|\[\[[^\[\]]*\]\]/) &&
                  !text.match(/{{[^{}]*}}|\[\[[^\[\]]*\]\]$/)) {
            // generate message id
            messageId = this._generateMessageId(path, id);
            try {
              //console.log(messageId + ' parsing attribute ' + attribute.name + ' = ' + text);
              var value = JSON.parse(text.replace(/\n/g, ' '));
              //console.log('parsed JSON object = ');
              //console.log(value);
              switch (typeof value) {
              case 'string':
              case 'number':
              case 'object':
                // put into model
                attrId = ['model', messageId, attribute.name].join('.');
                debuglog(attrId + ' = ' + text);
                this._setBundleValue(bundle, attrId, value);
                attribute.value = '{{' + attrId + '}}';
                break;
              default: // skip other types
                break;
              }
            }
            catch (e) {
              // invalid JSON
              console.warn(e, 'Invalid JSON at <' + name + ' ' + attribute.name + '> with value = ' + text);
            }
          }
          else if (text.match(/{{[^{}]{1,}}}|\[\[[^\[\]]{1,}\]\]/)) {
            // compound binding attribute
            // Parameterized:
            //   e.g., attr="Compound binding attribute has [[bound.value]] {{parameters}} in the value string"
            //   replaced as "{{i18nFormat(attrId.0,bound.value,parameters)}}"
            //   extracted as [ "Compound binding attribute has {1} {2} in the value string", "[[bound.value]]", "{{parameters}}" ]
            // Concatenated: (Parameters with functions cannot be reordered in translation)
            //   e.g., attr2="Compound binding attribute has [[f1(bound.value)]] {{f2(parameters)}} in the value string"
            //   replaced as "{{attrId.0}}[[f1(bound.value)]]{{attrId.2}}{{f2(parameters)}}{{attrId.4}}"
            //   extracted as [ "Compound binding attribute has ", "[[f1(bound.value)]]", " ", "{{f2(parameters)}}", " in the value string" ]
            var parsed = text.match(/([^{}\[\]]{1,})|({{[^{}]{1,}}})|(\[\[[^\[\]]{1,}\]\])/g);
            var parameterized;
            var processed;
            var n;
            messageId = this._generateMessageId(path, id);
            attrId = ['model', messageId, attribute.name.replace(/\$$/, '')].join('.');
            if (text.match(/\)}}|\)\]\]/)) { // check for function parameter
              // Concatenate
              debuglog(attrId + ' = ' + JSON.stringify(parsed));
              this._setBundleValue(bundle, attrId, parsed);
              processed = '';
              for (n = 0; n < parsed.length; n++) {
                if (parsed[n].match(/^{{[^{}]{1,}}}|\[\[[^\[\]]{1,}\]\]$/)) {
                  processed += parsed[n];
                }
                else {
                  processed += '{{' + attrId + '.' + n + '}}';
                }
              }
              if (isLocalizable === '$' && !attribute.name.match(/\$$/)) {
                dummy = document.createElement('span');
                dummy.innerHTML = '<span ' + attribute.name + '$="' + processed + '"></span>';
                node.setAttributeNode(dummy.childNodes[0].attributes[0].cloneNode());
              }
              else {
                attribute.value = processed;
              }
            }
            else {
              // Parameterize
              parameterized = [ '' ];
              while (parsed.length) {
                if (parsed[0].match(/^{{[^{}]{1,}}}|\[\[[^\[\]]{1,}\]\]$/)) {
                  parameterized.push(parsed[0]);
                  parameterized[0] += '{' + (parameterized.length - 1) + '}';
                }
                else {
                  parameterized[0] += parsed[0];
                }
                parsed.shift();
              }
              debuglog(attrId + ' = ' + JSON.stringify(parameterized));
              this._setBundleValue(bundle, attrId, parameterized);
              processed = '{{i18nFormat(' + attrId + '.0';
              for (n = 1; n < parameterized.length; n++) {
                processed += ',' + parameterized[n].replace(/^[{\[][{\[](.*)[}\]][}\]]$/, '$1');
              }
              processed += ')}}';
              if (isLocalizable === '$' && !attribute.name.match(/\$$/)) {
                dummy = document.createElement('span');
                dummy.innerHTML = '<span ' + attribute.name + '$="' + processed + '"></span>';
                node.setAttributeNode(dummy.childNodes[0].attributes[0].cloneNode());
              }
              else {
                attribute.value = processed;
              }
            }
          }
          else {
            // string attribute
            messageId = this._generateMessageId(path, id);
            attrId = ['model', messageId, attribute.name].join('.');
            debuglog(attrId + ' = ' + text);
            this._setBundleValue(bundle, attrId, text);
            if (isLocalizable === '$' && !attribute.name.match(/\$$/)) {
              dummy = document.createElement('span');
              dummy.innerHTML = '<span ' + attribute.name + '$=' + '"{{' + attrId + '}}"' + '></span>';
              node.setAttributeNode(dummy.childNodes[0].attributes[0].cloneNode());
            }
            else {
              attribute.value = '{{' + attrId + '}}';
            }
          }
          break;
        }
      }, this);
    },

    /**
     * Recursively traverse text contents of the target element node
     * and add them to the target bundle object.
     *
     * Traversed text contents are replaced with annotations 
     * for the corresponding text in the bundle.
     *
     * - - -
     *
     * There are some special treatments in the following cases.
     *
     * ### Sentence with parameterized child parameter-like elements:
     *
     * As the order of the parameters can change in different languages,
     * `<i18n-format>` element is used to make the sentence localizable.
     *
     * ### Before processing
     *
     * ```
     *   <p id="p"><code>i18n-format</code> is 
     *     used for  
     *     <a href="https://www.google.com">parameterized</a> 
     *     sentences.</p>
     * ```
     *
     * ### After processing
     *
     * ```
     *   <p id="p">
     *     <i18n-format lang="{{effectiveLang}}">
     *       <span>{{text.p.0}}</span>
     *       <code>{{text.p.1}}</code>
     *       <a href="https://www.google.com">{{text.p.2}}</a>
     *     </i18n-format>
     *   </p>
     * ```
     *
     * ### Constructed bundle data: Texts are stored in an Array of strings.
     *
     * ```
     *   {
     *     "p" : [
     *       "{1} is\n used for\n {2}\n sentences.",
     *       "i18n-format",
     *       "parameterized"
     *     ]
     *   }
     * ```
     *
     * - - -
     *
     * ### `<i18n-format>` element with compound templates:
     *
     * Texts with compound templates for `<i18n-format>` element are
     * processed as below.
     *
     * `lang="{{effectiveLang}}"` attribute is added to `<i18n-format>` node
     * as well as `<i18n-number>` node.
     *
     * ### Before processing
     *
     * ```
     * <i18n-format id="sentence">
     *   <json-data>{
     *     "0": "You ({3}) gave no gifts.",
     *     "1": {
     *       "male": "You ({3}) gave him ({4}) {5}.",
     *       "female": "You ({3}) gave her ({4}) {5}.",
     *       "other": "You ({3}) gave them ({4}) {5}."
     *     },
     *     "one": {
     *       "male": 
     *         "You ({3}) gave him ({4}) and one other {5}.",
     *       "female": 
     *         "You ({3}) gave her ({4}) and one other {5}.",
     *       "other": 
     *         "You ({3}) gave them ({4}) and one other {5}."
     *     },
     *     "other": 
     *       "You ({3}) gave them ({4}) and {1} others gifts."
     *   }</json-data>
     *   <i18n-number 
     *     offset="1"
     *     >{{recipients.length}}</i18n-number>
     *   <span>{{recipients.0.gender}}</span>
     *   <span>{{sender.name}}</span>
     *   <span>{{recipients.0.name}}</span>
     *   <span>a gift</span>
     * </i18n-format>
     * ```
     *
     * ### After processing
     *
     * ```
     * <i18n-format id="sentence" 
     *              lang="{{effectiveLang}}">
     *   <json-data>{{serialize(text.sentence.0)}}</json-data>
     *   <i18n-number 
     *     offset="1"
     *     lang="{{effectiveLang}}"
     *     >{{recipients.length}}</i18n-number>
     *   <span>{{recipients.0.gender}}</span>
     *   <span>{{sender.name}}</span>
     *   <span>{{recipients.0.name}}</span>
     *   <span>{{text.sentence.5}}</span>
     * </i18n-format>
     * ```
     *
     * ### Constructed bundle data:
     *
     * ```
     * {
     *   "sentence" : [
     *     {
     *       "0": "You ({3}) gave no gifts.",
     *       "1": {
     *         "male": "You ({3}) gave him ({4}) {5}.",
     *         "female": "You ({3}) gave her ({4}) {5}.",
     *         "other": "You ({3}) gave them ({4}) {5}."
     *       },
     *       "one": {
     *         "male": 
     *         "You ({3}) gave him ({4}) and one other {5}.",
     *         "female": 
     *         "You ({3}) gave her ({4}) and one other {5}.",
     *         "other": 
     *         "You ({3}) gave them ({4}) and one other {5}."
     *       },
     *       "other": 
     *       "You ({3}) gave them ({4}) and {1} others gifts."
     *     },
     *     "{{recipients.length - 1}}",
     *     "{{recipients.0.gender}}",
     *     "{{sender.name}}",
     *     "{{recipients.0.name}}",
     *     "a gift"
     *   ]
     * }
     * ```
     *
     * @param {Object} node Target element node.
     * @param {string} path Path to the target node.
     * @param {Object} bundle Default bundle.
     * @param {Number} index Index in the siblings of the target node excluding whitespace nodes.
     */
    _traverseTemplateTree: function (node, path, bundle, index) {
      var i;
      var whiteSpaceElements = 0;
      var isWhiteSpace = false;
      var isCompoundAnnotatedNode = false;
      var text;
      var span;
      var name = node.nodeName.toLowerCase();
      var id = node.getAttribute ? 
                 (node.getAttribute('text-id') || 
                  node.getAttribute('id')) : null;
      var messageId;
      var n;
      var templateText;
      var templateTextParams;
      path.push(id ? '#' + id : name + (index > 0 ? '_' + index : ''));
      //console.log(path.join(':'));
      switch (node.nodeType) {
      case node.ELEMENT_NODE:
        switch (name) {
        case 'style':
        case 'script':
        case 'meta':
          // skip
          break;
        case 'i18n-format':
          // pick up element attributes
          this._traverseAttributes(node, path, bundle);
          // generate message id
          messageId = this._generateMessageId(path, id);
          if (!node.hasAttribute('lang')) {
            node.setAttribute('lang', '{{effectiveLang}}');
          }
          text = Array.prototype.filter.call(node.childNodes, function (child) {
            return child.nodeType === child.ELEMENT_NODE;
          }).map(function (param, n) {
            var value = param.textContent;
            var parsedValue = value.match(/^({{)(.*)(}})$/) || 
                              value.match(/^(\[\[)(.*)(\]\])$/);
            if (n === 0) {
              // template element
              if (param.tagName.toLowerCase() === 'json-data') {
                if (parsedValue) {
                  var parsedValue2 = value.match(/^({{)(serialize\(.*\))(}})$/) || 
                                     value.match(/^(\[\[)(serialize\(.*\))(\]\])$/);
                  if (!parsedValue2) {
                    // convert to {{serialize(id)}}
                    parsedValue.shift();
                    parsedValue.splice(1, 0, 'serialize(');
                    parsedValue.splice(3, 0, ')');
                    param.textContent = parsedValue.join('');
                  }
                }
                else {
                  value = JSON.parse(value);
                  param.textContent = '{{serialize(text.' + messageId + '.' + n + ')}}';
                }
              }
              else {
                if (!parsedValue) {
                  param.textContent = '{{text.' + messageId + '.' + n + '}}';
                }
              }
            }
            else {
              // param element
              // TODO: handle localization of param nodes and attributes
              if (!param.hasAttribute(paramAttribute)) {
                param.setAttribute(paramAttribute, n);
              }
              if (param.tagName.toLowerCase() === 'i18n-number') {
                if (!param.hasAttribute('lang')) {
                  param.setAttribute('lang', '{{effectiveLang}}');
                }
                var offset = param.getAttribute('offset');
                if (offset) {
                  offset = ' - ' + offset;
                }
                else {
                  offset = '';
                }
                if (parsedValue) {
                  // convert to {{path - offset}}
                  parsedValue.shift();
                  parsedValue.splice(2, 0, offset);
                  value = parsedValue.join('');
                }
                else {
                  param.textContent = '{{text.' + messageId + '.' + n + '}}';
                }
              }
              else {
                if (!parsedValue) {
                  param.textContent = '{{text.' + messageId + '.' + n + '}}';
                }
              }
            }
            return value;
          }, this);
          debuglog(messageId + ' = ' + text);
          this._setBundleValue(bundle, messageId, text);
          break;
        case 'template':
          // traverse into its content
          //console.log(path.join(':') + ':' + node.content.nodeName + ':' + 0);
          if (extraWhiteSpaceNode) {
            //if (node.hasAttribute('is') && node.getAttribute('is').match(/^(i18n-)?dom-/)) {
              node.setAttribute('strip-whitespace', '');
            //}
          }
          this._traverseTemplateTree(node.content, path, bundle, 0);
          break;
        default:
          // element node
          if (name === 'i18n-number' ||
              name === 'i18n-datetime') {
            if (!node.hasAttribute('lang')) {
              node.setAttribute('lang', '{{effectiveLang}}');
            }
          }
          // pick up element attributes
          this._traverseAttributes(node, path, bundle);
          // check annonated node
          isCompoundAnnotatedNode = false;
          if (node.childElementCount === 0) {
            if (node.textContent) {
              isCompoundAnnotatedNode = this._isCompoundAnnotatedText(node.textContent);
            }
          }
          if (node.childElementCount === 0 && !isCompoundAnnotatedNode) {
            if (node.textContent) { // use textContent for Firefox compatibility
              text = node.textContent;
              if (text.length === 0 || text.match(/^\s*$/g)) {
                // skip empty or whitespace node
              }
              else if (text.trim().match(/^({{[^{}]*}}|\[\[[^\[\]]*\]\])$/)) {
                // skip annotation node
                // TODO: compound bindings support
              }
              else {
                // a text message found
                // generate message id
                messageId = this._generateMessageId(path, id);
                // store the text message
                text = text.replace(/^[\s]*[\s]/, ' ').replace(/[\s][\s]*$/, ' ');
                if (name === 'json-data') {
                  this._setBundleValue(bundle, messageId, JSON.parse(text));
                }
                else {
                  this._setBundleValue(bundle, messageId, text);
                }
                // replace textContent with annotation
                node.textContent = '{{text.' + messageId + '}}';
                if (!id) {
                  //node.id = messageId;
                  //console.warn('add missing node id as ' + messageId + ' for ' + text);
                }
                debuglog(messageId + ' = ' + text);
              }
            }
            else {
              // skip
            }
          } 
          else {
            // has children or compound annotation
            // check if i18n-format is applicable
            var childStatus = Array.prototype.map.call(
              node.childNodes, function (child) {
                var result;
                if (child.nodeType === child.ELEMENT_NODE &&
                    child.tagName === 'TEMPLATE') {
                  var templateNonCommentChildNodes =
                    Array.prototype.filter.call(child.content.childNodes, function (templateChild) {
                      switch (templateChild.nodeType) {
                      case templateChild.COMMENT_NODE:
                        return false;
                      case templateChild.TEXT_NODE:
                        return !templateChild.textContent.match(/^\s*$/g);
                      default:
                      case templateChild.ELEMENT_NODE:
                        return true;
                      }
                    });
                  var firstChild = templateNonCommentChildNodes.shift();
                  // Examples:
                  // hasText: <template>text</template>
                  // hasCompoundAnnotatedText: <template>{{item.name}} text</template>
                  // hasTextChild: <template><b>text</b></template> or <template><br></template>
                  // hasCompoundAnnotatedChildNode: <template><b>{{item.name}} text</b></template>
                  // hasGrandChildren: <template><span><b>text</b></span></template> or 
                  //                   <template><b>A</b><i>B</i></template> or
                  //                   hasCompoundAnnotatedText
                  result = {
                    hasText: templateNonCommentChildNodes.length === 0 &&
                             firstChild &&
                             firstChild.nodeType === firstChild.TEXT_NODE &&
                             firstChild.textContent.length > 0 &&
                             !firstChild.textContent.match(/^\s*$/g),
                    hasCompoundAnnotatedText: firstChild &&
                                              firstChild.nodeType === firstChild.TEXT_NODE &&
                                              this._isCompoundAnnotatedText(firstChild.textContent),
                    hasTextChild: templateNonCommentChildNodes.length === 0 &&
                                  firstChild &&
                                  firstChild.nodeType === child.ELEMENT_NODE &&
                                  firstChild.childElementCount === 0, // including <br>
                    hasCompoundAnnotatedChildNode: firstChild &&
                                                   firstChild.nodeType === firstChild.ELEMENT_NODE &&
                                                   firstChild.childElementCount === 0 &&
                                                   this._isCompoundAnnotatedText(firstChild.textContent),
                    hasGrandChildren: templateNonCommentChildNodes.length > 0 ||
                                      (firstChild &&
                                       firstChild.nodeType === firstChild.ELEMENT_NODE &&
                                        Array.prototype.map.call(
                                          firstChild.childNodes,
                                          function (grandChild) {
                                            return grandChild.nodeType !== grandChild.TEXT_NODE;
                                          }
                                        ).reduce(function (prev, current) {
                                          return prev || current;
                                        }, false)) ||
                                      (firstChild &&
                                       firstChild.nodeType === firstChild.TEXT_NODE &&
                                       this._isCompoundAnnotatedText(firstChild.textContent))
                  };
                }
                else {
                  result = {
                    hasText: child.nodeType === child.TEXT_NODE &&
                             child.textContent.length > 0 &&
                             !child.textContent.match(/^\s*$/g),
                    hasCompoundAnnotatedText: child.nodeType === child.TEXT_NODE &&
                                              this._isCompoundAnnotatedText(child.textContent),
                    hasTextChild: child.nodeType === child.ELEMENT_NODE &&
                                  child.childElementCount === 0, // including <br>
                    hasCompoundAnnotatedChildNode: child.nodeType === child.ELEMENT_NODE &&
                                                   child.childElementCount === 0 &&
                                                   this._isCompoundAnnotatedText(child.textContent),
                    hasGrandChildren: child.nodeType === child.ELEMENT_NODE &&
                                      Array.prototype.map.call(
                                        child.childNodes,
                                        function (grandChild) {
                                          return grandChild.nodeType !== grandChild.TEXT_NODE;
                                        }
                                      ).reduce(function (prev, current) {
                                        return prev || current;
                                      }, false)
                  };
                }
                return result;
              }.bind(this)).reduce(function (prev, current) { 
                return {
                  hasText: prev.hasText || current.hasText,
                  hasCompoundAnnotatedText: prev.hasCompoundAnnotatedText || current.hasCompoundAnnotatedText,
                  hasTextChild: prev.hasTextChild || current.hasTextChild,
                  hasCompoundAnnotatedChildNode: prev.hasCompoundAnnotatedChildNode || current.hasCompoundAnnotatedChildNode,
                  hasGrandChildren: prev.hasGrandChildren || current.hasGrandChildren
                };
              }, { 
                hasText: false, 
                hasCompoundAnnotatedText: false,
                hasTextChild: false,
                hasCompoundAnnotatedChildNode: false,
                hasGrandChildren: false
              });
            if ((childStatus.hasText || node.hasAttribute('text-id')) &&
                (childStatus.hasTextChild || childStatus.hasCompoundAnnotatedText) && 
                !childStatus.hasGrandChildren &&
                !childStatus.hasCompoundAnnotatedChildNode) {
              // apply i18n-format
              /*
                    <i18n-format>
                      <span>{{text.simpleChartDesc.0}}</span>
                      <code param="1">{{text.simpleChartDesc.1}}</code>
                      <a param="2" href="link">{{text.simpleChartDesc.2}}</a>
                      <a param="3" href="link2">{{text.simpleChartDesc.3}}</a>
                    </i18n-format>
              */
              n = 0;
              messageId = this._generateMessageId(path, id);
              templateTextParams = Array.prototype.map.call(
                node.childNodes, function (child) {
                  var firstChild;
                  if (child.nodeType === child.TEXT_NODE &&
                      this._hasAnnotatedText(child.textContent)) {
                    return this._compoundAnnotationToSpan(child)
                      .map(function (_child) {
                        return {
                          node: _child,
                          templateNode: null,
                          type: _child.nodeType,
                          text: _child.nodeType === _child.TEXT_NODE ? 
                                  _child.textContent : null,
                          childTextNode: _child.nodeType === _child.ELEMENT_NODE &&
                                         _child.childNodes.length > 0
                        };
                      });
                  }
                  else if (child.nodeType === child.ELEMENT_NODE &&
                      child.tagName === 'TEMPLATE') {
                    firstChild =
                      Array.prototype.filter.call(child.content.childNodes, function (templateChild) {
                        switch (templateChild.nodeType) {
                        case templateChild.COMMENT_NODE:
                          return false;
                        case templateChild.TEXT_NODE:
                          return !templateChild.textContent.match(/^\s*$/g);
                        default:
                        case templateChild.ELEMENT_NODE:
                          return true;
                        }
                      }).shift();
                    if (!firstChild) {
                      firstChild =
                        Array.prototype.filter.call(child.content.childNodes, function (templateChild) {
                          switch (templateChild.nodeType) {
                          case templateChild.COMMENT_NODE:
                            return false;
                          default:
                            return true;
                          }
                        }).shift();
                    }
                    if (firstChild) {
                      return [{
                        node: firstChild,
                        templateNode: child,
                        type: firstChild.nodeType,
                        text: null,
                        childTextNode: true
                      }];
                    }
                    else {
                      return [];
                    }
                  }
                  else {
                    return [{
                      node: child,
                      templateNode: null,
                      type: child.nodeType,
                      text: child.nodeType === child.TEXT_NODE ? 
                              child.textContent : null,
                      childTextNode: child.nodeType === child.ELEMENT_NODE &&
                                     child.childNodes.length > 0
                    }];
                  }
                }.bind(this)).reduce(function (prev, currentList) {
                  var current;
                  var textContent;
                  for (var i = 0; i < currentList.length; i++) {
                    current = currentList[i];
                    if (current.text) {
                      prev.text[0] += current.text;
                    }
                    if (current.type === current.node.ELEMENT_NODE) {
                      n++;
                      prev.text[0] += '{' + n + '}';
                      path.push(n);
                      this._traverseAttributes(current.node, path, bundle);
                      path.pop();
                      if (current.childTextNode) {
                        textContent = current.node.textContent;
                        if (textContent.length === 0) {
                          // tag without textContent
                          prev.text.push('<' + current.node.nodeName.toLowerCase() + '>');
                          current.node.textContent = '';
                        }
                        else if (textContent.match(/^\s*$/g)) {
                          // tag with whitespace textContent
                          prev.text.push('<' + current.node.nodeName.toLowerCase() + '>');
                          current.node.textContent = ' ';
                        }
                        else if (textContent.match(/^[\s]*({{.*}}|\[\[.*\]\])[\s]*$/)) {
                          // tag with annotation
                          prev.text.push(textContent);
                          // textContent is untouched
                        }
                        else {
                          prev.text.push(current.node.textContent.replace(/^[\s]*[\s]/, ' ').replace(/[\s][\s]*$/, ' '));
                          current.node.textContent = '{{text.' + messageId + '.' + n + '}}';
                        }
                      }
                      else {
                        prev.text.push('<' + current.node.nodeName.toLowerCase() + '>');
                      }
                      current.node.setAttribute(paramAttribute, n.toString());
                      prev.params.push(current.templateNode || current.node);
                    }
                    else if (current.type === current.node.TEXT_NODE &&
                             current.childTextNode) {
                      // in template node
                      n++;
                      prev.text[0] += '{' + n + '}';
                      textContent = current.node.textContent;
                      if (textContent.length === 0) {
                        // template without textContent
                        prev.text.push('<template>');
                        current.node.textContent = '';
                      }
                      else if (textContent.match(/^\s*$/g)) {
                        // template with whitespace textContent
                        prev.text.push('<template>');
                        current.node.textContent = ' ';
                      }
                      else if (textContent.match(/^[\s]*({{.*}}|\[\[.*\]\])[\s]*$/)) {
                        // tag with annotation
                        prev.text.push(textContent);
                        // textContent is untouched
                      }
                      else {
                        prev.text.push(textContent.replace(/^[\s]*[\s]/, ' ').replace(/[\s][\s]*$/, ' '));
                        current.node.textContent = '{{text.' + messageId + '.' + n + '}}';
                      }
                      span = document.createElement('span');
                      span.setAttribute(paramAttribute, n.toString());
                      current.templateNode.content.removeChild(current.node);
                      span.appendChild(current.node);
                      current.templateNode.content.appendChild(span);
                      prev.params.push(current.templateNode);
                    }
                  }
                  return prev;
                }.bind(this), { text: [ '' ], params: [ '{{text.' + messageId + '.0}}' ] });
              // clear original childNodes before implicit removals by appendChild to i18n-format for ShadyDOM compatibility
              if (Polymer.ElementMixin) {
                // Avoid ShadyDOM issue for Polymer 2.x (Implicit removal by appendChild to another element introduces inconsistencies)
                node.innerHTML = '';
              }
              templateText = document.createElement('i18n-format');
              templateText.setAttribute('lang', '{{effectiveLang}}');
              if (Polymer.ElementMixin) {
                // Avoid ShadyDOM issue for Polymer 2.x (Implicit removal by appendChild to another element introduces inconsistencies)
                // insert i18n-format
                Polymer.dom(node).appendChild(templateText);
              }
              span = document.createElement('span');
              // span.innerText does not set an effective value in Firefox
              span.textContent = templateTextParams.params.shift();
              templateText.appendChild(span);
              Array.prototype.forEach.call(templateTextParams.params,
                function (param) {
                  templateText.appendChild(param);
                }
              );
              if (!Polymer.ElementMixin) {
                // Avoid ShadyDOM issue for Polymer 1.x (Clearance of innerHTML unexpectedly removes textContent of child nodes)
                // insert i18n-format
                node.innerHTML = '';
                Polymer.dom(node).appendChild(templateText);
              }
              // store the text message
              templateTextParams.text[0] = templateTextParams.text[0].replace(/^[\s]*[\s]/, ' ').replace(/[\s][\s]*$/, ' ');
              this._setBundleValue(bundle, messageId, templateTextParams.text);
              if (!id) {
                //node.id = messageId;
                //console.warn('add missing node id as ' + messageId + ' for ' + templateTextParams.text[0]);
              }
              debuglog(messageId + ' = ' + templateTextParams.text);
            }
            else {
              // traverse childNodes
              for (i = 0; i < node.childNodes.length; i++) {
                //console.log(path.join(':') + ':' + node.childNodes[i].nodeName + ':' + (i - whiteSpaceElements) + ' i = ' + i + ' whiteSpaceElements = ' + whiteSpaceElements);
                if (this._traverseTemplateTree(node.childNodes[i], path, bundle, i - whiteSpaceElements)) {
                  whiteSpaceElements++;
                }
              }
            }
          }
          break;
        }
        break;
      case node.TEXT_NODE:
        // text node
        text = node.textContent;
        if (text.length === 0 || text.match(/^\s*$/g)) {
          // skip empty or whitespace node
          isWhiteSpace = true;
        }
        else if (text.trim().match(/^({{[^{}]*}}|\[\[[^\[\]]*\]\])$/)) {
          // skip annotation node
        }
        else {
          var parent = node.parentNode;

          if (this._isCompoundAnnotatedText(text)) {
            // apply i18n-format
            n = 0;
            messageId = this._generateMessageId(path, id);
            templateTextParams = Array.prototype.map.call(
              [ node ], function (child) {
                return this._compoundAnnotationToSpan(child)
                  .map(function (_child) {
                    return {
                      node: _child,
                      type: _child.nodeType,
                      text: _child.nodeType === _child.TEXT_NODE ? 
                              _child.textContent : null,
                      childTextNode: _child.nodeType === _child.ELEMENT_NODE &&
                                     _child.childNodes.length > 0
                    };
                  });
              }.bind(this)).reduce(function (prev, currentList) {
                var current;
                for (var i = 0; i < currentList.length; i++) {
                  current = currentList[i];
                  if (current.text) {
                    prev.text[0] += current.text;
                  }
                  if (current.type === current.node.ELEMENT_NODE) {
                    n++;
                    prev.text[0] += '{' + n + '}';
                    path.push(n);
                    this._traverseAttributes(current.node, path, bundle);
                    path.pop();
                    /* current.childTextNode is always true since current.node is <span>{{annotation}}</span> */
                    prev.text.push(current.node.textContent);
                    current.node.setAttribute(paramAttribute, n.toString());
                    prev.params.push(current.node);
                  }
                }
                return prev;
              }.bind(this), { text: [ '' ], params: [ '{{text.' + messageId + '.0}}' ] });
            templateText = document.createElement('i18n-format');
            templateText.setAttribute('lang', '{{effectiveLang}}');
            // insert i18n-format
            Polymer.dom(parent).insertBefore(templateText, node);
            Polymer.dom(parent).removeChild(node);
            span = document.createElement('span');
            // span.innerText does not set an effective value in Firefox
            span.textContent = templateTextParams.params.shift();
            templateText.appendChild(span);
            Array.prototype.forEach.call(templateTextParams.params,
              function (param) {
                templateText.appendChild(param);
              }
            );
            // store the text message
            templateTextParams.text[0] = templateTextParams.text[0].replace(/^[\s]*[\s]/, ' ').replace(/[\s][\s]*$/, ' ');
            this._setBundleValue(bundle, messageId, templateTextParams.text);
            debuglog(messageId + ' = ' + templateTextParams.text);
          }
          else {
            // generate message id
            messageId = this._generateMessageId(path, id);
            // store the text message
            text = text.replace(/^[\s]*[\s]/, ' ').replace(/[\s][\s]*$/, ' ');
            this._setBundleValue(bundle, messageId, text);
            // replace textContent with annotation
            node.textContent = '{{text.' + messageId + '}}';
            if (!id) {
              //span.id = messageId;
              //console.warn('add missing span with id as ' + messageId + ' for ' + text);
            }
            debuglog(messageId + ' = ' + text);
          }
        }
        break;
      case node.DOCUMENT_NODE:
      case node.DOCUMENT_FRAGMENT_NODE:
        // traverse childNodes
        for (i = 0; i < node.childNodes.length; i++) {
          //console.log(path.join(':') + ':' + node.childNodes[i].nodeName + ':' + (i - whiteSpaceElements) + ' i = ' + i + ' whiteSpaceElements = ' + whiteSpaceElements);
          if (this._traverseTemplateTree(node.childNodes[i], path, bundle, i - whiteSpaceElements)) {
            whiteSpaceElements++;
          }
        }
        break;
      default:
        isWhiteSpace = true;
        // comment node, etc.
        break;
      }
      path.pop();
      return isWhiteSpace;
    },

    /**
     * Check if the text has compound annotation 
     * 
     * @param {string} text target text to check compound annotation
     * @return {Boolean} true if the text contains compound annotation
     */
    _isCompoundAnnotatedText: function (text) {
      return !text.trim().match(/^({{[^{}]*}}|\[\[[^\[\]]*\]\])$/) &&
             !!text.match(/({{[^{}]*}}|\[\[[^\[\]]*\]\])/);
    },

    /**
     * Check if the text has annotation 
     * 
     * @param {string} text target text to check annotation
     * @return {Boolean} true if the text contains annotation
     */
    _hasAnnotatedText: function (text) {
      return !!text.match(/({{[^{}]*}}|\[\[[^\[\]]*\]\])/);
    },

    /**
     * Convert compound annotations to span elements
     * 
     * @param {Text} node target text node to convert compound annotations
     * @return {Object[]} Array of Text or span elements
     */
    _compoundAnnotationToSpan: function (node) {
      var result;
      /* istanbul ignore else: node is prechecked to contain annotation(s) */
      if (node.textContent.match(/({{[^{}]*}}|\[\[[^\[\]]*\]\])/)) {
        result = node.textContent
          .match(/({{[^{}]*}}|\[\[[^\[\]]*\]\]|[^{}\[\]]{1,}|[{}\[\]]{1,})/g)
          .reduce(function (prev, current) {
            if (current.match(/^({{[^{}]*}}|\[\[[^\[\]]*\]\])$/)) {
              prev.push(current);
              prev.push('');
            }
            else {
              if (prev.length === 0) {
                prev.push(current);
              }
              else {
                prev[prev.length - 1] += current;
              }
            }
            return prev;
          }.bind(this), [])
          .map(function (item) {
            var childNode;
            if (item.match(/^({{[^{}]*}}|\[\[[^\[\]]*\]\])$/)) {
              childNode = document.createElement('span');
              childNode.textContent = item;
            }
            else if (item) {
              childNode = document.createTextNode(item);
            }
            else {
              childNode = null;
            }
            return childNode;
          });
        if (result.length > 0) {
          if (!result[result.length - 1]) {
            result.pop(); // pop null node for ''
          }
        }
      }
      else {
        // no compound annotation
        result = [ node ];
      }
      return result;
    },

    /**
     * Add the value to the target default bundle with the specified message Id 
     * 
     * @param {Object} bundle Default bundle.
     * @param {string} messageId ID string of the value.
     * @param {Object} value Value of the text message. Normally a string.
     */
    _setBundleValue: function (bundle, messageId, value) {
      var messageIdPath = messageId.split('.');
      bundle.model = bundle.model || {};
      if (messageIdPath.length === 1) {
        bundle[messageId] = value;
      }
      else {
        var cursor = bundle;
        for (var i = 0; i < messageIdPath.length; i++) {
          if (i < messageIdPath.length - 1) {
            cursor[messageIdPath[i]] = cursor[messageIdPath[i]] || {};
            cursor = cursor[messageIdPath[i]];
          }
          else {
            cursor[messageIdPath[i]] = value;
          }
        }
      }
    },

    /**
     * Generate a message ID from the specified path and id.
     * 
     * ### TODO: 
     *
     * - Shorten or optimize ids
     *
     * @param {Array} path List of ascestor elements of the current node in traversal.
     * @param {id} id Value of `id` or `text-id` attribute of the current node.
     */
    _generateMessageId: function (path, id) {
      var messageId;
      if (!id || id.length === 0) {
        for (var i = 1; i < path.length; i++) {
          if (path[i][0] === '#') {
            if (path[i] !== '#document-fragment') {
              if (messageId && path[i].substr(0, 5) === '#text') {
                messageId += ':' + path[i].substr(1);
              }
              else {
                messageId = path[i].substr(1);
              }
            }
          }
          else {
            if (messageId) {
              messageId += ':' + path[i];
            }
            else {
              messageId = path[i];
            }
          }
        }
      }
      else {
        messageId = id;
      }
      return messageId;
    },

    /**
     * Merge `this.defaultText` into the target default bundle.
     * 
     * ### TODO: 
     *
     * - Need more research on the effective usage of this feature.
     *
     * @param {Object} bundle Default bundle.
     */
    /*
    _mergeDefaultText: function (bundle) {
      if (this.defaultText) {
        this._deepMap(bundle, this.defaultText, function (text) { return text; });
      }
    },
    */

    /**
     * Return the first non-null argument.
     *
     * Utility method for use in annotations.
     *
     * ### Example Usage:
     * ```
     *   <input is="iron-input" class="flex"
     *     type="search" id="query" bind-value="{{query}}"
     *     autocomplete="off"
     *     placeholder="{{or(placeholder,text.search)}}">
     * ```
     *
     * @param {*} arguments List of arguments.
     */
    or: function () {
      var result = arguments[0];
      var i = 1;
      while (!result && i < arguments.length) {
        result = arguments[i++];
      }
      return result;
    },


    /**
     * Translate a string by a message table.
     *
     * Utility method for use in annotations.
     *
     * ### Example Usage:
     * ```
     *   <span>{{tr(status,text.statusMsgs)}}</span>
     *   <span>{{tr(errorId,text)}}</span>
     *   <template>
     *     <json-data text-id="statusMsgs">{
     *       "signed-in": "Authenticated",
     *       "signed-out": "Not Authenticated",
     *       "error": "Error in Authentication",
     *       "default": "Unknown Status in Authentication"
     *     }</json-data>
     *     <span text-id="http-404">File Not Found</span>
     *     <span text-id="http-301">Moved Permanently</span>
     *   </template>
     * ```
     *
     * Note: The second `table` parameter should always be specified in order
     * to trigger automatic updates on `this.text` mutations, i.e., updates of `this.effectiveLang`.
     *
     * @param {string} key Key of the message.
     * @param {Object} table The message table object or this.text itself if omitted
     * @return {string} Translated string, `table.default` if `table[key]` is undefined, or key string if table.default is undefined.
     */
    tr: function (key, table) {
      if (table) {
        if (typeof table === 'object') {
          if (typeof table[key] !== 'undefined') {
            return table[key];
          }
          else if (typeof table['default'] !== 'undefined') {
            return table['default'];
          }
          else {
            return key;
          }
        }
        else {
          return key;
        }
      }
      else {
        return (typeof this.text === 'object') &&
               (typeof key !== 'undefined') &&
               (typeof this.text[key] !== 'undefined') ? this.text[key] : key;
      }
    },

    /**
     * Format a parameterized string.
     *
     * Utility method for use in annotations.
     *
     * ### Example Usage:
     * ```
     *   <span attr="{{i18nFormat(text.param.0,text.textparam1,text.textparam2)}}"></span>
     *   <template>
     *     <json-data text-id="param">[
     *       "String with {1} and {2} are formetted",
     *       "[[text.textparam1]]",
     *       "[[text.textparam2]]"
     *     ]</json-data>
     *     <span text-id="textparam1">Parameter 1</span>
     *     <span text-id="textparam2">Parameter 2</span>
     *   </template>
     * ```
     *
     * Note: Compound bindings in attributes are automatically converted to {{i18nFormat()}} in preprocessing.
     *
     * @param {*} arguments List of arguments.
     * @return {string} Formatted string
     */
    i18nFormat: function () {
      if (arguments.length > 0) {
        var formatted = arguments[0] || '';
        for (var n = 1; n < arguments.length; n++) {
          formatted = formatted.replace('{' + n + '}', arguments[n]);
        }
      }
      return formatted;
    },

    // Lifecycle callbacks

    /**
     * Lifecycle callback before registration of the custom element.
     *
     * The default bundle is constructed via traversal of the element's template at this timing per registration.
     *
     * ### Notes: 
     *
     * - For `i18n-dom-bind` elements, bundle construction is put off until `ready` lifecycle callback.
     * - As called twice per custom element registration, the method skips bundle construction at the second call.
     */
    beforeRegister: function () {
      if (this.is !== 'i18n-dom-bind') {
        if (!this._templateLocalizable) {
          this._templateLocalizable = this._constructDefaultBundle();
        }
      }
    },


    /**
     * Lifecycle callback at registration of the custom element.
     *
     * this._fetchStatus is initialized per registration.
     */
    registered: function () {
      if (this.is !== 'i18n-dom-bind') {
        var template = Polymer.DomModule.import(this.is, 'template');
        if (!template) {
          var id = this.is;
          var current = (!window.HTMLImports || HTMLImports.useNative) ? document.currentScript
                                              : (document._currentScript || document.currentScript);
          template = (current ? current.ownerDocument
                      .querySelector('template[id=' + id + ']') : null) ||
                     document.querySelector('template[id=' + id + ']');
          if (!template) {
            template = document.createElement('template');
            template.setAttribute('id', id);
          }
          if (template) {
            var domModule = document.createElement('dom-module');
            var _noTemplateDomModule = Polymer.DomModule.import(this.is);
            var assetpath = _noTemplateDomModule
              ? _noTemplateDomModule.assetpath
              : new URL((current ? current.baseURI : null) ||
                (window.currentImport ? window.currentImport.baseURI : null) ||
                (current && current.ownerDocument ? current.ownerDocument.baseURI : null) ||
                document.baseURI).pathname;
            domModule.appendChild(template);
            domModule.setAttribute('assetpath', 
                                    template.hasAttribute('basepath') ?
                                      template.getAttribute('basepath') :
                                      template.hasAttribute('assetpath') ? 
                                        template.getAttribute('assetpath') : 
                                        assetpath);
            domModule.register(id);
            this._template = template;
          }
          var bundle = { model: {} };
          bundles[''][id] = bundle;
          bundles[defaultLang] = bundles[defaultLang] || {};
          bundles[defaultLang][id] = bundle;
          console.warn('I18nBehavior.registered: ' + id + ' has no template. Supplying an empty template');
        }
        this._fetchStatus = deepcopy({ // per custom element
          fetchingInstance: null,
          ajax: null,
          ajaxLang: null,
          lastLang: null,
          fallbackLanguageList: null,
          targetLang: null,
          lastResponse: {},
          rawResponses: {}
        });
      }
    },

    /**
     * Lifecycle callback on instance creation
     */
    created: function () {
      // Fix #34. [Polymer 1.4.0] _propertyEffects have to be maintained per instance
      if (this.is === 'i18n-dom-bind') {
        this._propertyEffects = deepcopy(this._propertyEffects);
      }
      else {
        var template = Polymer.DomModule.import(this.is, 'template');
        if (template && template.hasAttribute('lang')) {
          this.templateDefaultLang = template.getAttribute('lang') || '';
        }
        if (!this._fetchStatus) {
          this._fetchStatus = deepcopy({ // per custom element
            fetchingInstance: null,
            ajax: null,
            ajaxLang: null,
            lastLang: null,
            fallbackLanguageList: null,
            targetLang: null,
            lastResponse: {},
            rawResponses: {}
          });
        }
      }
      if (!isStandardPropertyConfigurable) {
        // Fix #36. Emulate lang's observer since Safari 7 predefines non-configurable lang property
        this.observer = new MutationObserver(this._handleLangAttributeChange.bind(this));
        this.observer.observe(this, {
          attributes: true,
          attributeFilter: [ 'lang' ],
          attributeOldValue: true
        });
      }
    },

    /**
     * Lifecycle callback when the template children are ready.
     */
    ready: function () {
      if (this.is === 'i18n-dom-bind') {
        if (!this._templateLocalizable) {
          this._templateLocalizable = this._constructDefaultBundle();
        }
        if (!this._fetchStatus) {
          this._fetchStatus = deepcopy({ // per instance
            fetchingInstance: null,
            ajax: null,
            ajaxLang: null,
            lastLang: null,
            fallbackLanguageList: null,
            targetLang: null, 
            lastResponse: {},
            rawResponses: {}
          });
        }
        this._onDomChangeBindThis = this._onDomChange.bind(this);
        this.addEventListener('dom-change', this._onDomChangeBindThis);
        // Fix #34. [Polymer 1.4.0] Supply an empty object if this.__data__ is undefined
        this.__data__ = this.__data__ || Object.create(null);
      }
      else {
        if (!isStandardPropertyConfigurable) {
          // Fix #36. Patch missing properties except for lang
          for (var p in this._propertyEffects) {
            if (this._propertyEffects[p] &&
                !Object.getOwnPropertyDescriptor(this, p)) {
              //console.log('ready: creating accessors for ' + p);
              Polymer.Bind._createAccessors(this, p, this._propertyEffects[p]);
            }
          }
        }
        if (Polymer.ElementMixin && !this.__data) {
          this._initializeProperties();
        }
        this._langChanged(this.getAttribute('lang'), undefined);
        // model per instance
        if (this.text) {
          this.model = deepcopy(this.text.model);
        }
      }
    },

    /**
     * attached lifecycle callback.
     */
    attached: function () {
      if (this.is === 'i18n-dom-bind') {
        if (this._properties) {
          // Fix #35. [IE10] Restore properties for use in rendering
          this.properties = this._properties;
          delete this._properties;
        }
      }
      if (this.observeHtmlLang) {
        this.lang = html.lang;
        // TODO: this call is redundant
        this._observeHtmlLangChanged(true);
      }
    },

    /**
     * Handle `dom-change` event for `i18n-dom-bind`
     */
    _onDomChange: function () {
      // Fix #16: [IE11][Polymer 1.3.0] On IE11, i18n-dom-bind does not work with Polymer 1.3.0
      // Patch the broken lang property accessors manually if it is missing
      // Fix #34: [IE11][Polymer 1.4.0] Create missing property accessors including lang
      for (var p in this._propertyEffects) {
        if (this._propertyEffects[p] &&
            !Object.getOwnPropertyDescriptor(this, p)) {
          Polymer.Bind._createAccessors(this, p, this._propertyEffects[p]);
        }
      }
      this.removeEventListener('dom-change', this._onDomChangeBindThis);
      if (this.text && this.text.model) {
        this.model = deepcopy(this.text.model);
      }
      // Fix #17: [Polymer 1.3.0] observeHtmlLang is undefined in i18n-dom-bind
      // Explicitly initialize observeHtmlLang if the value is undefined.
      if (typeof this.observeHtmlLang === 'undefined' &&
          !this.hasAttribute('observe-html-lang')) {
        this.observeHtmlLang = true;
      }
      if (this.observeHtmlLang) {
        this.lang = html.lang;
        this._observeHtmlLangChanged(true);
      }
    },

    /**
     * detached lifecycle callback
     */
    detached: function () {
      if (this.observeHtmlLang) {
        this._observeHtmlLangChanged(false);
      }
    }
  };

  // Fix #36. Rename lang property as _lang to avoid conflict with the predefined lang property
  if (!isStandardPropertyConfigurable) {
    var _properties = Object.create(null);
    for (var p in BehaviorsStore.I18nBehavior.properties) {
      if (p === 'lang') {
        _properties._lang = BehaviorsStore.I18nBehavior.properties.lang;
      }
      else {
        _properties[p] = BehaviorsStore.I18nBehavior.properties[p];
      }
    }
    BehaviorsStore.I18nBehavior.properties = _properties;
    BehaviorsStore.I18nBehavior.properties._lang.reflectToAttribute = false;
    BehaviorsStore.I18nBehavior.properties.text.computed = '_getBundle(_lang)';
    BehaviorsStore.I18nBehavior._updateEffectiveLang = function (event) {
      if ((!Polymer.ElementMixin && Polymer.dom(event).rootTarget === this) ||
          (Polymer.ElementMixin && event.composedPath()[0] === this)) {
        //console.log('lang-updated: _updateEffectiveLang: assigning effectiveLang = ' + this._lang);
        this.effectiveLang = this._lang;
      }
    };
    BehaviorsStore.I18nBehavior.hostAttributes = {
      'lang': defaultLang
    };
  }

  if (Polymer.ElementMixin) {
    // Polymer 2.x
    BehaviorsStore._I18nBehavior = BehaviorsStore.I18nBehavior;
    BehaviorsStore.I18nBehavior = [ BehaviorsStore._I18nBehavior ];
    Object.defineProperty(BehaviorsStore.I18nBehavior, '0', {
      get: function() {
        var current = (!window.HTMLImports || HTMLImports.hasNative || HTMLImports.useNative) ? document.currentScript : (document._currentScript || document.currentScript);
        var ownerDocument = current.ownerDocument;
        if (ownerDocument.nodeType === ownerDocument.DOCUMENT_NODE) {
          // HTML Imports are flatten in the root document and not under document fragment nodes
          // Fix #62: Emulate a subset of "non-HTMLImports-link-traversing" querySelectorAll for latest Firefox 51
          // since currentScript.ownerDocument, HTML Imports polyfill, and querySelectorAll behave differently
          var _tmpNode = current;
          // check for DOCUMENT_FRAGMENT_NODE for fail safe
          while (_tmpNode && _tmpNode.tagName !== 'LINK' &&
            _tmpNode.nodeType !== _tmpNode.DOCUMENT_FRAGMENT_NODE &&
            _tmpNode.nodeType !== _tmpNode.DOCUMENT_NODE) {
            _tmpNode = _tmpNode.parentNode;
          }
          if (_tmpNode &&
            (_tmpNode.nodeType === _tmpNode.DOCUMENT_FRAGMENT_NODE ||
             _tmpNode.nodeType === _tmpNode.DOCUMENT_NODE)) {
            ownerDocument = _tmpNode; // reach the containing document fragment
          }
          else if (_tmpNode && _tmpNode.import === _tmpNode) { // html-imports polyfill v1
            ownerDocument = _tmpNode.children; // reach the immediate import link containing the currentScript
            ownerDocument.querySelectorAll = function (selector) {
              var match = selector.match(/^([a-zA-Z0-9-]{1,})(:not\(\[(processed)\]\))?(\[(legacy)\])?$/);
              var list = [];
              var node;
              var tagName;
              var i;
              for (i = 0; i < this.length; i++) {
                node = this[i];
                tagName = node.tagName.toLowerCase();
                switch (tagName) {
                case 'link':
                  break;
                case match[1]:
                  if (match[2]) {
                    if (!node.hasAttribute(match[3])) {
                      list.push(node);
                    }
                  }
                  else if (match[4]) {
                    if (node.hasAttribute(match[5])) {
                      list.push(node);
                    }
                  }
                  else {
                    list.push(node);
                  }
                  break;
                default:
                  Array.prototype.forEach.call(node.querySelectorAll(selector), function (child) { list.push(child); });
                  break;
                }
              }
              return list;
            }
          }
        }
        var i18nAttrRepos = ownerDocument.querySelectorAll('i18n-attr-repo:not([processed])');
        var domModules = ownerDocument.querySelectorAll('dom-module[legacy]');
        if (domModules.length === 0) {
          domModules = ownerDocument.querySelectorAll('dom-module');
          if (domModules.length !== 1) {
            domModules = [];
          }
        }
        BehaviorsStore._I18nAttrRepo._created();
        Array.prototype.forEach.call(i18nAttrRepos, function (repo) {
          if (!repo.hasAttribute('processed')) {
            var customAttributes = repo.querySelector('template#custom');
            if (customAttributes) {
              BehaviorsStore._I18nAttrRepo._traverseTemplateTree(customAttributes.content || customAttributes._content);
            }
            repo.setAttribute('processed', '');
          }
        });
        Array.prototype.forEach.call(domModules, function (domModule) {
          if (domModule && domModule.id) {
            var template = domModule.querySelector('template');
            if (template) {
              BehaviorsStore._I18nBehavior._constructDefaultBundle(template, domModule.id);
              domModule.removeAttribute('legacy');
            }
          }
        });
        return BehaviorsStore._I18nBehavior;
      }
    });
  }
  else {
    // Polymer 1.x
  /**
   * `<template is="i18n-dom-bind">` element extends `dom-bind` template element with `I18nBehavior`
   *
   * @group I18nBehavior
   * @element i18n-dom-bind
   */
  var i18nBehaviorDomBind = {};
  Polymer.Base.extend(i18nBehaviorDomBind, BehaviorsStore.I18nBehavior);
  var i18nDomBind = {};
  var domBind = document.createElement('template', 'dom-bind');
  var domBindProto = Object.getPrototypeOf(domBind);
  if (typeof domBindProto.render !== 'function') {
    domBindProto = domBind.__proto__; // fallback for IE10
  }
  Polymer.Base.extend(i18nDomBind, domBindProto);
  i18nDomBind.is = 'i18n-dom-bind';
  if (!navigator.language && navigator.browserLanguage) { // Detect IE10
    // Fix #35. [IE10] Hide properties until attached phase in IE10
    // to avoid exceptions in overriding unconfigurable properties in Object.defineProperty
    i18nBehaviorDomBind._properties = i18nBehaviorDomBind.properties;
    i18nBehaviorDomBind.properties = Object.create(null);
  }
  /* As of Polymer 1.3.1, dom-bind does not have predefined behaviors */
  /* istanbul ignore if */
  if (i18nDomBind.behaviors) {
    i18nDomBind.behaviors.push(i18nBehaviorDomBind);
  }
  else {
    i18nDomBind.behaviors = [ i18nBehaviorDomBind ];
  }
  var _Polymer = Polymer;
  _Polymer(i18nDomBind);
  }
})(document);
</script>
<template id="simple-text-element" basepath="simple-text-element/" localizable-text="embedded">{{text.text}}<div><div></div></div>
    <span id="whitespace"> &nbsp; </span>
    <h1>{{text.h1_3}}</h1>{{text.text_4}}<span>{{text.span_5}}</span>
    <span>{{text.span_6}}</span>
    <span id="label-1">{{text.label-1}}</span>
    <span id="label-2">{{text.label-2}}</span>
    <div>
      <span>{{text.div_9:span}}</span> 
      <span>{{text.div_9:span_1}}</span> 
      <div><div>{{text.div_9:div_2:div}}</div></div> 
    </div>
    <div>{{text.div_10:text}}<span>{{text.div_10:span_1}}</span>{{text.div_10:text_2}}<span>{{text.div_10:span_3}}</span>
      <div><div>{{text.div_10:div_4:div}}</div></div>{{text.div_10:text_5}}</div>
    <div id="toplevel-div">
      <span>{{text.toplevel-div:span}}</span>
      <span>{{text.toplevel-div:span_1}}</span>
      <div id="second-level-div">
        <div id="third-level-div">{{text.third-level-div}}</div>
        <div>{{text.second-level-div:div_1}}</div>
      </div>
    </div>
    <div>
      <ul>
        <li>{{text.div_12:ul:li}}</li>
        <li>{{text.div_12:ul:li_1}}</li>
        <li>{{text.div_12:ul:li_2}}</li>
      </ul>
      <ul id="line-items">
        <li>{{text.line-items:li}}</li>
        <li>{{text.line-items:li_1}}</li>
        <li>{{text.line-items:li_2}}</li>
      </ul>
    </div>
    <p><i18n-format lang="{{effectiveLang}}"><span>{{text.p_13.0}}</span><b slot="1">{{text.p_13.1}}</b><code slot="2">{{text.p_13.2}}</code></i18n-format></p>
    <p id="paragraph"><i18n-format lang="{{effectiveLang}}"><span>{{text.paragraph.0}}</span><b slot="1">{{text.paragraph.1}}</b><code slot="2">{{text.paragraph.2}}</code></i18n-format></p>{{text.text_15}}<template id="localizable-text">
<json-data>
{
  "meta": {},
  "model": {},
  "text": " outermost text at the beginning ",
  "h1_3": "outermost header 1",
  "text_4": " outermost text in the middle ",
  "span_5": "simple text without id",
  "span_6": "simple text without id 2",
  "label-1": "simple text with id",
  "label-2": "simple text with id 2",
  "div_9:span": "simple text within div",
  "div_9:span_1": "simple text within div 2",
  "div_9:div_2:div": "great grandchild text within div",
  "div_10:text": " simple text as the first element in div ",
  "div_10:span_1": "simple text within div",
  "div_10:text_2": " simple text in the middle of div ",
  "div_10:span_3": "simple text within div 2",
  "div_10:div_4:div": "great grandchild text within div",
  "div_10:text_5": " simple text at the last element in div ",
  "toplevel-div:span": "simple text within div",
  "toplevel-div:span_1": "simple text within div 2",
  "third-level-div": "great grandchild text within div",
  "second-level-div:div_1": "great grandchild text within div without id",
  "div_12:ul:li": "line item without id 1",
  "div_12:ul:li_1": "line item without id 2",
  "div_12:ul:li_2": "line item without id 3",
  "line-items:li": "line item with id 1",
  "line-items:li_1": "line item with id 2",
  "line-items:li_2": "line item with id 3",
  "p_13": [
    "A paragraph with {1} is converted to {2}.",
    "parameters",
    "&lt;i18n-format&gt;"
  ],
  "paragraph": [
    "A paragraph with {1} is converted to {2}.",
    "id",
    "&lt;i18n-format&gt;"
  ],
  "text_15": " outermost text at the end "
}
</json-data>
</template>
</template>
<dom-module id="simple-text-element" legacy="" assetpath="simple-text-element/">
  <template localizable-text="embedded">{{text.text}}<div><div></div></div>
    <span id="whitespace"> &nbsp; </span>
    <h1>{{text.h1_3}}</h1>{{text.text_4}}<span>{{text.span_5}}</span>
    <span>{{text.span_6}}</span>
    <span id="label-1">{{text.label-1}}</span>
    <span id="label-2">{{text.label-2}}</span>
    <div>
      <span>{{text.div_9:span}}</span> 
      <span>{{text.div_9:span_1}}</span> 
      <div><div>{{text.div_9:div_2:div}}</div></div> 
    </div>
    <div>{{text.div_10:text}}<span>{{text.div_10:span_1}}</span>{{text.div_10:text_2}}<span>{{text.div_10:span_3}}</span>
      <div><div>{{text.div_10:div_4:div}}</div></div>{{text.div_10:text_5}}</div>
    <div id="toplevel-div">
      <span>{{text.toplevel-div:span}}</span>
      <span>{{text.toplevel-div:span_1}}</span>
      <div id="second-level-div">
        <div id="third-level-div">{{text.third-level-div}}</div>
        <div>{{text.second-level-div:div_1}}</div>
      </div>
    </div>
    <div>
      <ul>
        <li>{{text.div_12:ul:li}}</li>
        <li>{{text.div_12:ul:li_1}}</li>
        <li>{{text.div_12:ul:li_2}}</li>
      </ul>
      <ul id="line-items">
        <li>{{text.line-items:li}}</li>
        <li>{{text.line-items:li_1}}</li>
        <li>{{text.line-items:li_2}}</li>
      </ul>
    </div>
    <p><i18n-format lang="{{effectiveLang}}"><span>{{text.p_13.0}}</span><b slot="1">{{text.p_13.1}}</b><code slot="2">{{text.p_13.2}}</code></i18n-format></p>
    <p id="paragraph"><i18n-format lang="{{effectiveLang}}"><span>{{text.paragraph.0}}</span><b slot="1">{{text.paragraph.1}}</b><code slot="2">{{text.paragraph.2}}</code></i18n-format></p>{{text.text_15}}<template id="localizable-text">
<json-data>
{
  "meta": {},
  "model": {},
  "text": " outermost text at the beginning ",
  "h1_3": "outermost header 1",
  "text_4": " outermost text in the middle ",
  "span_5": "simple text without id",
  "span_6": "simple text without id 2",
  "label-1": "simple text with id",
  "label-2": "simple text with id 2",
  "div_9:span": "simple text within div",
  "div_9:span_1": "simple text within div 2",
  "div_9:div_2:div": "great grandchild text within div",
  "div_10:text": " simple text as the first element in div ",
  "div_10:span_1": "simple text within div",
  "div_10:text_2": " simple text in the middle of div ",
  "div_10:span_3": "simple text within div 2",
  "div_10:div_4:div": "great grandchild text within div",
  "div_10:text_5": " simple text at the last element in div ",
  "toplevel-div:span": "simple text within div",
  "toplevel-div:span_1": "simple text within div 2",
  "third-level-div": "great grandchild text within div",
  "second-level-div:div_1": "great grandchild text within div without id",
  "div_12:ul:li": "line item without id 1",
  "div_12:ul:li_1": "line item without id 2",
  "div_12:ul:li_2": "line item without id 3",
  "line-items:li": "line item with id 1",
  "line-items:li_1": "line item with id 2",
  "line-items:li_2": "line item with id 3",
  "p_13": [
    "A paragraph with {1} is converted to {2}.",
    "parameters",
    "&lt;i18n-format&gt;"
  ],
  "paragraph": [
    "A paragraph with {1} is converted to {2}.",
    "id",
    "&lt;i18n-format&gt;"
  ],
  "text_15": " outermost text at the end "
}
</json-data>
</template>
</template>
</dom-module>
<script>
  switch (syntax) {
  default:
  case 'mixin':
    {
      class SimpleTextElement extends Mixins.Localizable(Polymer.LegacyElement) {
        static get is() { return 'simple-text-element' }
        static get config () {
          return {
            listeners: {
              'lang-updated': '_langUpdated'
            }          
          }
        }

        _langUpdated (e) {
          console.log(this.is, 'lang-updated', e.detail);
          if (e.composedPath()[0] === this) {
            this.model = deepcopy(this.text.model);
          }
        }
      }
      customElements.define(SimpleTextElement.is, SimpleTextElement);
    }
    break;
  case 'base-element':
    {
      class SimpleTextElement extends BaseElements.I18nElement {
        static get is() { return 'simple-text-element' }
        static get config () {
          return {
            listeners: {
              'lang-updated': '_langUpdated'
            }          
          }
        }

        _langUpdated (e) {
          console.log(this.is, 'lang-updated', e.detail);
          if (e.composedPath()[0] === this) {
            this.model = deepcopy(this.text.model);
          }
        }
      }
      customElements.define(SimpleTextElement.is, SimpleTextElement);
    }
    break;
  case 'thin':
    {
      Define = class SimpleTextElement extends BaseElements.I18nElement {
        static get config () {
          return {
            listeners: {
              'lang-updated': '_langUpdated'
            }          
          }
        }

        _langUpdated (e) {
          console.log(this.is, 'lang-updated', e.detail);
          if (e.composedPath()[0] === this) {
            this.model = deepcopy(this.text.model);
          }
        }
      };
    }
    break;
  case 'legacy':
    {
      Polymer({
        is: 'simple-text-element',

        behaviors: [
          BehaviorsStore.I18nBehavior
        ],

        listeners: {
          'lang-updated': '_langUpdated'
        },

        ready: function () {
          //this.observeHtmlLang = false;
        },

        attached: function () {
        },

        _langUpdated: function (e) {
          console.log(this.is, 'lang-updated', e.detail);
          if (Polymer.dom(e).rootTarget === this) {
            this.model = deepcopy(this.text.model);
          }
        }
      });
    }
    break;
  }
</script>
<template id="commented-simple-text-element" basepath="commented-simple-text-element/" localizable-text="embedded">{{text.text}}
    <div><div></div></div>
    <span id="whitespace"> &nbsp; </span>
    <h1>{{text.h1_3}}</h1>{{text.text_4}}
    <span>{{text.span_5}}</span>
    <span>{{text.span_6}}</span>
    <span id="label-1">{{text.label-1}}</span>
    <span id="label-2">{{text.label-2}}</span>
    <div>
      <span>{{text.div_9:span}}</span> 
      <span>{{text.div_9:span_1}}</span> 
      <div><div>{{text.div_9:div_2:div}}</div></div> 
    </div>
    
    <div>{{text.div_10:text}}
      <span>{{text.div_10:span_1}}</span>{{text.div_10:text_2}}
      <span>{{text.div_10:span_3}}</span>
      <div><div>{{text.div_10:div_4:div}}</div></div>{{text.div_10:text_5}}</div>
    <div id="toplevel-div">
      <span>{{text.toplevel-div:span}}</span>
      <span>{{text.toplevel-div:span_1}}</span>
      <div id="second-level-div">
        <div id="third-level-div">{{text.third-level-div}}</div>
        <div>{{text.second-level-div:div_1}}</div>
      </div>
    </div>
    <div>
      <ul>
        <li>{{text.div_12:ul:li}}</li>
        <li>{{text.div_12:ul:li_1}}</li>
        <li>{{text.div_12:ul:li_2}}</li>
      </ul>
      <ul id="line-items">
        <li>{{text.line-items:li}}</li>
        <li>{{text.line-items:li_1}}</li>
        <li>{{text.line-items:li_2}}</li>
      </ul>
    </div>
    <p><i18n-format lang="{{effectiveLang}}"><span>{{text.p_13.0}}</span><b slot="1">{{text.p_13.1}}</b><code slot="2">{{text.p_13.2}}</code></i18n-format></p>
    <p id="paragraph"><i18n-format lang="{{effectiveLang}}"><span>{{text.paragraph.0}}</span><b slot="1">{{text.paragraph.1}}</b><code slot="2">{{text.paragraph.2}}</code></i18n-format></p>{{text.text_15}}
  <template id="localizable-text">
<json-data>
{
  "meta": {},
  "model": {},
  "text": " outermost text at the beginning ",
  "h1_3": "outermost header 1",
  "text_4": " outermost text in the middle ",
  "span_5": "simple text without id",
  "span_6": "simple text without id 2",
  "label-1": "simple text with id",
  "label-2": "simple text with id 2",
  "div_9:span": "simple text within div",
  "div_9:span_1": "simple text within div 2",
  "div_9:div_2:div": "great grandchild text within div",
  "div_10:text": " simple text as the first element in div ",
  "div_10:span_1": "simple text within div",
  "div_10:text_2": " simple text in the middle of div ",
  "div_10:span_3": "simple text within div 2",
  "div_10:div_4:div": "great grandchild text within div",
  "div_10:text_5": " simple text at the last element in div ",
  "toplevel-div:span": "simple text within div",
  "toplevel-div:span_1": "simple text within div 2",
  "third-level-div": "great grandchild text within div",
  "second-level-div:div_1": "great grandchild text within div without id",
  "div_12:ul:li": "line item without id 1",
  "div_12:ul:li_1": "line item without id 2",
  "div_12:ul:li_2": "line item without id 3",
  "line-items:li": "line item with id 1",
  "line-items:li_1": "line item with id 2",
  "line-items:li_2": "line item with id 3",
  "p_13": [
    "A paragraph with {1} is converted to {2}.",
    "parameters",
    "&lt;i18n-format&gt;"
  ],
  "paragraph": [
    "A paragraph with {1} is converted to {2}.",
    "id",
    "&lt;i18n-format&gt;"
  ],
  "text_15": " outermost text at the end "
}
</json-data>
</template>
</template>
<dom-module id="commented-simple-text-element" legacy="" assetpath="commented-simple-text-element/">
  <template localizable-text="embedded">{{text.text}}
    <div><div></div></div>
    <span id="whitespace"> &nbsp; </span>
    <h1>{{text.h1_3}}</h1>{{text.text_4}}
    <span>{{text.span_5}}</span>
    <span>{{text.span_6}}</span>
    <span id="label-1">{{text.label-1}}</span>
    <span id="label-2">{{text.label-2}}</span>
    <div>
      <span>{{text.div_9:span}}</span> 
      <span>{{text.div_9:span_1}}</span> 
      <div><div>{{text.div_9:div_2:div}}</div></div> 
    </div>
    
    <div>{{text.div_10:text}}
      <span>{{text.div_10:span_1}}</span>{{text.div_10:text_2}}
      <span>{{text.div_10:span_3}}</span>
      <div><div>{{text.div_10:div_4:div}}</div></div>{{text.div_10:text_5}}</div>
    <div id="toplevel-div">
      <span>{{text.toplevel-div:span}}</span>
      <span>{{text.toplevel-div:span_1}}</span>
      <div id="second-level-div">
        <div id="third-level-div">{{text.third-level-div}}</div>
        <div>{{text.second-level-div:div_1}}</div>
      </div>
    </div>
    <div>
      <ul>
        <li>{{text.div_12:ul:li}}</li>
        <li>{{text.div_12:ul:li_1}}</li>
        <li>{{text.div_12:ul:li_2}}</li>
      </ul>
      <ul id="line-items">
        <li>{{text.line-items:li}}</li>
        <li>{{text.line-items:li_1}}</li>
        <li>{{text.line-items:li_2}}</li>
      </ul>
    </div>
    <p><i18n-format lang="{{effectiveLang}}"><span>{{text.p_13.0}}</span><b slot="1">{{text.p_13.1}}</b><code slot="2">{{text.p_13.2}}</code></i18n-format></p>
    <p id="paragraph"><i18n-format lang="{{effectiveLang}}"><span>{{text.paragraph.0}}</span><b slot="1">{{text.paragraph.1}}</b><code slot="2">{{text.paragraph.2}}</code></i18n-format></p>{{text.text_15}}
  <template id="localizable-text">
<json-data>
{
  "meta": {},
  "model": {},
  "text": " outermost text at the beginning ",
  "h1_3": "outermost header 1",
  "text_4": " outermost text in the middle ",
  "span_5": "simple text without id",
  "span_6": "simple text without id 2",
  "label-1": "simple text with id",
  "label-2": "simple text with id 2",
  "div_9:span": "simple text within div",
  "div_9:span_1": "simple text within div 2",
  "div_9:div_2:div": "great grandchild text within div",
  "div_10:text": " simple text as the first element in div ",
  "div_10:span_1": "simple text within div",
  "div_10:text_2": " simple text in the middle of div ",
  "div_10:span_3": "simple text within div 2",
  "div_10:div_4:div": "great grandchild text within div",
  "div_10:text_5": " simple text at the last element in div ",
  "toplevel-div:span": "simple text within div",
  "toplevel-div:span_1": "simple text within div 2",
  "third-level-div": "great grandchild text within div",
  "second-level-div:div_1": "great grandchild text within div without id",
  "div_12:ul:li": "line item without id 1",
  "div_12:ul:li_1": "line item without id 2",
  "div_12:ul:li_2": "line item without id 3",
  "line-items:li": "line item with id 1",
  "line-items:li_1": "line item with id 2",
  "line-items:li_2": "line item with id 3",
  "p_13": [
    "A paragraph with {1} is converted to {2}.",
    "parameters",
    "&lt;i18n-format&gt;"
  ],
  "paragraph": [
    "A paragraph with {1} is converted to {2}.",
    "id",
    "&lt;i18n-format&gt;"
  ],
  "text_15": " outermost text at the end "
}
</json-data>
</template>
</template>
</dom-module>
<script>
  switch (syntax) {
  default:
  case 'mixin':
    {
      class CommentedSimpleTextElement extends Mixins.Localizable(Polymer.LegacyElement) {
        static get is() { return 'commented-simple-text-element' }
        static get config () {
          return {
            listeners: {
              'lang-updated': '_langUpdated'
            }          
          }
        }

        ready() {
          super.ready();
        }

        _langUpdated (e) {
          console.log(this.is, 'lang-updated', e.detail);
          if (e.composedPath()[0] === this) {
            this.model = deepcopy(this.text.model);
          }
        }
      }
      customElements.define(CommentedSimpleTextElement.is, CommentedSimpleTextElement);
    }
    break;
  case 'base-element':
    {
      class CommentedSimpleTextElement extends BaseElements.I18nElement {
        static get is() { return 'commented-simple-text-element' }
        static get config () {
          return {
            listeners: {
              'lang-updated': '_langUpdated'
            }          
          }
        }

        ready() {
          super.ready();
        }

        _langUpdated (e) {
          console.log(this.is, 'lang-updated', e.detail);
          if (e.composedPath()[0] === this) {
            this.model = deepcopy(this.text.model);
          }
        }
      }
      customElements.define(CommentedSimpleTextElement.is, CommentedSimpleTextElement);
    }
    break;
  case 'thin':
    {
      Define = class CommentedSimpleTextElement extends BaseElements.I18nElement {
        static get config () {
          return {
            listeners: {
              'lang-updated': '_langUpdated'
            }          
          }
        }

        ready() {
          super.ready();
        }

        _langUpdated (e) {
          console.log(this.is, 'lang-updated', e.detail);
          if (e.composedPath()[0] === this) {
            this.model = deepcopy(this.text.model);
          }
        }
      };
    }
    break;
  case 'legacy':
    {
      Polymer({
        is: 'commented-simple-text-element',

        behaviors: [
          BehaviorsStore.I18nBehavior
        ],

        listeners: {
          'lang-updated': '_langUpdated'
        },

        ready: function () {
          //this.observeHtmlLang = false;
        },

        attached: function () {
        },

        _langUpdated: function (e) {
          console.log(this.is, 'lang-updated', e.detail);
          if (Polymer.dom(e).rootTarget === this) {
            this.model = deepcopy(this.text.model);
          }
        }
      });
    }
    break;
  }
</script><template id="plural-gender-element" basepath="plural-gender-element/" localizable-text="embedded">
    <p>
      <i18n-format id="compound-format-text" on-rendered="_rendered" lang="{{effectiveLang}}">
        <json-data>{{serialize(text.compound-format-text.0)}}</json-data>
        <i18n-number offset="1" slot="1" lang="{{effectiveLang}}">{{recipients.length}}</i18n-number>
        <span slot="2">{{recipients.0.gender}}</span>
        <span slot="3">{{sender.name}}</span>
        <span slot="4">{{recipients.0.name}}</span>
        <span slot="5">{{text.compound-format-text.5}}</span>
      </i18n-format>
    </p>
  <template id="localizable-text">
<json-data>
{
  "meta": {},
  "model": {},
  "compound-format-text": [
    {
      "0": "You ({3}) gave no gifts.",
      "1": {
        "male": "You ({3}) gave him ({4}) {5}.",
        "female": "You ({3}) gave her ({4}) {5}.",
        "other": "You ({3}) gave them ({4}) {5}."
      },
      "one": {
        "male": "You ({3}) gave him ({4}) and one other person {5}.",
        "female": "You ({3}) gave her ({4}) and one other person {5}.",
        "other": "You ({3}) gave them ({4}) and one other person {5}."
      },
      "other": "You ({3}) gave them ({4}) and {1} other people gifts."
    },
    "{{recipients.length - 1}}",
    "{{recipients.0.gender}}",
    "{{sender.name}}",
    "{{recipients.0.name}}",
    "a gift"
  ]
}
</json-data>
</template>
</template>
<dom-module id="plural-gender-element" legacy="" assetpath="plural-gender-element/">
  <template localizable-text="embedded">
    <p>
      <i18n-format id="compound-format-text" on-rendered="_rendered" lang="{{effectiveLang}}">
        <json-data>{{serialize(text.compound-format-text.0)}}</json-data>
        <i18n-number offset="1" slot="1" lang="{{effectiveLang}}">{{recipients.length}}</i18n-number>
        <span slot="2">{{recipients.0.gender}}</span>
        <span slot="3">{{sender.name}}</span>
        <span slot="4">{{recipients.0.name}}</span>
        <span slot="5">{{text.compound-format-text.5}}</span>
      </i18n-format>
    </p>
  <template id="localizable-text">
<json-data>
{
  "meta": {},
  "model": {},
  "compound-format-text": [
    {
      "0": "You ({3}) gave no gifts.",
      "1": {
        "male": "You ({3}) gave him ({4}) {5}.",
        "female": "You ({3}) gave her ({4}) {5}.",
        "other": "You ({3}) gave them ({4}) {5}."
      },
      "one": {
        "male": "You ({3}) gave him ({4}) and one other person {5}.",
        "female": "You ({3}) gave her ({4}) and one other person {5}.",
        "other": "You ({3}) gave them ({4}) and one other person {5}."
      },
      "other": "You ({3}) gave them ({4}) and {1} other people gifts."
    },
    "{{recipients.length - 1}}",
    "{{recipients.0.gender}}",
    "{{sender.name}}",
    "{{recipients.0.name}}",
    "a gift"
  ]
}
</json-data>
</template>
</template>
</dom-module>
<script>
  switch (syntax) {
  default:
  case 'mixin':
    {
      class PluralGenderElement extends Mixins.Localizable(Polymer.LegacyElement) {
        static get is() { return 'plural-gender-element' }
        static get config () {
          return {
            properties: {
              sender: {
                type: Object
              },
              recipients: {
                type: Array
              }
            },
            listeners: {
              'lang-updated': '_langUpdated'
            }          
          }
        }

        _langUpdated(e) {
          console.log('plural-gender-element lang-updated lang = ' + this.lang + ' effectiveLang = ' + this.effectiveLang);
          if (e.composedPath()[0] === this) {
            this.model = deepcopy(this.text.model);
          }
          if (this.renderedEffectiveLang === this.effectiveLang ||
              (this.renderedEffectiveLang === '' && this.effectiveLang === 'en')) {
            this.fire('local-dom-ready');
          }
        }

        _rendered() {
          console.log('plural-gender-element rendered lang = ' + this.lang + ' effectiveLang = ' + this.effectiveLang);
          if (this.lang === this.effectiveLang) {
            this.fire('local-dom-ready');
          }
          else {
            this.renderedEffectiveLang = this.effectiveLang;
          }
        }
      }
      customElements.define(PluralGenderElement.is, PluralGenderElement);
    }
    break;
  case 'base-element':
    {
      class PluralGenderElement extends BaseElements.I18nElement {
        static get is() { return 'plural-gender-element' }
        static get config () {
          return {
            properties: {
              sender: {
                type: Object
              },
              recipients: {
                type: Array
              }
            },
            listeners: {
              'lang-updated': '_langUpdated'
            }          
          }
        }

        _langUpdated(e) {
          console.log('plural-gender-element lang-updated lang = ' + this.lang + ' effectiveLang = ' + this.effectiveLang);
          if (e.composedPath()[0] === this) {
            this.model = deepcopy(this.text.model);
          }
          if (this.renderedEffectiveLang === this.effectiveLang ||
              (this.renderedEffectiveLang === '' && this.effectiveLang === 'en')) {
            this.fire('local-dom-ready');
          }
        }

        _rendered() {
          console.log('plural-gender-element rendered lang = ' + this.lang + ' effectiveLang = ' + this.effectiveLang);
          if (this.lang === this.effectiveLang) {
            this.fire('local-dom-ready');
          }
          else {
            this.renderedEffectiveLang = this.effectiveLang;
          }
        }
      }
      customElements.define(PluralGenderElement.is, PluralGenderElement);
    }
    break;
  case 'thin':
    {
      Define = class PluralGenderElement extends BaseElements.I18nElement {
        static get config () {
          return {
            properties: {
              sender: {
                type: Object
              },
              recipients: {
                type: Array
              }
            },
            listeners: {
              'lang-updated': '_langUpdated'
            }          
          }
        }

        _langUpdated(e) {
          console.log('plural-gender-element lang-updated lang = ' + this.lang + ' effectiveLang = ' + this.effectiveLang);
          if (e.composedPath()[0] === this) {
            this.model = deepcopy(this.text.model);
          }
          if (this.renderedEffectiveLang === this.effectiveLang ||
              (this.renderedEffectiveLang === '' && this.effectiveLang === 'en')) {
            this.fire('local-dom-ready');
          }
        }

        _rendered() {
          console.log('plural-gender-element rendered lang = ' + this.lang + ' effectiveLang = ' + this.effectiveLang);
          if (this.lang === this.effectiveLang) {
            this.fire('local-dom-ready');
          }
          else {
            this.renderedEffectiveLang = this.effectiveLang;
          }
        }
      };
    }
    break;
  case 'legacy':
    {
      Polymer({
        is: 'plural-gender-element',

        behaviors: [
          BehaviorsStore.I18nBehavior
        ],

        properties: {
          sender: {
            type: Object
          },
          recipients: {
            type: Array
          }
        },

        listeners: {
          'lang-updated': '_langUpdated'
        },

        _langUpdated: function (e) {
          console.log('plural-gender-element lang-updated lang = ' + this.lang + ' effectiveLang = ' + this.effectiveLang);
          if (e.composedPath()[0] === this) {
            this.model = deepcopy(this.text.model);
          }
          if (this.renderedEffectiveLang === this.effectiveLang ||
              (this.renderedEffectiveLang === '' && this.effectiveLang === 'en')) {
            this.fire('local-dom-ready');
          }
        },

        _rendered: function () {
          console.log('plural-gender-element rendered lang = ' + this.lang + ' effectiveLang = ' + this.effectiveLang);
          if (this.lang === this.effectiveLang) {
            this.fire('local-dom-ready');
          }
          else {
            this.renderedEffectiveLang = this.effectiveLang;
          }
        }
      });
    }
    break;
  }
</script><i18n-attr-repo>
  <template id="custom">
    <text-attribute-element custom-text-attr1=""></text-attribute-element>
    <text-attribute-element custom-text-attr2=""></text-attribute-element>
    <text-attribute-element custom-text-attr3=""></text-attribute-element>
    <text-attribute-element custom-text-attr4="$"></text-attribute-element>
    <text-attribute-element custom-text-attr5="$"></text-attribute-element>
    <text-attribute-element i18n-target=""></text-attribute-element>
    <text-attribute-element i18n-target="boolean-attr,!boolean-attr2,string-attr=abc|def,empty-attr=,type1"></text-attribute-element>
    <text-attribute-element i18n-target="boolean-attr,boolean-attr2,string-attr=aaa,type2"></text-attribute-element>
    <text-attribute-element i18n-target="string-attr=aaa,string-attr2=bbb,type3"></text-attribute-element>
    <text-attribute-element i18n-target="boolean-attr=,type4"></text-attribute-element>
    <text-attribute-element i18n-target2="boolean-attr,!boolean-attr2,string-attr=abc|def,empty-attr=,type1"></text-attribute-element>
    <text-attribute-element i18n-target2="boolean-attr,boolean-attr2,,string-attr=aaa,,type2"></text-attribute-element>
    <text-attribute-element i18n-target2="string-attr=aaa,string-attr2=bbb,type3"></text-attribute-element>
    <text-attribute-element i18n-target2="boolean-attr=,type4"></text-attribute-element>
    <text-attribute-element i18n-target2="type5"></text-attribute-element>
    <text-attribute-element i18n-target3="string-attr=aaa,type1"></text-attribute-element>
    <text-attribute-element i18n-target3=""></text-attribute-element>
    <text-attribute-element i18n-target4=""></text-attribute-element>
    <text-attribute-element i18n-target4="string-attr=aaa,type1"></text-attribute-element>
    <text-attribute-element i18n-target5=""></text-attribute-element>
    <text-attribute-element i18n-target5="type1"></text-attribute-element>
    <text-attribute-element i18n-target="boolean-attr=,type4"></text-attribute-element>
    <text-attribute-element i18n-target="string-attr=aaa,string-attr2=bbb,type3"></text-attribute-element>
    <text-attribute-element i18n-target="boolean-attr,,boolean-attr2,,string-attr=aaa"></text-attribute-element>
    <text-attribute-element i18n-target="boolean-attr,!boolean-attr2,string-attr=abc|def,empty-attr=,type1"></text-attribute-element>
    <text-attribute-element i18n-target=""></text-attribute-element>
    <text-attribute-element i18n-target2="type5"></text-attribute-element>
    <text-attribute-element i18n-target2="boolean-attr="></text-attribute-element>
    <text-attribute-element i18n-target2="string-attr=aaa,string-attr2=bbb,type3"></text-attribute-element>
    <text-attribute-element i18n-target2="boolean-attr,!boolean-attr2,,string-attr=abc|def,,empty-attr=,type1"></text-attribute-element>
    <text-attribute-element i18n-target2="boolean-attr,,boolean-attr2,,string-attr=aaa,type2"></text-attribute-element>
    <text-attribute-element i18n-target3="string-attr=aaa,type1"></text-attribute-element>
    <text-attribute-element i18n-target3=""></text-attribute-element>
    <text-attribute-element i18n-target4=""></text-attribute-element>
    <text-attribute-element i18n-target4="string-attr=aaa,type1"></text-attribute-element>
    <text-attribute-element i18n-target5=""></text-attribute-element>
    <text-attribute-element i18n-target5="type1"></text-attribute-element>
    <text-attribute-element i18n-target6="type5"></text-attribute-element>
    <text-attribute-element i18n-target6="boolean-attr="></text-attribute-element>
    <text-attribute-element i18n-target6="boolean-attr,boolean-attr2,type1"></text-attribute-element>
    <text-attribute-element i18n-target6="boolean-attr,boolean-attr2,string-attr=aaa,type2"></text-attribute-element>
    <text-attribute-element i18n-target7="string-attr=aaa,type1"></text-attribute-element>
    <text-attribute-element i18n-target7="invalid!attr=aaa,typeX"></text-attribute-element>
  </template>
</i18n-attr-repo>
  <template id="text-attribute-element" text-attr="custom-text-attr1 custom-text-attr3" basepath="simple-attribute-element/" localizable-text="embedded">
    <span id="attr1">{{customTextAttr1}}</span>
    <span id="attr2">{{customTextAttr2}}</span>
    <span id="attr3">{{customTextAttr3}}</span>
    <span id="attr4">{{outOfScopeAttr}}</span>
    <span>{{text.span_4}}</span>
  <template id="localizable-text">
<json-data>
{
  "meta": {},
  "model": {},
  "span_4": "text"
}
</json-data>
</template>
</template>
<dom-module id="text-attribute-element" legacy="" assetpath="simple-attribute-element/">
  <template text-attr="custom-text-attr1 custom-text-attr3" localizable-text="embedded">
    <span id="attr1">{{customTextAttr1}}</span>
    <span id="attr2">{{customTextAttr2}}</span>
    <span id="attr3">{{customTextAttr3}}</span>
    <span id="attr4">{{outOfScopeAttr}}</span>
    <span>{{text.span_4}}</span>
  <template id="localizable-text">
<json-data>
{
  "meta": {},
  "model": {},
  "span_4": "text"
}
</json-data>
</template>
</template>
</dom-module>
<script>
  switch (syntax) {
  default:
  case 'mixin':
    {
      class TextAttributeElement extends Mixins.Localizable(Polymer.LegacyElement) {
        static get is() { return 'text-attribute-element'; }
        static get config() {
          return {
            properties: {
              customTextAttr1: {
                type: String,
                reflectToAttribute: true
              },
              customTextAttr2: {
                type: String,
                reflectToAttribute: true
              },
              customTextAttr3: {
                type: String,
                reflectToAttribute: true
              },
              outOfScopeAttr: {
                type: String,
                reflectToAttribute: true
              },
              i18nTarget: {
                type: String
              },
              i18nTarget2: {
                type: String
              }
            },
            listeners: {
              'lang-updated': '_langUpdated'
            }
          };
        }
        _langUpdated () {
          this.model = deepcopy(this.text.model);
        }
      }
      customElements.define(TextAttributeElement.is, TextAttributeElement);
    }
    break;
  case 'base-element':
    {
      class TextAttributeElement extends BaseElements.I18nElement {
        static get is() { return 'text-attribute-element'; }
        static get config() {
          return {
            properties: {
              customTextAttr1: {
                type: String,
                reflectToAttribute: true
              },
              customTextAttr2: {
                type: String,
                reflectToAttribute: true
              },
              customTextAttr3: {
                type: String,
                reflectToAttribute: true
              },
              outOfScopeAttr: {
                type: String,
                reflectToAttribute: true
              },
              i18nTarget: {
                type: String
              },
              i18nTarget2: {
                type: String
              }
            },
            listeners: {
              'lang-updated': '_langUpdated'
            }
          };
        }
        _langUpdated () {
          this.model = deepcopy(this.text.model);
        }
      }
      customElements.define(TextAttributeElement.is, TextAttributeElement);
    }
    break;
  case 'thin':
    {
      Define = class TextAttributeElement extends BaseElements.I18nElement {
        static get config() {
          return {
            properties: {
              customTextAttr1: {
                type: String,
                reflectToAttribute: true
              },
              customTextAttr2: {
                type: String,
                reflectToAttribute: true
              },
              customTextAttr3: {
                type: String,
                reflectToAttribute: true
              },
              outOfScopeAttr: {
                type: String,
                reflectToAttribute: true
              },
              i18nTarget: {
                type: String
              },
              i18nTarget2: {
                type: String
              }
            },
            listeners: {
              'lang-updated': '_langUpdated'
            }
          };
        }
        _langUpdated () {
          this.model = deepcopy(this.text.model);
        }
      };
    }
    break;
  case 'legacy':
    {
      Polymer({
        is: 'text-attribute-element',

        behaviors: [
          BehaviorsStore.I18nBehavior
        ],

        properties: {
          customTextAttr1: {
            type: String,
            reflectToAttribute: true
          },
          customTextAttr2: {
            type: String,
            reflectToAttribute: true
          },
          customTextAttr3: {
            type: String,
            reflectToAttribute: true
          },
          outOfScopeAttr: {
            type: String,
            reflectToAttribute: true
          },
          i18nTarget: {
            type: String
          },
          i18nTarget2: {
            type: String
          }
        },

        listeners: {
          'lang-updated': '_langUpdated'
        },

        ready: function () {
          //this.observeHtmlLang = false;
        },

        attached: function () {
        },

        _langUpdated: function () {
          this.model = deepcopy(this.text.model);
        }

      });
    }
    break;
  }
</script>

<template id="simple-attribute-element" basepath="simple-attribute-element/" localizable-text="embedded">
    <style attr="This is not extracted">
    google-chart {
      width: 300px;
    }
    </style>
    <div id="outer-div">
      <div id="ordinary-div" attr="This is not targeted for extraction">{{text.ordinary-div}}</div>

      <input id="standard-input" placeholder="{{model.standard-input.placeholder}}">
      <input placeholder="{{model.outer-div:input_2.placeholder}}">

      <paper-input id="paper-input-element" label="{{model.paper-input-element.label}}" error-message="{{model.paper-input-element.error-message}}" placeholder="{{model.paper-input-element.placeholder}}" value="this is not a target">
      </paper-input>

      <paper-input label="{{model.outer-div:paper-input_4.label}}" error-message="{{model.outer-div:paper-input_4.error-message}}" placeholder="{{model.outer-div:paper-input_4.placeholder}}" value="this is not a target">
      </paper-input>

      <google-chart type="pie" id="pie-chart" options="{{model.pie-chart.options}}" cols="{{model.pie-chart.cols}}" rows="{{model.pie-chart.rows}}">
      </google-chart>

      <google-chart id="column-chart" type="column" options="{{model.column-chart.options}}" data="{{model.column-chart.data}}">
      </google-chart>

      <text-attribute-element id="custom-attr" custom-text-attr1="{{model.custom-attr.custom-text-attr1}}" custom-text-attr2="{{model.custom-attr.custom-text-attr2}}" custom-text-attr3="{{model.custom-attr.custom-text-attr3}}" out-of-scope-attr="out of scope attr">
      </text-attribute-element>

      <text-attribute-element id="selective-attr" boolean-attr="" empty-attr="" string-attr="abc" custom-text-attr4$="{{i18nFormat(model.selective-attr.custom-text-attr4.0,text.ordinary-div,text.ordinary-div,text.ordinary-div,text.ordinary-div)}}" custom-text-attr5$="[[text.ordinary-div]]{{model.selective-attr.custom-text-attr5.1}}{{or('',text.ordinary-div)}}{{model.selective-attr.custom-text-attr5.3}}[[text.ordinary-div]]" i18n-target="{{i18nFormat(model.selective-attr.i18n-target.0,text.ordinary-div,text.ordinary-div)}}" i18n-target2="{{model.selective-attr.i18n-target2.0}}{{or('',text.ordinary-div)}}{{model.selective-attr.i18n-target2.2}}[[text.ordinary-div]]">
      </text-attribute-element>
      <text-attribute-element id="selective-attr2" boolean-attr="" boolean-attr2="" string-attr="aaa" i18n-target="{{model.selective-attr2.i18n-target}}">
      </text-attribute-element>
      <text-attribute-element id="selective-attr3" i18n-target6="{{model.selective-attr3.i18n-target6}}">
      </text-attribute-element>
      <text-attribute-element id="selective-attr4" boolean-attr="" i18n-target6="{{model.selective-attr4.i18n-target6}}" i18n-target7="unmatching i18n-target4 attribute">
      </text-attribute-element>
      <text-attribute-element id="selective-attr5" string-attr="xxx" i18n-target7="unmatching i18n-target7 attribute">
      </text-attribute-element>

      <span id="test-json-data-1">{{model.json-data-id.attr1}}</span>
      <span id="test-json-data-2">{{model.json-data-id.i18n-target-attr}}</span>
      <span id="test-json-data-3">{{model.template_2:json-data_1.attr1}}</span>
      <span id="test-json-data-4">{{model.template_2:json-data_1.i18n-target-attr}}</span>

    </div>
    <template>
      <json-data id="json-data-id" attr1="{{model.json-data-id.attr1}}" i18n-target-attr="{{model.json-data-id.i18n-target-attr}}"></json-data>
      <json-data attr1="{{model.template_2:json-data_1.attr1}}" i18n-target-attr="{{model.template_2:json-data_1.i18n-target-attr}}"></json-data>
    </template>
  <template id="localizable-text">
<json-data>
{
  "meta": {},
  "model": {
    "standard-input": {
      "placeholder": "standard HTML5 attribute"
    },
    "outer-div:input_2": {
      "placeholder": "standard HTML5 attribute without id"
    },
    "paper-input-element": {
      "label": "paper-input label",
      "error-message": "paper-input error message",
      "placeholder": "paper-input placeholder"
    },
    "outer-div:paper-input_4": {
      "label": "paper-input label without id",
      "error-message": "paper-input error message without id",
      "placeholder": "paper-input placeholder without id"
    },
    "pie-chart": {
      "options": {
        "title": "Distribution of days in 2001H1"
      },
      "cols": [
        {
          "label": "Month",
          "type": "string"
        },
        {
          "label": "Days",
          "type": "number"
        }
      ],
      "rows": [
        [
          "Jan",
          31
        ],
        [
          "Feb",
          28
        ],
        [
          "Mar",
          31
        ],
        [
          "Apr",
          30
        ],
        [
          "May",
          31
        ],
        [
          "Jun",
          30
        ]
      ]
    },
    "column-chart": {
      "options": {
        "title": "Inventory"
      },
      "data": [
        [
          "Year",
          "Things",
          "Stuff"
        ],
        [
          "2004",
          1000,
          400
        ],
        [
          "2005",
          1170,
          460
        ],
        [
          "2006",
          660,
          1120
        ],
        [
          "2007",
          1030,
          540
        ]
      ]
    },
    "custom-attr": {
      "custom-text-attr1": "custom text attribute 1",
      "custom-text-attr2": "custom text attribute 2",
      "custom-text-attr3": "custom text attribute 3"
    },
    "selective-attr": {
      "custom-text-attr4": [
        "{1} custom-text-attr4 attribute with param {2} and param {3} {4}",
        "{{text.ordinary-div}}",
        "{{text.ordinary-div}}",
        "[[text.ordinary-div]]",
        "{{text.ordinary-div}}"
      ],
      "custom-text-attr5": [
        "[[text.ordinary-div]]",
        " custom-text-attr5 attribute with param ",
        "{{or('',text.ordinary-div)}}",
        " and param ",
        "[[text.ordinary-div]]"
      ],
      "i18n-target": [
        "i18n-target attribute with param {1} and param {2}",
        "{{text.ordinary-div}}",
        "[[text.ordinary-div]]"
      ],
      "i18n-target2": [
        "i18n-target2 attribute with param ",
        "{{or('',text.ordinary-div)}}",
        " and param ",
        "[[text.ordinary-div]]"
      ]
    },
    "selective-attr2": {
      "i18n-target": "i18n-target attribute 2"
    },
    "selective-attr3": {
      "i18n-target6": "i18n-target6 attribute 2"
    },
    "selective-attr4": {
      "i18n-target6": "i18n-target6 attribute 3"
    },
    "json-data-id": {
      "attr1": "this attr1 is extracted",
      "i18n-target-attr": "this attribute is also extracted"
    },
    "template_2:json-data_1": {
      "attr1": "this attr1 without id is extracted",
      "i18n-target-attr": "this attribute without id is also extracted"
    }
  },
  "ordinary-div": "text 1"
}
</json-data>
</template>
</template>
<dom-module id="simple-attribute-element" legacy="" assetpath="simple-attribute-element/">
  <template localizable-text="embedded">
    <style attr="This is not extracted">
    google-chart {
      width: 300px;
    }
    </style>
    <div id="outer-div">
      <div id="ordinary-div" attr="This is not targeted for extraction">{{text.ordinary-div}}</div>

      <input id="standard-input" placeholder="{{model.standard-input.placeholder}}">
      <input placeholder="{{model.outer-div:input_2.placeholder}}">

      <paper-input id="paper-input-element" label="{{model.paper-input-element.label}}" error-message="{{model.paper-input-element.error-message}}" placeholder="{{model.paper-input-element.placeholder}}" value="this is not a target">
      </paper-input>

      <paper-input label="{{model.outer-div:paper-input_4.label}}" error-message="{{model.outer-div:paper-input_4.error-message}}" placeholder="{{model.outer-div:paper-input_4.placeholder}}" value="this is not a target">
      </paper-input>

      <google-chart type="pie" id="pie-chart" options="{{model.pie-chart.options}}" cols="{{model.pie-chart.cols}}" rows="{{model.pie-chart.rows}}">
      </google-chart>

      <google-chart id="column-chart" type="column" options="{{model.column-chart.options}}" data="{{model.column-chart.data}}">
      </google-chart>

      <text-attribute-element id="custom-attr" custom-text-attr1="{{model.custom-attr.custom-text-attr1}}" custom-text-attr2="{{model.custom-attr.custom-text-attr2}}" custom-text-attr3="{{model.custom-attr.custom-text-attr3}}" out-of-scope-attr="out of scope attr">
      </text-attribute-element>

      <text-attribute-element id="selective-attr" boolean-attr="" empty-attr="" string-attr="abc" custom-text-attr4$="{{i18nFormat(model.selective-attr.custom-text-attr4.0,text.ordinary-div,text.ordinary-div,text.ordinary-div,text.ordinary-div)}}" custom-text-attr5$="[[text.ordinary-div]]{{model.selective-attr.custom-text-attr5.1}}{{or('',text.ordinary-div)}}{{model.selective-attr.custom-text-attr5.3}}[[text.ordinary-div]]" i18n-target="{{i18nFormat(model.selective-attr.i18n-target.0,text.ordinary-div,text.ordinary-div)}}" i18n-target2="{{model.selective-attr.i18n-target2.0}}{{or('',text.ordinary-div)}}{{model.selective-attr.i18n-target2.2}}[[text.ordinary-div]]">
      </text-attribute-element>
      <text-attribute-element id="selective-attr2" boolean-attr="" boolean-attr2="" string-attr="aaa" i18n-target="{{model.selective-attr2.i18n-target}}">
      </text-attribute-element>
      <text-attribute-element id="selective-attr3" i18n-target6="{{model.selective-attr3.i18n-target6}}">
      </text-attribute-element>
      <text-attribute-element id="selective-attr4" boolean-attr="" i18n-target6="{{model.selective-attr4.i18n-target6}}" i18n-target7="unmatching i18n-target4 attribute">
      </text-attribute-element>
      <text-attribute-element id="selective-attr5" string-attr="xxx" i18n-target7="unmatching i18n-target7 attribute">
      </text-attribute-element>

      <span id="test-json-data-1">{{model.json-data-id.attr1}}</span>
      <span id="test-json-data-2">{{model.json-data-id.i18n-target-attr}}</span>
      <span id="test-json-data-3">{{model.template_2:json-data_1.attr1}}</span>
      <span id="test-json-data-4">{{model.template_2:json-data_1.i18n-target-attr}}</span>

    </div>
    <template>
      <json-data id="json-data-id" attr1="{{model.json-data-id.attr1}}" i18n-target-attr="{{model.json-data-id.i18n-target-attr}}"></json-data>
      <json-data attr1="{{model.template_2:json-data_1.attr1}}" i18n-target-attr="{{model.template_2:json-data_1.i18n-target-attr}}"></json-data>
    </template>
  <template id="localizable-text">
<json-data>
{
  "meta": {},
  "model": {
    "standard-input": {
      "placeholder": "standard HTML5 attribute"
    },
    "outer-div:input_2": {
      "placeholder": "standard HTML5 attribute without id"
    },
    "paper-input-element": {
      "label": "paper-input label",
      "error-message": "paper-input error message",
      "placeholder": "paper-input placeholder"
    },
    "outer-div:paper-input_4": {
      "label": "paper-input label without id",
      "error-message": "paper-input error message without id",
      "placeholder": "paper-input placeholder without id"
    },
    "pie-chart": {
      "options": {
        "title": "Distribution of days in 2001H1"
      },
      "cols": [
        {
          "label": "Month",
          "type": "string"
        },
        {
          "label": "Days",
          "type": "number"
        }
      ],
      "rows": [
        [
          "Jan",
          31
        ],
        [
          "Feb",
          28
        ],
        [
          "Mar",
          31
        ],
        [
          "Apr",
          30
        ],
        [
          "May",
          31
        ],
        [
          "Jun",
          30
        ]
      ]
    },
    "column-chart": {
      "options": {
        "title": "Inventory"
      },
      "data": [
        [
          "Year",
          "Things",
          "Stuff"
        ],
        [
          "2004",
          1000,
          400
        ],
        [
          "2005",
          1170,
          460
        ],
        [
          "2006",
          660,
          1120
        ],
        [
          "2007",
          1030,
          540
        ]
      ]
    },
    "custom-attr": {
      "custom-text-attr1": "custom text attribute 1",
      "custom-text-attr2": "custom text attribute 2",
      "custom-text-attr3": "custom text attribute 3"
    },
    "selective-attr": {
      "custom-text-attr4": [
        "{1} custom-text-attr4 attribute with param {2} and param {3} {4}",
        "{{text.ordinary-div}}",
        "{{text.ordinary-div}}",
        "[[text.ordinary-div]]",
        "{{text.ordinary-div}}"
      ],
      "custom-text-attr5": [
        "[[text.ordinary-div]]",
        " custom-text-attr5 attribute with param ",
        "{{or('',text.ordinary-div)}}",
        " and param ",
        "[[text.ordinary-div]]"
      ],
      "i18n-target": [
        "i18n-target attribute with param {1} and param {2}",
        "{{text.ordinary-div}}",
        "[[text.ordinary-div]]"
      ],
      "i18n-target2": [
        "i18n-target2 attribute with param ",
        "{{or('',text.ordinary-div)}}",
        " and param ",
        "[[text.ordinary-div]]"
      ]
    },
    "selective-attr2": {
      "i18n-target": "i18n-target attribute 2"
    },
    "selective-attr3": {
      "i18n-target6": "i18n-target6 attribute 2"
    },
    "selective-attr4": {
      "i18n-target6": "i18n-target6 attribute 3"
    },
    "json-data-id": {
      "attr1": "this attr1 is extracted",
      "i18n-target-attr": "this attribute is also extracted"
    },
    "template_2:json-data_1": {
      "attr1": "this attr1 without id is extracted",
      "i18n-target-attr": "this attribute without id is also extracted"
    }
  },
  "ordinary-div": "text 1"
}
</json-data>
</template>
</template>
</dom-module>
<script>
  switch (syntax) {
  default:
  case 'mixin':
    {
      class SimpleAttributeElement extends Mixins.Localizable(Polymer.LegacyElement) {
        static get is() { return 'simple-attribute-element' }
        static get config() {
          return {
            listeners: {
              'lang-updated': '_langUpdated'
              //'pie-chart.google-chart-render': '_pieChartRendered',
              //'column-chart.google-chart-render': '_columnChartRendered'
            }
          };
        }

        connectedCallback() {
          super.connectedCallback();
          this._intervalId = window.setInterval(this._checkChartStatus.bind(this), 1000);
          setTimeout(function () {
            this.isPieChartRendered = true;
            this.isColumnChartRendered = true;
            window.clearInterval(this._intervalId);
            this.fire('local-dom-ready'); // TODO: this is an ad-hoc solution
          }.bind(this), 200);
        }

        disconnectedCallback() {
          super.disconnectedCallback();
        }

        _checkChartStatus() {
          var pieChartInnerHtml = this.$['pie-chart'].$.chartdiv.innerHTML;
          var columnChartInnerHtml = this.$['column-chart'].$.chartdiv.innerHTML;
          var notLoaded = false;
          if (pieChartInnerHtml === 'Undefined chart type') {
            this.isPieChartRendered = true; // google api to blame; this is not responsible
          }
          if (columnChartInnerHtml === 'Undefined chart type') {
            this.isColumnChartRendered = true; // google api to blame; this is not responsible
          }
          if (this.isPieChartRendered && this.isColumnChartRendered) {
            window.clearInterval(this._intervalId);
            this.fire('local-dom-ready');
          }
        }

        _langUpdated(e) {
          if (e.composedPath()[0] === this) {
            this.model = deepcopy(this.text.model);
          }
        }

        _pieChartRendered() {
          this.isPieChartRendered = true;
          if (this.isPieChartRendered && this.isColumnChartRendered) {
            window.clearInterval(this._intervalId);
            this.fire('local-dom-ready');
          }
        }

        _columnChartRendered() {
          this.isColumnChartRendered = true;
          if (this.isPieChartRendered && this.isColumnChartRendered) {
            window.clearInterval(this._intervalId);
            this.fire('local-dom-ready');
          }
        }
      }
      customElements.define(SimpleAttributeElement.is, SimpleAttributeElement);
    }
    break;
  case 'base-element':
    {
      class SimpleAttributeElement extends BaseElements.I18nElement {
        static get is() { return 'simple-attribute-element' }
        static get config() {
          return {
            listeners: {
              'lang-updated': '_langUpdated'
              //'pie-chart.google-chart-render': '_pieChartRendered',
              //'column-chart.google-chart-render': '_columnChartRendered'
            }
          };
        }

        connectedCallback() {
          super.connectedCallback();
          this._intervalId = window.setInterval(this._checkChartStatus.bind(this), 1000);
          setTimeout(function () {
            this.isPieChartRendered = true;
            this.isColumnChartRendered = true;
            window.clearInterval(this._intervalId);
            this.fire('local-dom-ready'); // TODO: this is an ad-hoc solution
          }.bind(this), 200);
        }

        disconnectedCallback() {
          super.disconnectedCallback();
        }

        _checkChartStatus() {
          var pieChartInnerHtml = this.$['pie-chart'].$.chartdiv.innerHTML;
          var columnChartInnerHtml = this.$['column-chart'].$.chartdiv.innerHTML;
          var notLoaded = false;
          if (pieChartInnerHtml === 'Undefined chart type') {
            this.isPieChartRendered = true; // google api to blame; this is not responsible
          }
          if (columnChartInnerHtml === 'Undefined chart type') {
            this.isColumnChartRendered = true; // google api to blame; this is not responsible
          }
          if (this.isPieChartRendered && this.isColumnChartRendered) {
            window.clearInterval(this._intervalId);
            this.fire('local-dom-ready');
          }
        }

        _langUpdated(e) {
          if (e.composedPath()[0] === this) {
            this.model = deepcopy(this.text.model);
          }
        }

        _pieChartRendered() {
          this.isPieChartRendered = true;
          if (this.isPieChartRendered && this.isColumnChartRendered) {
            window.clearInterval(this._intervalId);
            this.fire('local-dom-ready');
          }
        }

        _columnChartRendered() {
          this.isColumnChartRendered = true;
          if (this.isPieChartRendered && this.isColumnChartRendered) {
            window.clearInterval(this._intervalId);
            this.fire('local-dom-ready');
          }
        }
      }
      customElements.define(SimpleAttributeElement.is, SimpleAttributeElement);
    }
    break;
  case 'thin':
    {
      Define = class SimpleAttributeElement extends BaseElements.I18nElement {
        static get config() {
          return {
            listeners: {
              'lang-updated': '_langUpdated'
              //'pie-chart.google-chart-render': '_pieChartRendered',
              //'column-chart.google-chart-render': '_columnChartRendered'
            }
          };
        }

        connectedCallback() {
          super.connectedCallback();
          this._intervalId = window.setInterval(this._checkChartStatus.bind(this), 1000);
          setTimeout(function () {
            this.isPieChartRendered = true;
            this.isColumnChartRendered = true;
            window.clearInterval(this._intervalId);
            this.fire('local-dom-ready'); // TODO: this is an ad-hoc solution
          }.bind(this), 200);
        }

        disconnectedCallback() {
          super.disconnectedCallback();
        }

        _checkChartStatus() {
          var pieChartInnerHtml = this.$['pie-chart'].$.chartdiv.innerHTML;
          var columnChartInnerHtml = this.$['column-chart'].$.chartdiv.innerHTML;
          var notLoaded = false;
          if (pieChartInnerHtml === 'Undefined chart type') {
            this.isPieChartRendered = true; // google api to blame; this is not responsible
          }
          if (columnChartInnerHtml === 'Undefined chart type') {
            this.isColumnChartRendered = true; // google api to blame; this is not responsible
          }
          if (this.isPieChartRendered && this.isColumnChartRendered) {
            window.clearInterval(this._intervalId);
            this.fire('local-dom-ready');
          }
        }

        _langUpdated(e) {
          if (e.composedPath()[0] === this) {
            this.model = deepcopy(this.text.model);
          }
        }

        _pieChartRendered() {
          this.isPieChartRendered = true;
          if (this.isPieChartRendered && this.isColumnChartRendered) {
            window.clearInterval(this._intervalId);
            this.fire('local-dom-ready');
          }
        }

        _columnChartRendered() {
          this.isColumnChartRendered = true;
          if (this.isPieChartRendered && this.isColumnChartRendered) {
            window.clearInterval(this._intervalId);
            this.fire('local-dom-ready');
          }
        }
      }
    }
    break;
  case 'legacy':
    {
      Polymer({
        is: 'simple-attribute-element',

        behaviors: [
          BehaviorsStore.I18nBehavior
        ],

        listeners: {
          'lang-updated': '_langUpdated',
          'pie-chart.google-chart-render': '_pieChartRendered',
          'column-chart.google-chart-render': '_columnChartRendered'
        },

        ready: function () {
          //this.observeHtmlLang = false;
        },

        attached: function () {
          this._intervalId = window.setInterval(this._checkChartStatus.bind(this), 1000);
          setTimeout(function () {
            this.isPieChartRendered = true;
            this.isColumnChartRendered = true;
            window.clearInterval(this._intervalId);
            this.fire('local-dom-ready'); // TODO: this is an ad-hoc solution
          }.bind(this), 200);
        },

        _checkChartStatus: function () {
          var pieChartInnerHtml = this.$['pie-chart'].$.chartdiv.innerHTML;
          var columnChartInnerHtml = this.$['column-chart'].$.chartdiv.innerHTML;
          var notLoaded = false;
          if (pieChartInnerHtml === 'Undefined chart type') {
            this.isPieChartRendered = true; // google api to blame; this is not responsible
          }
          if (columnChartInnerHtml === 'Undefined chart type') {
            this.isColumnChartRendered = true; // google api to blame; this is not responsible
          }
          if (this.isPieChartRendered && this.isColumnChartRendered) {
            window.clearInterval(this._intervalId);
            this.fire('local-dom-ready');
          }
        },

        _langUpdated: function (e) {
          if (Polymer.dom(e).rootTarget === this) {
            this.model = deepcopy(this.text.model);
          }
        },

        _pieChartRendered: function () {
          this.isPieChartRendered = true;
          if (this.isPieChartRendered && this.isColumnChartRendered) {
            window.clearInterval(this._intervalId);
            this.fire('local-dom-ready');
          }
        },

        _columnChartRendered: function () {
          this.isColumnChartRendered = true;
          if (this.isPieChartRendered && this.isColumnChartRendered) {
            window.clearInterval(this._intervalId);
            this.fire('local-dom-ready');
          }
        }

      });
    }
    break;
  }
</script><template id="fallback-text-element" basepath="fallback-text-element/" localizable-text="embedded">{{text.text}}<div><div></div></div>
    <span id="whitespace"> &nbsp; </span>
    <h1>{{text.h1_3}}</h1>{{text.text_4}}<span>{{text.span_5}}</span>
    <span>{{text.span_6}}</span>
    <span id="label-1">{{text.label-1}}</span>
    <span id="label-2">{{text.label-2}}</span>
    <div>
      <span>{{text.div_9:span}}</span> 
      <span>{{text.div_9:span_1}}</span> 
      <div><div>{{text.div_9:div_2:div}}</div></div> 
    </div>
    <div>{{text.div_10:text}}<span>{{text.div_10:span_1}}</span>{{text.div_10:text_2}}<span>{{text.div_10:span_3}}</span>
      <div><div>{{text.div_10:div_4:div}}</div></div>{{text.div_10:text_5}}</div>
    <div id="toplevel-div">
      <span>{{text.toplevel-div:span}}</span>
      <span>{{text.toplevel-div:span_1}}</span>
      <div id="second-level-div">
        <div id="third-level-div">{{text.third-level-div}}</div>
        <div>{{text.second-level-div:div_1}}</div>
      </div>
    </div>
    <div>
      <ul>
        <li>{{text.div_12:ul:li}}</li>
        <li>{{text.div_12:ul:li_1}}</li>
        <li>{{text.div_12:ul:li_2}}</li>
      </ul>
      <ul id="line-items">
        <li>{{text.line-items:li}}</li>
        <li>{{text.line-items:li_1}}</li>
        <li>{{text.line-items:li_2}}</li>
      </ul>
    </div>
    <p><i18n-format lang="{{effectiveLang}}"><span>{{text.p_13.0}}</span><b slot="1">{{text.p_13.1}}</b><code slot="2">{{text.p_13.2}}</code></i18n-format></p>
    <p id="paragraph"><i18n-format lang="{{effectiveLang}}"><span>{{text.paragraph.0}}</span><b slot="1">{{text.paragraph.1}}</b><code slot="2">{{text.paragraph.2}}</code></i18n-format></p>{{text.text_15}}<template id="localizable-text">
<json-data>
{
  "meta": {},
  "model": {},
  "text": " outermost text at the beginning ",
  "h1_3": "outermost header 1",
  "text_4": " outermost text in the middle ",
  "span_5": "simple text without id",
  "span_6": "simple text without id 2",
  "label-1": "simple text with id",
  "label-2": "simple text with id 2",
  "div_9:span": "simple text within div",
  "div_9:span_1": "simple text within div 2",
  "div_9:div_2:div": "great grandchild text within div",
  "div_10:text": " simple text as the first element in div ",
  "div_10:span_1": "simple text within div",
  "div_10:text_2": " simple text in the middle of div ",
  "div_10:span_3": "simple text within div 2",
  "div_10:div_4:div": "great grandchild text within div",
  "div_10:text_5": " simple text at the last element in div ",
  "toplevel-div:span": "simple text within div",
  "toplevel-div:span_1": "simple text within div 2",
  "third-level-div": "great grandchild text within div",
  "second-level-div:div_1": "great grandchild text within div without id",
  "div_12:ul:li": "line item without id 1",
  "div_12:ul:li_1": "line item without id 2",
  "div_12:ul:li_2": "line item without id 3",
  "line-items:li": "line item with id 1",
  "line-items:li_1": "line item with id 2",
  "line-items:li_2": "line item with id 3",
  "p_13": [
    "A paragraph with {1} is converted to {2}.",
    "parameters",
    "&lt;i18n-format&gt;"
  ],
  "paragraph": [
    "A paragraph with {1} is converted to {2}.",
    "id",
    "&lt;i18n-format&gt;"
  ],
  "text_15": " outermost text at the end "
}
</json-data>
</template>
</template>
<dom-module id="fallback-text-element" legacy="" assetpath="fallback-text-element/">
  <template localizable-text="embedded">{{text.text}}<div><div></div></div>
    <span id="whitespace"> &nbsp; </span>
    <h1>{{text.h1_3}}</h1>{{text.text_4}}<span>{{text.span_5}}</span>
    <span>{{text.span_6}}</span>
    <span id="label-1">{{text.label-1}}</span>
    <span id="label-2">{{text.label-2}}</span>
    <div>
      <span>{{text.div_9:span}}</span> 
      <span>{{text.div_9:span_1}}</span> 
      <div><div>{{text.div_9:div_2:div}}</div></div> 
    </div>
    <div>{{text.div_10:text}}<span>{{text.div_10:span_1}}</span>{{text.div_10:text_2}}<span>{{text.div_10:span_3}}</span>
      <div><div>{{text.div_10:div_4:div}}</div></div>{{text.div_10:text_5}}</div>
    <div id="toplevel-div">
      <span>{{text.toplevel-div:span}}</span>
      <span>{{text.toplevel-div:span_1}}</span>
      <div id="second-level-div">
        <div id="third-level-div">{{text.third-level-div}}</div>
        <div>{{text.second-level-div:div_1}}</div>
      </div>
    </div>
    <div>
      <ul>
        <li>{{text.div_12:ul:li}}</li>
        <li>{{text.div_12:ul:li_1}}</li>
        <li>{{text.div_12:ul:li_2}}</li>
      </ul>
      <ul id="line-items">
        <li>{{text.line-items:li}}</li>
        <li>{{text.line-items:li_1}}</li>
        <li>{{text.line-items:li_2}}</li>
      </ul>
    </div>
    <p><i18n-format lang="{{effectiveLang}}"><span>{{text.p_13.0}}</span><b slot="1">{{text.p_13.1}}</b><code slot="2">{{text.p_13.2}}</code></i18n-format></p>
    <p id="paragraph"><i18n-format lang="{{effectiveLang}}"><span>{{text.paragraph.0}}</span><b slot="1">{{text.paragraph.1}}</b><code slot="2">{{text.paragraph.2}}</code></i18n-format></p>{{text.text_15}}<template id="localizable-text">
<json-data>
{
  "meta": {},
  "model": {},
  "text": " outermost text at the beginning ",
  "h1_3": "outermost header 1",
  "text_4": " outermost text in the middle ",
  "span_5": "simple text without id",
  "span_6": "simple text without id 2",
  "label-1": "simple text with id",
  "label-2": "simple text with id 2",
  "div_9:span": "simple text within div",
  "div_9:span_1": "simple text within div 2",
  "div_9:div_2:div": "great grandchild text within div",
  "div_10:text": " simple text as the first element in div ",
  "div_10:span_1": "simple text within div",
  "div_10:text_2": " simple text in the middle of div ",
  "div_10:span_3": "simple text within div 2",
  "div_10:div_4:div": "great grandchild text within div",
  "div_10:text_5": " simple text at the last element in div ",
  "toplevel-div:span": "simple text within div",
  "toplevel-div:span_1": "simple text within div 2",
  "third-level-div": "great grandchild text within div",
  "second-level-div:div_1": "great grandchild text within div without id",
  "div_12:ul:li": "line item without id 1",
  "div_12:ul:li_1": "line item without id 2",
  "div_12:ul:li_2": "line item without id 3",
  "line-items:li": "line item with id 1",
  "line-items:li_1": "line item with id 2",
  "line-items:li_2": "line item with id 3",
  "p_13": [
    "A paragraph with {1} is converted to {2}.",
    "parameters",
    "&lt;i18n-format&gt;"
  ],
  "paragraph": [
    "A paragraph with {1} is converted to {2}.",
    "id",
    "&lt;i18n-format&gt;"
  ],
  "text_15": " outermost text at the end "
}
</json-data>
</template>
</template>
</dom-module>
<script>
  switch (syntax) {
  default:
  case 'mixin':
    {
      class FallbackTextElement extends Mixins.Localizable(Polymer.LegacyElement) {
        static get is() { return 'fallback-text-element' }
        static get config () {
          return {
            listeners: {
              'lang-updated': '_langUpdated'
            }
          }
        }

        _langUpdated (e) {
          console.log(this.is, 'lang-updated', e.detail);
          if (e.composedPath()[0] === this) {
            this.model = deepcopy(this.text.model);
          }
        }
      }
      customElements.define(FallbackTextElement.is, FallbackTextElement);
    }
    break;
  case 'base-element':
    {
      class FallbackTextElement extends BaseElements.I18nElement {
        static get is() { return 'fallback-text-element' }
        static get config () {
          return {
            listeners: {
              'lang-updated': '_langUpdated'
            }          
          }
        }

        _langUpdated (e) {
          console.log(this.is, 'lang-updated', e.detail);
          if (e.composedPath()[0] === this) {
            this.model = deepcopy(this.text.model);
          }
        }
      }
      customElements.define(FallbackTextElement.is, FallbackTextElement);
    }
    break;
  case 'thin':
    {
      Define = class FallbackTextElement extends BaseElements.I18nElement {
        static get config () {
          return {
            listeners: {
              'lang-updated': '_langUpdated'
            }          
          }
        }

        _langUpdated (e) {
          console.log(this.is, 'lang-updated', e.detail);
          if (e.composedPath()[0] === this) {
            this.model = deepcopy(this.text.model);
          }
        }
      };
    }
    break;
  case 'legacy':
    {
      Polymer({
        is: 'fallback-text-element',

        behaviors: [
          BehaviorsStore.I18nBehavior
        ],

        listeners: {
          'lang-updated': '_langUpdated'
        },

        ready: function () {
          //this.observeHtmlLang = false;
        },

        attached: function () {
        },

        _langUpdated: function (e) {
          console.log(this.is, 'lang-updated', e.detail);
          if (Polymer.dom(e).rootTarget === this) {
            this.model = deepcopy(this.text.model);
          }
        }
      });
    }
    break;
  }
</script><template id="compound-binding-element" basepath="compound-binding-element/" localizable-text="embedded"><i18n-format lang="{{effectiveLang}}"><span>{{text.text.0}}</span><span slot="1">{{param1}}</span><span slot="2">{{param2}}</span></i18n-format><div><div></div></div>
    <span id="whitespace"> &nbsp; </span>
    <h1><i18n-format lang="{{effectiveLang}}"><span>{{text.h1_3.0}}</span><span slot="1">{{param1}}</span><span slot="2">{{param2}}</span></i18n-format></h1><i18n-format lang="{{effectiveLang}}"><span>{{text.text_4.0}}</span><span slot="1">{{param1}}</span><span slot="2">{{param2}}</span></i18n-format><span><i18n-format lang="{{effectiveLang}}"><span>{{text.span_5.0}}</span><span slot="1">{{param1}}</span><span slot="2">{{param2}}</span></i18n-format></span>
    <span><i18n-format lang="{{effectiveLang}}"><span>{{text.span_6.0}}</span><span slot="1">{{param1}}</span><span slot="2">{{param2}}</span></i18n-format></span>
    <span id="label-1"><i18n-format lang="{{effectiveLang}}"><span>{{text.label-1.0}}</span><span slot="1">{{param1}}</span><span slot="2">{{param2}}</span></i18n-format></span>
    <span id="label-2"><i18n-format lang="{{effectiveLang}}"><span>{{text.label-2.0}}</span><span slot="1">{{param1}}</span><span slot="2">{{param2}}</span></i18n-format></span>
    <div>
      <span><i18n-format lang="{{effectiveLang}}"><span>{{text.div_9:span.0}}</span><span slot="1">{{param1}}</span><span slot="2">{{param2}}</span></i18n-format></span> 
      <span><i18n-format lang="{{effectiveLang}}"><span>{{text.div_9:span_1.0}}</span><span slot="1">{{param1}}</span><span slot="2">{{param2}}</span></i18n-format></span> 
      <div><div><i18n-format lang="{{effectiveLang}}"><span>{{text.div_9:div_2:div.0}}</span><span slot="1">{{param1}}</span><span slot="2">{{param2}}</span></i18n-format></div></div> 
    </div>
    <div><i18n-format lang="{{effectiveLang}}"><span>{{text.div_10:text.0}}</span><span slot="1">{{param1}}</span><span slot="2">{{param2}}</span></i18n-format><span><i18n-format lang="{{effectiveLang}}"><span>{{text.div_10:span_1.0}}</span><span slot="1">{{param1}}</span><span slot="2">{{param2}}</span></i18n-format></span><i18n-format lang="{{effectiveLang}}"><span>{{text.div_10:text_2.0}}</span><span slot="1">{{param1}}</span><span slot="2">{{param2}}</span></i18n-format><span><i18n-format lang="{{effectiveLang}}"><span>{{text.div_10:span_3.0}}</span><span slot="1">{{param1}}</span><span slot="2">{{param2}}</span></i18n-format></span>
      <div><div><i18n-format lang="{{effectiveLang}}"><span>{{text.div_10:div_4:div.0}}</span><span slot="1">{{param1}}</span><span slot="2">{{param2}}</span></i18n-format></div></div><i18n-format lang="{{effectiveLang}}"><span>{{text.div_10:text_5.0}}</span><span slot="1">{{param1}}</span><span slot="2">{{param2}}</span></i18n-format></div>
    <div id="toplevel-div">
      <span><i18n-format lang="{{effectiveLang}}"><span>{{text.toplevel-div:span.0}}</span><span slot="1">{{param1}}</span><span slot="2">{{param2}}</span></i18n-format></span>
      <span><i18n-format lang="{{effectiveLang}}"><span>{{text.toplevel-div:span_1.0}}</span><span slot="1">{{param1}}</span><span slot="2">{{param2}}</span></i18n-format></span>
      <div id="second-level-div">
        <div id="third-level-div"><i18n-format lang="{{effectiveLang}}"><span>{{text.third-level-div.0}}</span><span slot="1">{{param1}}</span><span slot="2">{{param2}}</span></i18n-format></div>
        <div><i18n-format lang="{{effectiveLang}}"><span>{{text.second-level-div:div_1.0}}</span><span slot="1">{{param1}}</span><span slot="2">{{param2}}</span></i18n-format></div>
      </div>
    </div>
    <div>
      <ul>
        <li><i18n-format lang="{{effectiveLang}}"><span>{{text.div_12:ul:li.0}}</span><span slot="1">{{param1}}</span><span slot="2">{{param2}}</span></i18n-format></li>
        <li><i18n-format lang="{{effectiveLang}}"><span>{{text.div_12:ul:li_1.0}}</span><span slot="1">{{param1}}</span><span slot="2">{{param2}}</span></i18n-format></li>
        <li><i18n-format lang="{{effectiveLang}}"><span>{{text.div_12:ul:li_2.0}}</span><span slot="1">{{param1}}</span><span slot="2">{{param2}}</span></i18n-format></li>
      </ul>
      <ul id="line-items">
        <li><i18n-format lang="{{effectiveLang}}"><span>{{text.line-items:li.0}}</span><span slot="1">{{param1}}</span><span slot="2">{{param2}}</span></i18n-format></li>
        <li><i18n-format lang="{{effectiveLang}}"><span>{{text.line-items:li_1.0}}</span><span slot="1">{{param1}}</span><span slot="2">{{param2}}</span></i18n-format></li>
        <li><i18n-format lang="{{effectiveLang}}"><span>{{text.line-items:li_2.0}}</span><span slot="1">{{param1}}</span><span slot="2">{{param2}}</span></i18n-format></li>
      </ul>
    </div>
    <p><i18n-format lang="{{effectiveLang}}"><span>{{text.p_13.0}}</span><span slot="1">{{param1}}</span><span slot="2">{{param2}}</span></i18n-format></p>
    <p id="paragraph"><i18n-format lang="{{effectiveLang}}"><span>{{text.paragraph.0}}</span><b slot="1">{{text.paragraph.1}}</b><span slot="2">{{param1}}</span><span slot="3">{{param2}}</span><code slot="4">{{text.paragraph.4}}</code></i18n-format></p><i18n-format lang="{{effectiveLang}}"><span>{{text.text_15.0}}</span><span slot="1">{{param1}}</span><span slot="2">{{param2}}</span></i18n-format><template id="localizable-text">
<json-data>
{
  "meta": {},
  "model": {},
  "text": [
    " outermost text at the beginning with compound {1} and {2} variables ",
    "{{param1}}",
    "{{param2}}"
  ],
  "h1_3": [
    "outermost header 1 with {1} and {2} variables",
    "{{param1}}",
    "{{param2}}"
  ],
  "text_4": [
    " outermost text in the middle with {1} and {2} variables ",
    "{{param1}}",
    "{{param2}}"
  ],
  "span_5": [
    "simple text without id with {1} and {2} variables",
    "{{param1}}",
    "{{param2}}"
  ],
  "span_6": [
    "simple text without id 2 with {1} and {2} variables",
    "{{param1}}",
    "{{param2}}"
  ],
  "label-1": [
    "simple text with id and {1} and {2} variables",
    "{{param1}}",
    "{{param2}}"
  ],
  "label-2": [
    "simple text with id and {1} and {2} variables 2",
    "{{param1}}",
    "{{param2}}"
  ],
  "div_9:span": [
    "simple text within div with {1} and {2} variables",
    "{{param1}}",
    "{{param2}}"
  ],
  "div_9:span_1": [
    "simple text within div with {1} and {2} variables 2",
    "{{param1}}",
    "{{param2}}"
  ],
  "div_9:div_2:div": [
    "great grandchild text within div with {1} and {2} variables",
    "{{param1}}",
    "{{param2}}"
  ],
  "div_10:text": [
    " simple text as the first element in div with {1} and {2} variables ",
    "{{param1}}",
    "{{param2}}"
  ],
  "div_10:span_1": [
    "simple text within div with {1} and {2} variables",
    "{{param1}}",
    "{{param2}}"
  ],
  "div_10:text_2": [
    " simple text in the middle of div with {1} and {2} variables ",
    "{{param1}}",
    "{{param2}}"
  ],
  "div_10:span_3": [
    "simple text within div with {1} and {2} variables 2",
    "{{param1}}",
    "{{param2}}"
  ],
  "div_10:div_4:div": [
    "great grandchild text within div with {1} and {2} variables",
    "{{param1}}",
    "{{param2}}"
  ],
  "div_10:text_5": [
    " simple text at the last element in div with {1} and {2} variables ",
    "{{param1}}",
    "{{param2}}"
  ],
  "toplevel-div:span": [
    "simple text within div with {1} and {2} variables",
    "{{param1}}",
    "{{param2}}"
  ],
  "toplevel-div:span_1": [
    "simple text within div 2 with {1} and {2} variables",
    "{{param1}}",
    "{{param2}}"
  ],
  "third-level-div": [
    "great grandchild text within div with {1} and {2} variables",
    "{{param1}}",
    "{{param2}}"
  ],
  "second-level-div:div_1": [
    "great grandchild text within div without id with {1} and {2} variables",
    "{{param1}}",
    "{{param2}}"
  ],
  "div_12:ul:li": [
    "line item without id 1 with {1} and {2} variables",
    "{{param1}}",
    "{{param2}}"
  ],
  "div_12:ul:li_1": [
    "line item without id 2 with {1} and {2} variables",
    "{{param1}}",
    "{{param2}}"
  ],
  "div_12:ul:li_2": [
    "line item without id 3 with {1} and {2} variables",
    "{{param1}}",
    "{{param2}}"
  ],
  "line-items:li": [
    "line item with id 1 with {1} and {2} variables",
    "{{param1}}",
    "{{param2}}"
  ],
  "line-items:li_1": [
    "line item with id 2 with {1} and {2} variables",
    "{{param1}}",
    "{{param2}}"
  ],
  "line-items:li_2": [
    "line item with id 3 with {1} and {2} variables",
    "{{param1}}",
    "{{param2}}"
  ],
  "p_13": [
    "A paragraph with {1} is converted to {2}.",
    "{{param1}}",
    "{{param2}}"
  ],
  "paragraph": [
    "A paragraph with {1}, {2}, and {3} is converted to {4}.",
    "id",
    "{{param1}}",
    "{{param2}}",
    "&lt;i18n-format&gt;"
  ],
  "text_15": [
    " outermost text at the end with {1} and {2} variables ",
    "{{param1}}",
    "{{param2}}"
  ]
}
</json-data>
</template>
</template>
<dom-module id="compound-binding-element" legacy="" assetpath="compound-binding-element/">
  <template localizable-text="embedded"><i18n-format lang="{{effectiveLang}}"><span>{{text.text.0}}</span><span slot="1">{{param1}}</span><span slot="2">{{param2}}</span></i18n-format><div><div></div></div>
    <span id="whitespace"> &nbsp; </span>
    <h1><i18n-format lang="{{effectiveLang}}"><span>{{text.h1_3.0}}</span><span slot="1">{{param1}}</span><span slot="2">{{param2}}</span></i18n-format></h1><i18n-format lang="{{effectiveLang}}"><span>{{text.text_4.0}}</span><span slot="1">{{param1}}</span><span slot="2">{{param2}}</span></i18n-format><span><i18n-format lang="{{effectiveLang}}"><span>{{text.span_5.0}}</span><span slot="1">{{param1}}</span><span slot="2">{{param2}}</span></i18n-format></span>
    <span><i18n-format lang="{{effectiveLang}}"><span>{{text.span_6.0}}</span><span slot="1">{{param1}}</span><span slot="2">{{param2}}</span></i18n-format></span>
    <span id="label-1"><i18n-format lang="{{effectiveLang}}"><span>{{text.label-1.0}}</span><span slot="1">{{param1}}</span><span slot="2">{{param2}}</span></i18n-format></span>
    <span id="label-2"><i18n-format lang="{{effectiveLang}}"><span>{{text.label-2.0}}</span><span slot="1">{{param1}}</span><span slot="2">{{param2}}</span></i18n-format></span>
    <div>
      <span><i18n-format lang="{{effectiveLang}}"><span>{{text.div_9:span.0}}</span><span slot="1">{{param1}}</span><span slot="2">{{param2}}</span></i18n-format></span> 
      <span><i18n-format lang="{{effectiveLang}}"><span>{{text.div_9:span_1.0}}</span><span slot="1">{{param1}}</span><span slot="2">{{param2}}</span></i18n-format></span> 
      <div><div><i18n-format lang="{{effectiveLang}}"><span>{{text.div_9:div_2:div.0}}</span><span slot="1">{{param1}}</span><span slot="2">{{param2}}</span></i18n-format></div></div> 
    </div>
    <div><i18n-format lang="{{effectiveLang}}"><span>{{text.div_10:text.0}}</span><span slot="1">{{param1}}</span><span slot="2">{{param2}}</span></i18n-format><span><i18n-format lang="{{effectiveLang}}"><span>{{text.div_10:span_1.0}}</span><span slot="1">{{param1}}</span><span slot="2">{{param2}}</span></i18n-format></span><i18n-format lang="{{effectiveLang}}"><span>{{text.div_10:text_2.0}}</span><span slot="1">{{param1}}</span><span slot="2">{{param2}}</span></i18n-format><span><i18n-format lang="{{effectiveLang}}"><span>{{text.div_10:span_3.0}}</span><span slot="1">{{param1}}</span><span slot="2">{{param2}}</span></i18n-format></span>
      <div><div><i18n-format lang="{{effectiveLang}}"><span>{{text.div_10:div_4:div.0}}</span><span slot="1">{{param1}}</span><span slot="2">{{param2}}</span></i18n-format></div></div><i18n-format lang="{{effectiveLang}}"><span>{{text.div_10:text_5.0}}</span><span slot="1">{{param1}}</span><span slot="2">{{param2}}</span></i18n-format></div>
    <div id="toplevel-div">
      <span><i18n-format lang="{{effectiveLang}}"><span>{{text.toplevel-div:span.0}}</span><span slot="1">{{param1}}</span><span slot="2">{{param2}}</span></i18n-format></span>
      <span><i18n-format lang="{{effectiveLang}}"><span>{{text.toplevel-div:span_1.0}}</span><span slot="1">{{param1}}</span><span slot="2">{{param2}}</span></i18n-format></span>
      <div id="second-level-div">
        <div id="third-level-div"><i18n-format lang="{{effectiveLang}}"><span>{{text.third-level-div.0}}</span><span slot="1">{{param1}}</span><span slot="2">{{param2}}</span></i18n-format></div>
        <div><i18n-format lang="{{effectiveLang}}"><span>{{text.second-level-div:div_1.0}}</span><span slot="1">{{param1}}</span><span slot="2">{{param2}}</span></i18n-format></div>
      </div>
    </div>
    <div>
      <ul>
        <li><i18n-format lang="{{effectiveLang}}"><span>{{text.div_12:ul:li.0}}</span><span slot="1">{{param1}}</span><span slot="2">{{param2}}</span></i18n-format></li>
        <li><i18n-format lang="{{effectiveLang}}"><span>{{text.div_12:ul:li_1.0}}</span><span slot="1">{{param1}}</span><span slot="2">{{param2}}</span></i18n-format></li>
        <li><i18n-format lang="{{effectiveLang}}"><span>{{text.div_12:ul:li_2.0}}</span><span slot="1">{{param1}}</span><span slot="2">{{param2}}</span></i18n-format></li>
      </ul>
      <ul id="line-items">
        <li><i18n-format lang="{{effectiveLang}}"><span>{{text.line-items:li.0}}</span><span slot="1">{{param1}}</span><span slot="2">{{param2}}</span></i18n-format></li>
        <li><i18n-format lang="{{effectiveLang}}"><span>{{text.line-items:li_1.0}}</span><span slot="1">{{param1}}</span><span slot="2">{{param2}}</span></i18n-format></li>
        <li><i18n-format lang="{{effectiveLang}}"><span>{{text.line-items:li_2.0}}</span><span slot="1">{{param1}}</span><span slot="2">{{param2}}</span></i18n-format></li>
      </ul>
    </div>
    <p><i18n-format lang="{{effectiveLang}}"><span>{{text.p_13.0}}</span><span slot="1">{{param1}}</span><span slot="2">{{param2}}</span></i18n-format></p>
    <p id="paragraph"><i18n-format lang="{{effectiveLang}}"><span>{{text.paragraph.0}}</span><b slot="1">{{text.paragraph.1}}</b><span slot="2">{{param1}}</span><span slot="3">{{param2}}</span><code slot="4">{{text.paragraph.4}}</code></i18n-format></p><i18n-format lang="{{effectiveLang}}"><span>{{text.text_15.0}}</span><span slot="1">{{param1}}</span><span slot="2">{{param2}}</span></i18n-format><template id="localizable-text">
<json-data>
{
  "meta": {},
  "model": {},
  "text": [
    " outermost text at the beginning with compound {1} and {2} variables ",
    "{{param1}}",
    "{{param2}}"
  ],
  "h1_3": [
    "outermost header 1 with {1} and {2} variables",
    "{{param1}}",
    "{{param2}}"
  ],
  "text_4": [
    " outermost text in the middle with {1} and {2} variables ",
    "{{param1}}",
    "{{param2}}"
  ],
  "span_5": [
    "simple text without id with {1} and {2} variables",
    "{{param1}}",
    "{{param2}}"
  ],
  "span_6": [
    "simple text without id 2 with {1} and {2} variables",
    "{{param1}}",
    "{{param2}}"
  ],
  "label-1": [
    "simple text with id and {1} and {2} variables",
    "{{param1}}",
    "{{param2}}"
  ],
  "label-2": [
    "simple text with id and {1} and {2} variables 2",
    "{{param1}}",
    "{{param2}}"
  ],
  "div_9:span": [
    "simple text within div with {1} and {2} variables",
    "{{param1}}",
    "{{param2}}"
  ],
  "div_9:span_1": [
    "simple text within div with {1} and {2} variables 2",
    "{{param1}}",
    "{{param2}}"
  ],
  "div_9:div_2:div": [
    "great grandchild text within div with {1} and {2} variables",
    "{{param1}}",
    "{{param2}}"
  ],
  "div_10:text": [
    " simple text as the first element in div with {1} and {2} variables ",
    "{{param1}}",
    "{{param2}}"
  ],
  "div_10:span_1": [
    "simple text within div with {1} and {2} variables",
    "{{param1}}",
    "{{param2}}"
  ],
  "div_10:text_2": [
    " simple text in the middle of div with {1} and {2} variables ",
    "{{param1}}",
    "{{param2}}"
  ],
  "div_10:span_3": [
    "simple text within div with {1} and {2} variables 2",
    "{{param1}}",
    "{{param2}}"
  ],
  "div_10:div_4:div": [
    "great grandchild text within div with {1} and {2} variables",
    "{{param1}}",
    "{{param2}}"
  ],
  "div_10:text_5": [
    " simple text at the last element in div with {1} and {2} variables ",
    "{{param1}}",
    "{{param2}}"
  ],
  "toplevel-div:span": [
    "simple text within div with {1} and {2} variables",
    "{{param1}}",
    "{{param2}}"
  ],
  "toplevel-div:span_1": [
    "simple text within div 2 with {1} and {2} variables",
    "{{param1}}",
    "{{param2}}"
  ],
  "third-level-div": [
    "great grandchild text within div with {1} and {2} variables",
    "{{param1}}",
    "{{param2}}"
  ],
  "second-level-div:div_1": [
    "great grandchild text within div without id with {1} and {2} variables",
    "{{param1}}",
    "{{param2}}"
  ],
  "div_12:ul:li": [
    "line item without id 1 with {1} and {2} variables",
    "{{param1}}",
    "{{param2}}"
  ],
  "div_12:ul:li_1": [
    "line item without id 2 with {1} and {2} variables",
    "{{param1}}",
    "{{param2}}"
  ],
  "div_12:ul:li_2": [
    "line item without id 3 with {1} and {2} variables",
    "{{param1}}",
    "{{param2}}"
  ],
  "line-items:li": [
    "line item with id 1 with {1} and {2} variables",
    "{{param1}}",
    "{{param2}}"
  ],
  "line-items:li_1": [
    "line item with id 2 with {1} and {2} variables",
    "{{param1}}",
    "{{param2}}"
  ],
  "line-items:li_2": [
    "line item with id 3 with {1} and {2} variables",
    "{{param1}}",
    "{{param2}}"
  ],
  "p_13": [
    "A paragraph with {1} is converted to {2}.",
    "{{param1}}",
    "{{param2}}"
  ],
  "paragraph": [
    "A paragraph with {1}, {2}, and {3} is converted to {4}.",
    "id",
    "{{param1}}",
    "{{param2}}",
    "&lt;i18n-format&gt;"
  ],
  "text_15": [
    " outermost text at the end with {1} and {2} variables ",
    "{{param1}}",
    "{{param2}}"
  ]
}
</json-data>
</template>
</template>
</dom-module>
<script>
  switch (syntax) {
  default:
  case 'mixin':
    {
      class CompoundBindingElement extends Mixins.Localizable(Polymer.LegacyElement) {
        static get is() { return 'compound-binding-element' }
        static get config () {
          return {
            properties: {
              param1: {
                type: String,
                value: 'parameter 1'
              },
              param2: {
                type: String,
                value: 'parameter 2'
              }
            },
            listeners: {
              'lang-updated': '_langUpdated'
            }          
          }
        }

        ready() {
          super.ready();
        }

        _langUpdated (e) {
          console.log(this.is, 'lang-updated', e.detail);
          if (e.composedPath()[0] === this) {
            this.model = deepcopy(this.text.model);
          }
        }
      }
      customElements.define(CompoundBindingElement.is, CompoundBindingElement);
    }
    break;
  case 'base-element':
    {
      class CompoundBindingElement extends BaseElements.I18nElement {
        static get is() { return 'compound-binding-element' }
        static get config () {
          return {
            properties: {
              param1: {
                type: String,
                value: 'parameter 1'
              },
              param2: {
                type: String,
                value: 'parameter 2'
              }
            },
            listeners: {
              'lang-updated': '_langUpdated'
            }          
          }
        }

        ready() {
          super.ready();
        }

        _langUpdated (e) {
          console.log(this.is, 'lang-updated', e.detail);
          if (e.composedPath()[0] === this) {
            this.model = deepcopy(this.text.model);
          }
        }
      }
      customElements.define(CompoundBindingElement.is, CompoundBindingElement);
    }
    break;
  case 'thin':
    {
      Define = class CompoundBindingElement extends BaseElements.I18nElement {
        static get config () {
          return {
            properties: {
              param1: {
                type: String,
                value: 'parameter 1'
              },
              param2: {
                type: String,
                value: 'parameter 2'
              }
            },
            listeners: {
              'lang-updated': '_langUpdated'
            }          
          }
        }

        ready() {
          super.ready();
        }

        _langUpdated (e) {
          console.log(this.is, 'lang-updated', e.detail);
          if (e.composedPath()[0] === this) {
            this.model = deepcopy(this.text.model);
          }
        }
      };
    }
    break;
  case 'legacy':
    {
      Polymer({
        is: 'compound-binding-element',

        behaviors: [
          BehaviorsStore.I18nBehavior
        ],

        properties: {
          param1: {
            type: String,
            value: 'parameter 1'
          },
          param2: {
            type: String,
            value: 'parameter 2'
          }
        },

        listeners: {
          'lang-updated': '_langUpdated'
        },

        ready: function () {
          //this.observeHtmlLang = false;
        },

        attached: function () {
        },

        _langUpdated: function (e) {
          console.log(this.is, 'lang-updated', e.detail);
          if (Polymer.dom(e).rootTarget === this) {
            this.model = deepcopy(this.text.model);
          }
        }
      });
    }
    break;
  }
</script><template id="simple-text-id-element" basepath="simple-text-id-element/" localizable-text="embedded">{{text.text}}<div><div></div></div>
    <span text-id="whitespace"> &nbsp; </span>
    <h1>{{text.h1_3}}</h1>{{text.text_4}}<span>{{text.span_5}}</span>
    <span>{{text.span_6}}</span>
    <span text-id="label-1">{{text.label-1}}</span>
    <span text-id="label-2">{{text.label-2}}</span>
    <div>
      <span>{{text.div_9:span}}</span> 
      <span>{{text.div_9:span_1}}</span> 
      <div><div>{{text.div_9:div_2:div}}</div></div> 
    </div>
    <div>{{text.div_10:text}}<span>{{text.div_10:span_1}}</span>{{text.div_10:text_2}}<span>{{text.div_10:span_3}}</span>
      <div><div>{{text.div_10:div_4:div}}</div></div>{{text.div_10:text_5}}</div>
    <div text-id="toplevel-div">
      <span>{{text.toplevel-div:span}}</span>
      <span>{{text.toplevel-div:span_1}}</span>
      <div text-id="second-level-div"><i18n-format lang="{{effectiveLang}}"><span>{{text.second-level-div.0}}</span><div text-id="third-level-div" slot="1">{{text.second-level-div.1}}</div><div slot="2">{{text.second-level-div.2}}</div></i18n-format></div>
    </div>
    <div>
      <ul>
        <li>{{text.div_12:ul:li}}</li>
        <li>{{text.div_12:ul:li_1}}</li>
        <li>{{text.div_12:ul:li_2}}</li>
      </ul>
      <ul text-id="line-items"><i18n-format lang="{{effectiveLang}}"><span>{{text.line-items.0}}</span><li slot="1">{{text.line-items.1}}</li><li slot="2">{{text.line-items.2}}</li><li slot="3">{{text.line-items.3}}</li></i18n-format></ul>
    </div>
    <p><i18n-format lang="{{effectiveLang}}"><span>{{text.p_13.0}}</span><b slot="1">{{text.p_13.1}}</b><code slot="2">{{text.p_13.2}}</code></i18n-format></p>
    <p text-id="paragraph"><i18n-format lang="{{effectiveLang}}"><span>{{text.paragraph.0}}</span><b slot="1">{{text.paragraph.1}}</b><code slot="2">{{text.paragraph.2}}</code></i18n-format></p>{{text.text_15}}<template id="localizable-text">
<json-data>
{
  "meta": {},
  "model": {},
  "text": " outermost text at the beginning ",
  "h1_3": "outermost header 1",
  "text_4": " outermost text in the middle ",
  "span_5": "simple text without id",
  "span_6": "simple text without id 2",
  "label-1": "simple text with id",
  "label-2": "simple text with id 2",
  "div_9:span": "simple text within div",
  "div_9:span_1": "simple text within div 2",
  "div_9:div_2:div": "great grandchild text within div",
  "div_10:text": " simple text as the first element in div ",
  "div_10:span_1": "simple text within div",
  "div_10:text_2": " simple text in the middle of div ",
  "div_10:span_3": "simple text within div 2",
  "div_10:div_4:div": "great grandchild text within div",
  "div_10:text_5": " simple text at the last element in div ",
  "toplevel-div:span": "simple text within div",
  "toplevel-div:span_1": "simple text within div 2",
  "second-level-div": [
    " {1}\n        {2} ",
    "great grandchild text within div",
    "great grandchild text within div without id"
  ],
  "div_12:ul:li": "line item without id 1",
  "div_12:ul:li_1": "line item without id 2",
  "div_12:ul:li_2": "line item without id 3",
  "line-items": [
    " {1}\n        {2}\n        {3} ",
    "line item with id 1",
    "line item with id 2",
    "line item with id 3"
  ],
  "p_13": [
    "A paragraph with {1} is converted to {2}.",
    "parameters",
    "&lt;i18n-format&gt;"
  ],
  "paragraph": [
    "A paragraph with {1} is converted to {2}.",
    "id",
    "&lt;i18n-format&gt;"
  ],
  "text_15": " outermost text at the end "
}
</json-data>
</template>
</template>
<dom-module id="simple-text-id-element" legacy="" assetpath="simple-text-id-element/">
  <template localizable-text="embedded">{{text.text}}<div><div></div></div>
    <span text-id="whitespace"> &nbsp; </span>
    <h1>{{text.h1_3}}</h1>{{text.text_4}}<span>{{text.span_5}}</span>
    <span>{{text.span_6}}</span>
    <span text-id="label-1">{{text.label-1}}</span>
    <span text-id="label-2">{{text.label-2}}</span>
    <div>
      <span>{{text.div_9:span}}</span> 
      <span>{{text.div_9:span_1}}</span> 
      <div><div>{{text.div_9:div_2:div}}</div></div> 
    </div>
    <div>{{text.div_10:text}}<span>{{text.div_10:span_1}}</span>{{text.div_10:text_2}}<span>{{text.div_10:span_3}}</span>
      <div><div>{{text.div_10:div_4:div}}</div></div>{{text.div_10:text_5}}</div>
    <div text-id="toplevel-div">
      <span>{{text.toplevel-div:span}}</span>
      <span>{{text.toplevel-div:span_1}}</span>
      <div text-id="second-level-div"><i18n-format lang="{{effectiveLang}}"><span>{{text.second-level-div.0}}</span><div text-id="third-level-div" slot="1">{{text.second-level-div.1}}</div><div slot="2">{{text.second-level-div.2}}</div></i18n-format></div>
    </div>
    <div>
      <ul>
        <li>{{text.div_12:ul:li}}</li>
        <li>{{text.div_12:ul:li_1}}</li>
        <li>{{text.div_12:ul:li_2}}</li>
      </ul>
      <ul text-id="line-items"><i18n-format lang="{{effectiveLang}}"><span>{{text.line-items.0}}</span><li slot="1">{{text.line-items.1}}</li><li slot="2">{{text.line-items.2}}</li><li slot="3">{{text.line-items.3}}</li></i18n-format></ul>
    </div>
    <p><i18n-format lang="{{effectiveLang}}"><span>{{text.p_13.0}}</span><b slot="1">{{text.p_13.1}}</b><code slot="2">{{text.p_13.2}}</code></i18n-format></p>
    <p text-id="paragraph"><i18n-format lang="{{effectiveLang}}"><span>{{text.paragraph.0}}</span><b slot="1">{{text.paragraph.1}}</b><code slot="2">{{text.paragraph.2}}</code></i18n-format></p>{{text.text_15}}<template id="localizable-text">
<json-data>
{
  "meta": {},
  "model": {},
  "text": " outermost text at the beginning ",
  "h1_3": "outermost header 1",
  "text_4": " outermost text in the middle ",
  "span_5": "simple text without id",
  "span_6": "simple text without id 2",
  "label-1": "simple text with id",
  "label-2": "simple text with id 2",
  "div_9:span": "simple text within div",
  "div_9:span_1": "simple text within div 2",
  "div_9:div_2:div": "great grandchild text within div",
  "div_10:text": " simple text as the first element in div ",
  "div_10:span_1": "simple text within div",
  "div_10:text_2": " simple text in the middle of div ",
  "div_10:span_3": "simple text within div 2",
  "div_10:div_4:div": "great grandchild text within div",
  "div_10:text_5": " simple text at the last element in div ",
  "toplevel-div:span": "simple text within div",
  "toplevel-div:span_1": "simple text within div 2",
  "second-level-div": [
    " {1}\n        {2} ",
    "great grandchild text within div",
    "great grandchild text within div without id"
  ],
  "div_12:ul:li": "line item without id 1",
  "div_12:ul:li_1": "line item without id 2",
  "div_12:ul:li_2": "line item without id 3",
  "line-items": [
    " {1}\n        {2}\n        {3} ",
    "line item with id 1",
    "line item with id 2",
    "line item with id 3"
  ],
  "p_13": [
    "A paragraph with {1} is converted to {2}.",
    "parameters",
    "&lt;i18n-format&gt;"
  ],
  "paragraph": [
    "A paragraph with {1} is converted to {2}.",
    "id",
    "&lt;i18n-format&gt;"
  ],
  "text_15": " outermost text at the end "
}
</json-data>
</template>
</template>
</dom-module>
<script>
  switch (syntax) {
  default:
  case 'mixin':
    {
      class SimpleTextIdElement extends Mixins.Localizable(Polymer.LegacyElement) {
        static get is() { return 'simple-text-id-element' }
        static get config () {
          return {
            listeners: {
              'lang-updated': '_langUpdated'
            }          
          }
        }

        ready() {
          super.ready();
        }

        _langUpdated (e) {
          console.log(this.is, 'lang-updated', e.detail);
          if (e.composedPath()[0] === this) {
            this.model = deepcopy(this.text.model);
          }
        }
      }
      customElements.define(SimpleTextIdElement.is, SimpleTextIdElement);
    }
    break;
  case 'base-element':
    {
      class SimpleTextIdElement extends BaseElements.I18nElement {
        static get is() { return 'simple-text-id-element' }
        static get config () {
          return {
            listeners: {
              'lang-updated': '_langUpdated'
            }          
          }
        }

        ready() {
          super.ready();
        }

        _langUpdated (e) {
          console.log(this.is, 'lang-updated', e.detail);
          if (e.composedPath()[0] === this) {
            this.model = deepcopy(this.text.model);
          }
        }
      }
      customElements.define(SimpleTextIdElement.is, SimpleTextIdElement);
    }
    break;
  case 'thin':
    {
      Define = class SimpleTextIdElement extends BaseElements.I18nElement {
        static get config () {
          return {
            listeners: {
              'lang-updated': '_langUpdated'
            }          
          }
        }

        ready() {
          super.ready();
        }

        _langUpdated (e) {
          console.log(this.is, 'lang-updated', e.detail);
          if (e.composedPath()[0] === this) {
            this.model = deepcopy(this.text.model);
          }
        }
      };
    }
    break;
  case 'legacy':
    {
      Polymer({
        is: 'simple-text-id-element',

        behaviors: [
          BehaviorsStore.I18nBehavior
        ],

        listeners: {
          'lang-updated': '_langUpdated'
        },

        ready: function () {
          //this.observeHtmlLang = false;
        },

        attached: function () {
        },

        _langUpdated: function (e) {
          console.log(this.is, 'lang-updated', e.detail);
          if (Polymer.dom(e).rootTarget === this) {
            this.model = deepcopy(this.text.model);
          }
        }
      });
    }
    break;
  }
</script>
<script>
      var bind = document.querySelector('#simple-attribute-dom-bind');

      bind.addEventListener('dom-change', function onDomChangeForBind (event) {
        if (!bind.done && event.target === bind) {
          bind._langUpdated = function (e) {
            if (e.composedPath()[0] === this) {
              //console.log('bind._langUpdated: ' + this.is + ' ' + this.id + ' ' + e.type + ' ' + this.lang + ' params.lang = ' + (this.params ? this.params.lang : ''));
              //console.log('bind._langUpdated: deepcopying model for lang ' + this.lang);
              this.model = deepcopy(this.text.model);
              this.notifyPath('model', this.model);
              this.render();
            }
          }.bind(bind);

          bind._onDomChangeAfterLangUpdated = function (e) {
            //console.log('bind._onDomChangeAfterLangUpdated ' + this.is + ' ' + this.id + ' ' + e.type + ' ' + this.lang + ' params.lang = ' + (this.params ? this.params.lang : ''));
            if (this.params && this.params.lang === this.lang) {
              //console.log('bind._onDomChangeAfterLangUpdated ' + this.is + ' ' + this.id + ' ' + e.type + ' firing local-dom-ready');
              this.fire('local-dom-ready');
            }
            e.stopPropagation();
            return false;
          }.bind(bind);

          bind.addEventListener('lang-updated', bind._langUpdated);
          bind.addEventListener('dom-change', bind._onDomChangeAfterLangUpdated);

          window.removeEventListener('dom-change', onDomChangeForBind);
          bind.done = true;
        }
      });
suite('I18nElement with ' + 
  (window.location.href.indexOf('?dom=Shadow') >= 0 ? 'Shadow DOM' : 'Shady DOM') +
  (' in ' + syntax + ' syntax'), 
  function () {

  var lang0 = '';
  var lang1 = 'en';
  var lang2 = 'fr';
  var lang3 = 'ja';
  var lang4 = 'fr-CA';
  var lang5 = 'zh-Hans-CN';
  var lang6 = 'ru';
  var text_simple = {
    'model': {},
    'text': ' outermost text at the beginning ',
    'h1_3': 'outermost header 1',
    'text_4': ' outermost text in the middle ',
    'span_5': 'simple text without id',
    'span_6': 'simple text without id 2',
    'label-1': 'simple text with id',
    'label-2': 'simple text with id 2',
    'div_9:span': 'simple text within div',
    'div_9:span_1': 'simple text within div 2',
    'div_9:div_2:div': 'great grandchild text within div',
    'div_10:text': ' simple text as the first element in div ',
    'div_10:span_1': 'simple text within div',
    'div_10:text_2': ' simple text in the middle of div ',
    'div_10:span_3': 'simple text within div 2',
    'div_10:div_4:div': 'great grandchild text within div',
    'div_10:text_5': ' simple text at the last element in div ',
    'toplevel-div:span': 'simple text within div',
    'toplevel-div:span_1': 'simple text within div 2',
    'third-level-div': 'great grandchild text within div',
    'second-level-div:div_1': 'great grandchild text within div without id',
    'div_12:ul:li': 'line item without id 1',
    'div_12:ul:li_1': 'line item without id 2',
    'div_12:ul:li_2': 'line item without id 3',
    'line-items:li': 'line item with id 1',
    'line-items:li_1': 'line item with id 2',
    'line-items:li_2': 'line item with id 3',
    'p_13': [
      'A paragraph with {1} is converted to {2}.',
      'parameters',
      '<i18n-format>'
    ],
    'paragraph': [
      'A paragraph with {1} is converted to {2}.',
      'id',
      '<i18n-format>'
    ],
    'text_15': ' outermost text at the end '
  };
  var localDOM_simple = [
    { select: 'div:not([id])', 'previousTextSibling.data': ' outermost text at the beginning ' },
    { select: 'h1', textContent: 'outermost header 1' },
    { select: 'h1', 'nextTextSibling.data': ' outermost text in the middle ' },
    { select: 'span:not([id])', textContent: [ 'simple text without id', 'simple text without id 2' ] },
    { select: 'span[id="label-1"]', textContent: 'simple text with id' },
    { select: 'span[id="label-2"]', textContent: 'simple text with id 2' },
    { select: 'span[id="label-2"] + div span:not([id])', textContent:  [ 'simple text within div', 'simple text within div 2' ] },
    { select: 'span[id="label-2"] + div div:not([id]) div:not([id])', textContent: [ 'great grandchild text within div' ] },
    { select: 'span[id="label-2"] + div + div', 'childNodes.0.data': ' simple text as the first element in div ' },
    { select: 'span[id="label-2"] + div + div span:not([id])', textContent:  [ 'simple text within div', 'simple text within div 2' ] },
    { select: 'span[id="label-2"] + div + div span:not([id])', 'nextTextSibling.data': ' simple text in the middle of div ' },
    { select: 'span[id="label-2"] + div + div div:not([id]) div:not([id])', textContent: 'great grandchild text within div' },
    { select: 'span[id="label-2"] + div + div div:not([id])', 'nextTextSibling.data': ' simple text at the last element in div ' },
    { select: '[id="toplevel-div"] span:not([id])', textContent: [ 'simple text within div', 'simple text within div 2' ] },
    { select: '[id="third-level-div"]', textContent: 'great grandchild text within div' },
    { select: '[id="second-level-div"] div:not([id])', textContent: 'great grandchild text within div without id' },
    { select: 'div ul:not([id]) li:not([id])', textContent: [ 'line item without id 1', 'line item without id 2', 'line item without id 3' ] },
    { select: '[id="line-items"] li:not([id])', textContent: [ 'line item with id 1', 'line item with id 2', 'line item with id 3' ] },
    { select: 'p:not([id]) i18n-format', 
      'PolymerDom.children.0.textContent': 'A paragraph with {1} is converted to {2}.' },
    { select: 'p:not([id]) i18n-format',
      'PolymerDom.children.1.tagName': 'B',
      'PolymerDom.children.1.textContent': 'parameters',
      'PolymerDom.children.1.attributes.slot.value': '1' },
    { select: 'p:not([id]) i18n-format',
      'PolymerDom.children.2.tagName': 'CODE',
      'PolymerDom.children.2.textContent': '<i18n-format>',
      'PolymerDom.children.2.attributes.slot.value': '2' },
    { select: '[id="paragraph"] i18n-format',
      'PolymerDom.children.0.textContent': 'A paragraph with {1} is converted to {2}.' },
    { select: '[id="paragraph"] i18n-format',
      'PolymerDom.children.1.tagName': 'B',
      'PolymerDom.children.1.textContent': 'id',
      'PolymerDom.children.1.attributes.slot.value': '1' },
    { select: '[id="paragraph"] i18n-format',
      'PolymerDom.children.2.tagName': 'CODE',
      'PolymerDom.children.2.textContent': '<i18n-format>',
      'PolymerDom.children.2.attributes.slot.value': '2' },
    { select: '[id="paragraph"]', 'nextTextSibling.data': ' outermost text at the end ' }
  ];
  var text_simple_text_id = {
    'model': {},
    'text': ' outermost text at the beginning ',
    'h1_3': 'outermost header 1',
    'text_4': ' outermost text in the middle ',
    'span_5': 'simple text without id',
    'span_6': 'simple text without id 2',
    'label-1': 'simple text with id',
    'label-2': 'simple text with id 2',
    'div_9:span': 'simple text within div',
    'div_9:span_1': 'simple text within div 2',
    'div_9:div_2:div': 'great grandchild text within div',
    'div_10:text': ' simple text as the first element in div ',
    'div_10:span_1': 'simple text within div',
    'div_10:text_2': ' simple text in the middle of div ',
    'div_10:span_3': 'simple text within div 2',
    'div_10:div_4:div': 'great grandchild text within div',
    'div_10:text_5': ' simple text at the last element in div ',
    'toplevel-div:span': 'simple text within div',
    'toplevel-div:span_1': 'simple text within div 2',
    'second-level-div': [
      ' {1}\n        {2} ',
      'great grandchild text within div',
      'great grandchild text within div without id'
    ],
    'div_12:ul:li': 'line item without id 1',
    'div_12:ul:li_1': 'line item without id 2',
    'div_12:ul:li_2': 'line item without id 3',
    'line-items': [
      ' {1}\n        {2}\n        {3} ',
      'line item with id 1',
      'line item with id 2',
      'line item with id 3'
    ],
    'p_13': [
      'A paragraph with {1} is converted to {2}.',
      'parameters',
      '<i18n-format>'
    ],
    'paragraph': [
      'A paragraph with {1} is converted to {2}.',
      'id',
      '<i18n-format>'
    ],
    'text_15': ' outermost text at the end '
  };
  var localDOM_simple_text_id = [
    { select: 'div:not([text-id])', 'previousTextSibling.data': ' outermost text at the beginning ' },
    { select: 'h1', textContent: 'outermost header 1' },
    { select: 'h1', 'nextTextSibling.data': ' outermost text in the middle ' },
    { select: 'span:not([text-id])', textContent: [ 'simple text without id', 'simple text without id 2' ] },
    { select: 'span[text-id="label-1"]', textContent: 'simple text with id' },
    { select: 'span[text-id="label-2"]', textContent: 'simple text with id 2' },
    { select: 'span[text-id="label-2"] + div span:not([text-id])', textContent:  [ 'simple text within div', 'simple text within div 2' ] },
    { select: 'span[text-id="label-2"] + div div:not([text-id]) div:not([text-id])', textContent: [ 'great grandchild text within div' ] },
    { select: 'span[text-id="label-2"] + div + div', 'childNodes.0.data': ' simple text as the first element in div ' },
    { select: 'span[text-id="label-2"] + div + div span:not([text-id])', textContent:  [ 'simple text within div', 'simple text within div 2' ] },
    { select: 'span[text-id="label-2"] + div + div span:not([text-id])', 'nextTextSibling.data': ' simple text in the middle of div ' },
    { select: 'span[text-id="label-2"] + div + div div:not([text-id]) div:not([text-id])', textContent: 'great grandchild text within div' },
    { select: 'span[text-id="label-2"] + div + div div:not([text-id])', 'nextTextSibling.data': ' simple text at the last element in div ' },
    { select: '[text-id="toplevel-div"] span:not([text-id])', textContent: [ 'simple text within div', 'simple text within div 2' ] },
    { select: '[text-id="second-level-div"] i18n-format',
      'PolymerDom.children.0.textContent': ' {1}\n        {2} ' },
    { select: '[text-id="second-level-div"] i18n-format',
      'PolymerDom.children.1.tagName': 'DIV',
      'PolymerDom.children.1.textContent': 'great grandchild text within div',
      'PolymerDom.children.1.attributes.slot.value': '1' },
    { select: '[text-id="second-level-div"] i18n-format',
      'PolymerDom.children.2.tagName': 'DIV',
      'PolymerDom.children.2.textContent': 'great grandchild text within div without id',
      'PolymerDom.children.2.attributes.slot.value': '2' },
    { select: 'div ul:not([text-id]) li:not([text-id])', textContent: [ 'line item without id 1', 'line item without id 2', 'line item without id 3' ] },
    { select: '[text-id="line-items"] i18n-format',
      'PolymerDom.children.0.textContent': ' {1}\n        {2}\n        {3} ' },
    { select: '[text-id="line-items"] i18n-format',
      'PolymerDom.children.1.tagName': 'LI',
      'PolymerDom.children.1.textContent': 'line item with id 1',
      'PolymerDom.children.1.attributes.slot.value': '1' },
    { select: '[text-id="line-items"] i18n-format',
      'PolymerDom.children.2.tagName': 'LI',
      'PolymerDom.children.2.textContent': 'line item with id 2',
      'PolymerDom.children.2.attributes.slot.value': '2' },
    { select: '[text-id="line-items"] i18n-format',
      'PolymerDom.children.3.tagName': 'LI',
      'PolymerDom.children.3.textContent': 'line item with id 3',
      'PolymerDom.children.3.attributes.slot.value': '3' },
    { select: 'p:not([text-id]) i18n-format', 
      'PolymerDom.children.0.textContent': 'A paragraph with {1} is converted to {2}.' },
    { select: 'p:not([text-id]) i18n-format',
      'PolymerDom.children.1.tagName': 'B',
      'PolymerDom.children.1.textContent': 'parameters',
      'PolymerDom.children.1.attributes.slot.value': '1' },
    { select: 'p:not([text-id]) i18n-format',
      'PolymerDom.children.2.tagName': 'CODE',
      'PolymerDom.children.2.textContent': '<i18n-format>',
      'PolymerDom.children.2.attributes.slot.value': '2' },
    { select: '[text-id="paragraph"] i18n-format',
      'PolymerDom.children.0.textContent': 'A paragraph with {1} is converted to {2}.' },
    { select: '[text-id="paragraph"] i18n-format',
      'PolymerDom.children.1.tagName': 'B',
      'PolymerDom.children.1.textContent': 'id',
      'PolymerDom.children.1.attributes.slot.value': '1' },
    { select: '[text-id="paragraph"] i18n-format',
      'PolymerDom.children.2.tagName': 'CODE',
      'PolymerDom.children.2.textContent': '<i18n-format>',
      'PolymerDom.children.2.attributes.slot.value': '2' },
    { select: '[text-id="paragraph"]', 'nextTextSibling.data': ' outermost text at the end ' }
  ];
  var sender1 = {
    'name': 'Joe',
    'gender': 'male'
  };
  var recipients1 = [
    { 'name': 'Alice', 'gender': 'female' },
    { 'name': 'Bob', 'gender': 'male' },
    { 'name': 'Yoda', 'gender': 'other' }
  ];
  var recipients2 = [
    { 'name': 'Alice', 'gender': 'female' },
    { 'name': 'Bob', 'gender': 'male' }
  ];
  var recipients3 = [
    { 'name': 'Bob', 'gender': 'male' }
  ];
  var recipients4 = [];
  var text_plural_gender = {
    'model': {},
    'compound-format-text': [
      {
        '0': 'You ({3}) gave no gifts.',
        '1': {
          'male': 'You ({3}) gave him ({4}) {5}.',
          'female': 'You ({3}) gave her ({4}) {5}.',
          'other': 'You ({3}) gave them ({4}) {5}.'
        },
        'one': {
          'male': 'You ({3}) gave him ({4}) and one other person {5}.',
          'female': 'You ({3}) gave her ({4}) and one other person {5}.',
          'other': 'You ({3}) gave them ({4}) and one other person {5}.'
        },
        'other': 'You ({3}) gave them ({4}) and {1} other people gifts.'
      },
      '{{recipients.length - 1}}',
      '{{recipients.0.gender}}',
      '{{sender.name}}',
      '{{recipients.0.name}}',
      'a gift'
    ]
  };
  var localDOM_plural_gender_1 = [
    { select: '#compound-format-text', 'root.PolymerDom.textContent': 'You () gave them () and  other people gifts.' },
    { select: '#compound-format-text', 'PolymerDom.children.1.PolymerDom.childNodes.0.data.raw': '3' },
    { select: '#compound-format-text', 'PolymerDom.children.2.PolymerDom.childNodes.0.data.raw': 'female' },
    { select: '#compound-format-text', 'PolymerDom.children.3.PolymerDom.childNodes.0.data.raw': 'Joe' },
    { select: '#compound-format-text', 'PolymerDom.children.4.PolymerDom.childNodes.0.data.raw': 'Alice' },
    { select: '#compound-format-text', 'PolymerDom.children.5.PolymerDom.childNodes.0.data': 'a gift' }
  ];
  var localDOM_plural_gender_2 = [
    { select: '#compound-format-text', 'root.PolymerDom.textContent': 'You () gave her () and one other person .' },
    { select: '#compound-format-text', 'PolymerDom.children.1.PolymerDom.childNodes.0.data.raw': '2' },
    { select: '#compound-format-text', 'PolymerDom.children.2.PolymerDom.childNodes.0.data.raw': 'female' },
    { select: '#compound-format-text', 'PolymerDom.children.3.PolymerDom.childNodes.0.data.raw': 'Joe' },
    { select: '#compound-format-text', 'PolymerDom.children.4.PolymerDom.childNodes.0.data.raw': 'Alice' },
    { select: '#compound-format-text', 'PolymerDom.children.5.PolymerDom.childNodes.0.data': 'a gift' }
  ];
  var localDOM_plural_gender_3 = [
    { select: '#compound-format-text', 'root.PolymerDom.textContent': 'You () gave him () .' },
    { select: '#compound-format-text', 'PolymerDom.children.1.PolymerDom.childNodes.0.data.raw': '1' },
    { select: '#compound-format-text', 'PolymerDom.children.2.PolymerDom.childNodes.0.data.raw': 'male' },
    { select: '#compound-format-text', 'PolymerDom.children.3.PolymerDom.childNodes.0.data.raw': 'Joe' },
    { select: '#compound-format-text', 'PolymerDom.children.4.PolymerDom.childNodes.0.data.raw': 'Bob' },
    { select: '#compound-format-text', 'PolymerDom.children.5.PolymerDom.childNodes.0.data': 'a gift' }
  ];
  var localDOM_plural_gender_4 = [
    { select: '#compound-format-text', 'root.PolymerDom.textContent': 'You () gave no gifts.' },
    { select: '#compound-format-text', 'PolymerDom.children.1.PolymerDom.childNodes.0.data.raw': '0' },
    { select: '#compound-format-text', 'PolymerDom.children.2.PolymerDom.childNodes.0.data.raw': '' },
    { select: '#compound-format-text', 'PolymerDom.children.3.PolymerDom.childNodes.0.data.raw': 'Joe' },
    { select: '#compound-format-text', 'PolymerDom.children.4.PolymerDom.childNodes.0.data.raw': '' },
    { select: '#compound-format-text', 'PolymerDom.children.5.PolymerDom.childNodes.0.data': 'a gift' }
  ];
  var text_simple_attribute = {
    'model': {
      'standard-input': {
        'placeholder': 'standard HTML5 attribute'
      },
      'outer-div:input_2': {
        'placeholder': 'standard HTML5 attribute without id'
      },
      'paper-input-element': {
        'label': 'paper-input label',
        'error-message': 'paper-input error message',
        'placeholder': 'paper-input placeholder'
      },
      'outer-div:paper-input_4': {
        'label': 'paper-input label without id',
        'error-message': 'paper-input error message without id',
        'placeholder': 'paper-input placeholder without id'
      },
      'pie-chart': {
        'options': {
          'title': 'Distribution of days in 2001H1'
        },
        'cols': [
          {
            'label': 'Month',
            'type': 'string'
          },
          {
            'label': 'Days',
            'type': 'number'
          }
        ],
        'rows': [
          [
            'Jan',
            31
          ],
          [
            'Feb',
            28
          ],
          [
            'Mar',
            31
          ],
          [
            'Apr',
            30
          ],
          [
            'May',
            31
          ],
          [
            'Jun',
            30
          ]
        ]
      },
      'column-chart': {
        'options': {
          'title': 'Inventory'
        },
        'data': [
          [
            'Year',
            'Things',
            'Stuff'
          ],
          [
            '2004',
            1000,
            400
          ],
          [
            '2005',
            1170,
            460
          ],
          [
            '2006',
            660,
            1120
          ],
          [
            '2007',
            1030,
            540
          ]
        ]
      },
      'custom-attr': {
        'custom-text-attr1': 'custom text attribute 1',
        'custom-text-attr2': 'custom text attribute 2',
        'custom-text-attr3': 'custom text attribute 3'
      },
      'selective-attr': {
        'custom-text-attr4': [
          '{1} custom-text-attr4 attribute with param {2} and param {3} {4}',
          '{{text.ordinary-div}}',
          '{{text.ordinary-div}}',
          '[[text.ordinary-div]]',
          '{{text.ordinary-div}}'
        ],
        'custom-text-attr5': [
          '[[text.ordinary-div]]',
          ' custom-text-attr5 attribute with param ',
          "{{or('',text.ordinary-div)}}",
          ' and param ',
          '[[text.ordinary-div]]'
        ],
        'i18n-target': [
          'i18n-target attribute with param {1} and param {2}',
          '{{text.ordinary-div}}',
          '[[text.ordinary-div]]'
        ],
        'i18n-target2': [
          'i18n-target2 attribute with param ',
          "{{or('',text.ordinary-div)}}",
          ' and param ',
          '[[text.ordinary-div]]'
        ]
      },
      'selective-attr2': {
        'i18n-target': 'i18n-target attribute 2'
      },
      'selective-attr3': {
        'i18n-target6': 'i18n-target6 attribute 2'
      },
      'selective-attr4': {
        'i18n-target6': 'i18n-target6 attribute 3'
      },
      'json-data-id': {
        'attr1': 'this attr1 is extracted',
        'i18n-target-attr': 'this attribute is also extracted'
      },
      'template_2:json-data_1': {
        'attr1': 'this attr1 without id is extracted',
        'i18n-target-attr': 'this attribute without id is also extracted'
      }
    },
    'ordinary-div': 'text 1'
  };
  var model_simple_attribute = {
    'standard-input': {
      'placeholder': 'standard HTML5 attribute'
    },
    'outer-div:input_2': {
      'placeholder': 'standard HTML5 attribute without id'
    },
    'paper-input-element': {
      'label': 'paper-input label',
      'error-message': 'paper-input error message',
      'placeholder': 'paper-input placeholder'
    },
    'outer-div:paper-input_4': {
      'label': 'paper-input label without id',
      'error-message': 'paper-input error message without id',
      'placeholder': 'paper-input placeholder without id'
    },
    'pie-chart': {
      'options': {
        'title': 'Distribution of days in 2001H1'
      },
      'cols': [
        {
          'label': 'Month',
          'type': 'string'
        },
        {
          'label': 'Days',
          'type': 'number'
        }
      ],
      'rows': [
        [
          'Jan',
          31
        ],
        [
          'Feb',
          28
        ],
        [
          'Mar',
          31
        ],
        [
          'Apr',
          30
        ],
        [
          'May',
          31
        ],
        [
          'Jun',
          30
        ]
      ]
    },
    'column-chart': {
      'options': {
        'title': 'Inventory'
      },
      'data': [
        [
          'Year',
          'Things',
          'Stuff'
        ],
        [
          '2004',
          1000,
          400
        ],
        [
          '2005',
          1170,
          460
        ],
        [
          '2006',
          660,
          1120
        ],
        [
          '2007',
          1030,
          540
        ]
      ]
    },
    'custom-attr': {
      'custom-text-attr1': 'custom text attribute 1',
      'custom-text-attr2': 'custom text attribute 2',
      'custom-text-attr3': 'custom text attribute 3'
    },
    'selective-attr': {
      'custom-text-attr4': [
        '{1} custom-text-attr4 attribute with param {2} and param {3} {4}',
        '{{text.ordinary-div}}',
        '{{text.ordinary-div}}',
        '[[text.ordinary-div]]',
        '{{text.ordinary-div}}'
      ],
      'custom-text-attr5': [
        '[[text.ordinary-div]]',
        ' custom-text-attr5 attribute with param ',
        "{{or('',text.ordinary-div)}}",
        ' and param ',
        '[[text.ordinary-div]]'
      ],
      'i18n-target': [
        'i18n-target attribute with param {1} and param {2}',
        '{{text.ordinary-div}}',
        '[[text.ordinary-div]]'
      ],
      'i18n-target2': [
        'i18n-target2 attribute with param ',
        "{{or('',text.ordinary-div)}}",
        ' and param ',
        '[[text.ordinary-div]]'
      ]
    },
    'selective-attr2': {
      'i18n-target': 'i18n-target attribute 2'
    },
    'selective-attr3': {
      'i18n-target6': 'i18n-target6 attribute 2'
    },
    'selective-attr4': {
      'i18n-target6': 'i18n-target6 attribute 3'
    },
    'json-data-id': {
      'attr1': 'this attr1 is extracted',
      'i18n-target-attr': 'this attribute is also extracted'
    },
    'template_2:json-data_1': {
      'attr1': 'this attr1 without id is extracted',
      'i18n-target-attr': 'this attribute without id is also extracted'
    }
  };
  var localDOM_simple_attribute = [
    { select: 'input[id="standard-input"]', 'placeholder.text': 'standard HTML5 attribute' },
    { select: 'input[id="standard-input"] + input', 'placeholder.text': 'standard HTML5 attribute without id' },
    { select: 'paper-input[id="paper-input-element"]', 'label.text': 'paper-input label', 'errorMessage.text': 'paper-input error message', 'placeholder.text': 'paper-input placeholder' },
    { select: 'paper-input[id="paper-input-element"] + paper-input', 'label.text': 'paper-input label without id', 'errorMessage.text': 'paper-input error message without id', 'placeholder.text': 'paper-input placeholder without id' },
    { select: 'google-chart[id="pie-chart"]', 'options.title.text': 'Distribution of days in 2001H1', 'cols.0.label.text': 'Month', 'cols.1.label.text': 'Days', 'rows.0.0.text': 'Jan', 'rows.1.0.text': 'Feb', 'rows.2.0.text': 'Mar', 'rows.3.0.text': 'Apr', 'rows.4.0.text': 'May', 'rows.5.0.text': 'Jun' },
    { select: 'google-chart[id="column-chart"]', 'options.title.text': 'Inventory', 'data.0.0.text': 'Year', 'data.0.1.text': 'Things', 'data.0.2.text': 'Stuff' },
    { select: 'text-attribute-element[id="custom-attr"]', 'customTextAttr1.text': 'custom text attribute 1', 'customTextAttr2.text': 'custom text attribute 2', 'customTextAttr3.text': 'custom text attribute 3' },
    { select: 'text-attribute-element[id="selective-attr"]', 'i18nTarget.raw': 'i18n-target attribute with param text 1 and param text 1', 'i18nTarget2.raw': 'i18n-target2 attribute with param text 1 and param text 1' },
    { select: 'span[id="test-json-data-1"]', 'textContent': 'this attr1 is extracted' },
    { select: 'span[id="test-json-data-2"]', 'textContent': 'this attribute is also extracted' },
    { select: 'span[id="test-json-data-3"]', 'textContent': 'this attr1 without id is extracted' },
    { select: 'span[id="test-json-data-4"]', 'textContent': 'this attribute without id is also extracted' },
  ];
  var localDOM_simple_attribute_fr = [
    { select: 'input[id="standard-input"]', 'placeholder.text': 'standard HTML5 attribute' },
    { select: 'input[id="standard-input"] + input', 'placeholder.text': 'standard HTML5 attribute without id' },
    { select: 'paper-input[id="paper-input-element"]', 'label.text': 'paper-input label', 'errorMessage.text': 'paper-input error message', 'placeholder.text': 'paper-input placeholder' },
    { select: 'paper-input[id="paper-input-element"] + paper-input', 'label.text': 'paper-input label without id', 'errorMessage.text': 'paper-input error message without id', 'placeholder.text': 'paper-input placeholder without id' },
    { select: 'google-chart[id="pie-chart"]', 'options.title.text': 'Distribution of days in 2001H1', 'cols.0.label.text': 'Month', 'cols.1.label.text': 'Days', 'rows.0.0.text': 'Jan', 'rows.1.0.text': 'Feb', 'rows.2.0.text': 'Mar', 'rows.3.0.text': 'Apr', 'rows.4.0.text': 'May', 'rows.5.0.text': 'Jun' },
    { select: 'google-chart[id="column-chart"]', 'options.title.text': 'Inventory', 'data.0.0.text': 'Year', 'data.0.1.text': 'Things', 'data.0.2.text': 'Stuff' },
    { select: 'text-attribute-element[id="custom-attr"]', 'customTextAttr1.text': 'custom text attribute 1', 'customTextAttr2.text': 'custom text attribute 2', 'customTextAttr3.text': 'custom text attribute 3' },
    { select: 'text-attribute-element[id="selective-attr"]', 'i18nTarget.raw': 'fr i18n-target attribute with param fr text 1 and param fr text 1', 'i18nTarget2.raw': 'fr i18n-target2 attribute with param fr text 1 fr and param fr text 1' },
    { select: 'span[id="test-json-data-1"]', 'textContent': 'this attr1 is extracted' },
    { select: 'span[id="test-json-data-2"]', 'textContent': 'this attribute is also extracted' },
    { select: 'span[id="test-json-data-3"]', 'textContent': 'this attr1 without id is extracted' },
    { select: 'span[id="test-json-data-4"]', 'textContent': 'this attribute without id is also extracted' },
  ];
  var text_fallback = {
    'model': {},
    'text': 'fr-CA  outermost text at the beginning ',
    'h1_3': 'fr-CA outermost header 1',
    'text_4': 'fr-CA  outermost text in the middle ',
    'span_5': 'fr-CA simple text without id',
    'span_6': 'fr-CA simple text without id 2',
    'label-1': 'fr-CA simple text with id',
    'label-2': 'fr-CA simple text with id 2',
    'div_9:span': 'simple text within div',
    'div_9:span_1': 'simple text within div 2',
    'div_9:div_2:div': 'great grandchild text within div',
    'div_10:text': ' simple text as the first element in div ',
    'div_10:span_1': 'fr-CA simple text within div',
    'div_10:text_2': ' simple text in the middle of div ',
    'div_10:span_3': 'simple text within div 2',
    'div_10:div_4:div': 'great grandchild text within div',
    'div_10:text_5': ' simple text at the last element in div ',
    'toplevel-div:span': 'fr-CA simple text within div',
    'toplevel-div:span_1': 'fr-CA simple text within div 2',
    'third-level-div': 'fr-CA great grandchild text within div',
    'second-level-div:div_1': 'fr-CA great grandchild text within div without id',
    'div_12:ul:li': 'fr line item without id 1',
    'div_12:ul:li_1': 'fr line item without id 2',
    'div_12:ul:li_2': 'fr line item without id 3',
    'line-items:li': 'fr line item with id 1',
    'line-items:li_1': 'fr line item with id 2',
    'line-items:li_2': 'fr line item with id 3',
    'p_13': [
      'fr-CA A paragraph with {1} is converted to {2}.',
      'fr-CA parameters',
      'fr-CA <i18n-format>'
    ],
    'paragraph': [
      'fr-CA A paragraph with {1} is converted to {2}.',
      'fr-CA id',
      'fr-CA <i18n-format>'
    ],
    'text_15': 'fr-CA  outermost text at the end '
  };
  var localDOM_fallback = [
    { select: 'div:not([id])', 'previousTextSibling.data': 'fr-CA  outermost text at the beginning ' },
    { select: 'h1', textContent: 'fr-CA outermost header 1' },
    { select: 'h1', 'nextTextSibling.data': 'fr-CA  outermost text in the middle ' },
    { select: 'span:not([id])', textContent: [ 'fr-CA simple text without id', 'fr-CA simple text without id 2' ] },
    { select: 'span[id="label-1"]', textContent: 'fr-CA simple text with id' },
    { select: 'span[id="label-2"]', textContent: 'fr-CA simple text with id 2' },
    { select: 'span[id="label-2"] + div span:not([id])', textContent:  [ 'simple text within div', 'simple text within div 2' ] },
    { select: 'span[id="label-2"] + div div:not([id]) div:not([id])', textContent: [ 'great grandchild text within div' ] },
    { select: 'span[id="label-2"] + div + div', 'childNodes.0.data': ' simple text as the first element in div ' },
    { select: 'span[id="label-2"] + div + div span:not([id])', textContent:  [ 'fr-CA simple text within div', 'simple text within div 2' ] },
    { select: 'span[id="label-2"] + div + div span:not([id])', 'nextTextSibling.data': ' simple text in the middle of div ' },
    { select: 'span[id="label-2"] + div + div div:not([id]) div:not([id])', textContent: 'great grandchild text within div' },
    { select: 'span[id="label-2"] + div + div div:not([id])', 'nextTextSibling.data': ' simple text at the last element in div ' },
    { select: '[id="toplevel-div"] span:not([id])', textContent: [ 'fr-CA simple text within div', 'fr-CA simple text within div 2' ] },
    { select: '[id="third-level-div"]', textContent: 'fr-CA great grandchild text within div' },
    { select: '[id="second-level-div"] div:not([id])', textContent: 'fr-CA great grandchild text within div without id' },
    { select: 'div ul:not([id]) li:not([id])', textContent: [ 'fr line item without id 1', 'fr line item without id 2', 'fr line item without id 3' ] },
    { select: '[id="line-items"] li:not([id])', textContent: [ 'fr line item with id 1', 'fr line item with id 2', 'fr line item with id 3' ] },
    { select: 'p:not([id]) i18n-format', 
      'PolymerDom.children.0.textContent': 'fr-CA A paragraph with {1} is converted to {2}.' },
    { select: 'p:not([id]) i18n-format',
      'PolymerDom.children.1.tagName': 'B',
      'PolymerDom.children.1.textContent': 'fr-CA parameters',
      'PolymerDom.children.1.attributes.slot.value': '1' },
    { select: 'p:not([id]) i18n-format',
      'PolymerDom.children.2.tagName': 'CODE',
      'PolymerDom.children.2.textContent': 'fr-CA <i18n-format>',
      'PolymerDom.children.2.attributes.slot.value': '2' },
    { select: '[id="paragraph"] i18n-format',
      'PolymerDom.children.0.textContent': 'fr-CA A paragraph with {1} is converted to {2}.' },
    { select: '[id="paragraph"] i18n-format',
      'PolymerDom.children.1.tagName': 'B',
      'PolymerDom.children.1.textContent': 'fr-CA id',
      'PolymerDom.children.1.attributes.slot.value': '1' },
    { select: '[id="paragraph"] i18n-format',
      'PolymerDom.children.2.tagName': 'CODE',
      'PolymerDom.children.2.textContent': 'fr-CA <i18n-format>',
      'PolymerDom.children.2.attributes.slot.value': '2' },
    { select: '[id="paragraph"]', 'nextTextSibling.data': 'fr-CA  outermost text at the end ' }
  ];
  var param1 = '1st compound parameter';
  var param2 = '2nd compound parameter';
  var text_compound = {
    'model': {},
    'text': [
      ' outermost text at the beginning with compound {1} and {2} variables ',
      '{{param1}}',
      '{{param2}}'
    ],
    'h1_3': [
      'outermost header 1 with {1} and {2} variables',
      '{{param1}}',
      '{{param2}}'
    ],
    'text_4': [
      ' outermost text in the middle with {1} and {2} variables ',
      '{{param1}}',
      '{{param2}}'
    ],
    'span_5': [
      'simple text without id with {1} and {2} variables',
      '{{param1}}',
      '{{param2}}'
    ],
    'span_6': [
      'simple text without id 2 with {1} and {2} variables',
      '{{param1}}',
      '{{param2}}'
    ],
    'label-1': [
      'simple text with id and {1} and {2} variables',
      '{{param1}}',
      '{{param2}}'
    ],
    'label-2': [
      'simple text with id and {1} and {2} variables 2',
      '{{param1}}',
      '{{param2}}'
    ],
    'div_9:span': [
      'simple text within div with {1} and {2} variables',
      '{{param1}}',
      '{{param2}}'
    ],
    'div_9:span_1': [
      'simple text within div with {1} and {2} variables 2',
      '{{param1}}',
      '{{param2}}'
    ],
    'div_9:div_2:div': [
      'great grandchild text within div with {1} and {2} variables',
      '{{param1}}',
      '{{param2}}'
    ],
    'div_10:text': [
      ' simple text as the first element in div with {1} and {2} variables ',
      '{{param1}}',
      '{{param2}}'
    ],
    'div_10:span_1': [
      'simple text within div with {1} and {2} variables',
      '{{param1}}',
      '{{param2}}'
    ],
    'div_10:text_2': [
      ' simple text in the middle of div with {1} and {2} variables ',
      '{{param1}}',
      '{{param2}}'
    ],
    'div_10:span_3': [
      'simple text within div with {1} and {2} variables 2',
      '{{param1}}',
      '{{param2}}'
    ],
    'div_10:div_4:div': [
      'great grandchild text within div with {1} and {2} variables',
      '{{param1}}',
      '{{param2}}'
    ],
    'div_10:text_5': [
      ' simple text at the last element in div with {1} and {2} variables ',
      '{{param1}}',
      '{{param2}}'
    ],
    'toplevel-div:span': [
      'simple text within div with {1} and {2} variables',
      '{{param1}}',
      '{{param2}}'
    ],
    'toplevel-div:span_1': [
      'simple text within div 2 with {1} and {2} variables',
      '{{param1}}',
      '{{param2}}'
    ],
    'third-level-div': [
      'great grandchild text within div with {1} and {2} variables',
      '{{param1}}',
      '{{param2}}'
    ],
    'second-level-div:div_1': [
      'great grandchild text within div without id with {1} and {2} variables',
      '{{param1}}',
      '{{param2}}'
    ],
    'div_12:ul:li': [
      'line item without id 1 with {1} and {2} variables',
      '{{param1}}',
      '{{param2}}'
    ],
    'div_12:ul:li_1': [
      'line item without id 2 with {1} and {2} variables',
      '{{param1}}',
      '{{param2}}'
    ],
    'div_12:ul:li_2': [
      'line item without id 3 with {1} and {2} variables',
      '{{param1}}',
      '{{param2}}'
    ],
    'line-items:li': [
      'line item with id 1 with {1} and {2} variables',
      '{{param1}}',
      '{{param2}}'
    ],
    'line-items:li_1': [
      'line item with id 2 with {1} and {2} variables',
      '{{param1}}',
      '{{param2}}'
    ],
    'line-items:li_2': [
      'line item with id 3 with {1} and {2} variables',
      '{{param1}}',
      '{{param2}}'
    ],
    'p_13': [
      'A paragraph with {1} is converted to {2}.',
      '{{param1}}',
      '{{param2}}'
    ],
    'paragraph': [
      'A paragraph with {1}, {2}, and {3} is converted to {4}.',
      'id',
      '{{param1}}',
      '{{param2}}',
      '<i18n-format>'
    ],
    'text_15': [
      ' outermost text at the end with {1} and {2} variables ',
      '{{param1}}',
      '{{param2}}'
    ]
  };
  var localDOM_compound = [
    { select: 'i18n-format', 
      'PolymerDom.children.0.textContent': [
        ' outermost text at the beginning with compound {1} and {2} variables ',
        'outermost header 1 with {1} and {2} variables',
        ' outermost text in the middle with {1} and {2} variables ',
        'simple text without id with {1} and {2} variables',
        'simple text without id 2 with {1} and {2} variables',
        'simple text with id and {1} and {2} variables',
        'simple text with id and {1} and {2} variables 2',
        'simple text within div with {1} and {2} variables',
        'simple text within div with {1} and {2} variables 2',
        'great grandchild text within div with {1} and {2} variables',
        ' simple text as the first element in div with {1} and {2} variables ',
        'simple text within div with {1} and {2} variables',
        ' simple text in the middle of div with {1} and {2} variables ',
        'simple text within div with {1} and {2} variables 2',
        'great grandchild text within div with {1} and {2} variables',
        ' simple text at the last element in div with {1} and {2} variables ',
        'simple text within div with {1} and {2} variables',
        'simple text within div 2 with {1} and {2} variables',
        'great grandchild text within div with {1} and {2} variables',
        'great grandchild text within div without id with {1} and {2} variables',
        'line item without id 1 with {1} and {2} variables',
        'line item without id 2 with {1} and {2} variables',
        'line item without id 3 with {1} and {2} variables',
        'line item with id 1 with {1} and {2} variables',
        'line item with id 2 with {1} and {2} variables',
        'line item with id 3 with {1} and {2} variables',
        'A paragraph with {1} is converted to {2}.',
        'A paragraph with {1}, {2}, and {3} is converted to {4}.',
        ' outermost text at the end with {1} and {2} variables '
      ],
      'PolymerDom.children.1.textContent.raw': [
        '1st compound parameter',
        '1st compound parameter',
        '1st compound parameter',
        '1st compound parameter',
        '1st compound parameter',
        '1st compound parameter',
        '1st compound parameter',
        '1st compound parameter',
        '1st compound parameter',
        '1st compound parameter',
        '1st compound parameter',
        '1st compound parameter',
        '1st compound parameter',
        '1st compound parameter',
        '1st compound parameter',
        '1st compound parameter',
        '1st compound parameter',
        '1st compound parameter',
        '1st compound parameter',
        '1st compound parameter',
        '1st compound parameter',
        '1st compound parameter',
        '1st compound parameter',
        '1st compound parameter',
        '1st compound parameter',
        '1st compound parameter',
        '1st compound parameter'
      ],
      'PolymerDom.children.2.textContent.raw': [
        '2nd compound parameter',
        '2nd compound parameter',
        '2nd compound parameter',
        '2nd compound parameter',
        '2nd compound parameter',
        '2nd compound parameter',
        '2nd compound parameter',
        '2nd compound parameter',
        '2nd compound parameter',
        '2nd compound parameter',
        '2nd compound parameter',
        '2nd compound parameter',
        '2nd compound parameter',
        '2nd compound parameter',
        '2nd compound parameter',
        '2nd compound parameter',
        '2nd compound parameter',
        '2nd compound parameter',
        '2nd compound parameter',
        '2nd compound parameter',
        '2nd compound parameter',
        '2nd compound parameter',
        '2nd compound parameter',
        '2nd compound parameter',
        '2nd compound parameter',
        '2nd compound parameter',
        '2nd compound parameter',
        '1st compound parameter',
        '2nd compound parameter'
      ]
    },
    { select: '[id="paragraph"] i18n-format',
      'PolymerDom.children.1.tagName': 'B',
      'PolymerDom.children.1.textContent': 'id',
      'PolymerDom.children.1.attributes.slot.value.raw': '1',
      'PolymerDom.children.3.tagName': 'SPAN',
      'PolymerDom.children.3.textContent.raw': '2nd compound parameter',
      'PolymerDom.children.3.attributes.slot.value.raw': '3'
    },
    { select: '[id="paragraph"] +i18n-format', 
      'PolymerDom.children.1.textContent.raw': '1st compound parameter'
    }
  ];

  var suites = [
    s('simple text default', null, { 
      fixture: 'simple-text-element-default-fixture', 
      fixtureModel: undefined, 
      assign: undefined,
      lang: lang1,
      effectiveLang: lang1,
      templateDefaultLang: lang1,
      observeHtmlLang: true,
      text: text_simple,
      model: {},
      localDOM: localDOM_simple,
      lightDOM: undefined
    }),
    s('commented simple text default', 'simple text default', {
      fixture: 'commented-simple-text-element-default-fixture'
    }),
    s('simple text default null lang', 'simple text default', {
      assign: { lang: lang0 },
      lang: lang0,
      effectiveLang: lang0
    }),
    s('commented simple text default null lang', 'commented simple text default', { 
      assign: { lang: lang0 },
      lang: lang0,
      effectiveLang: lang0
    }),
    s(lang2 + ' simple text default', 'simple text default', {
      assign: { lang: lang2 },
      lang: lang2,
      effectiveLang: lang2
    }),
    s(lang2 + ' commented simple text default', 'commented simple text default', {
      assign: { lang: lang2 },
      lang: lang2,
      effectiveLang: lang2
    }),
    s('simple text null lang', 'simple text default', {
      fixture: 'simple-text-element-fixture',
      fixtureModel: { observeHtmlLang: false, lang: lang0 }, 
      assign: { lang: lang0 },
      lang: lang0,
      effectiveLang: lang0,
      observeHtmlLang: false
    }),
    s('simple text', 'simple text null lang', {
      assign: { lang: lang1 },
      lang: lang1,
      effectiveLang: lang1
    }),
    s(lang2 + ' simple text', 'simple text', {
      assign: { lang: lang2 },
      lang: lang2,
      effectiveLang: lang2
    }),
    s(lang6 + ' simple text', 'simple text', {
      assign: { lang: lang6 },
      lang: lang6,
      effectiveLang: lang6
    }),
    s('commented simple text', 'simple text', {
      fixture: 'commented-simple-text-element-fixture'
    }),
    s('commented simple text null lang', 'commented simple text', {
      assign: { lang: lang0 },
      lang: lang0,
      effectiveLang: lang0
    }),
    s(lang2 + ' commented simple text', 'commented simple text', {
      fixtureModel: { observeHtmlLang: false, lang: lang0 }, 
      assign: { lang: lang2 },
      lang: lang2,
      effectiveLang: lang2
    }),
    s(lang2 + ' static commented simple text', 'commented simple text', {
      fixtureModel: { observeHtmlLang: false, lang: lang2 }, 
      assign: undefined,
      lang: lang2,
      effectiveLang: lang2
    }),
    s('simple text id', 'simple text', {
      fixture: 'simple-text-id-element-fixture',
      text: text_simple_text_id,
      localDOM: localDOM_simple_text_id
    }),
    s(lang2 + ' simple text id', 'simple text id', {
      assign: { lang: lang2 },
      lang: lang2,
      effectiveLang: lang2
    }),
    s('plural gender', 'simple text default', {
      fixture: 'plural-gender-element-fixture', 
      fixtureModel: {
        observeHtmlLang: false,
        lang: lang0
      }, 
      assign: {
        lang: lang1,
        sender: sender1,
        recipients: recipients1
      },
      observeHtmlLang: false,
      event: 'local-dom-ready',
      text: text_plural_gender,
      localDOM: localDOM_plural_gender_1
    }),
    s('plural gender 2', 'plural gender', {
      assign: {
        lang: lang1,
        sender: sender1,
        recipients: recipients2
      },
      localDOM: localDOM_plural_gender_2
    }),
    s('plural gender 3', 'plural gender', {
      assign: {
        lang: lang1,
        sender: sender1,
        recipients: recipients3
      },
      localDOM: localDOM_plural_gender_3
    }),
    s('plural gender 4', 'plural gender', {
      assign: {
        lang: lang1,
        sender: sender1,
        recipients: recipients4
      },
      localDOM: localDOM_plural_gender_4
    }),
    s(lang2 + ' plural gender', 'plural gender', {
      assign: {
        lang: lang2,
        sender: sender1,
        recipients: recipients1
      },
      lang: lang2,
      effectiveLang: lang2
    }),
    s(lang2 + ' plural gender 2', 'plural gender 2', {
      assign: {
        lang: lang2,
        sender: sender1,
        recipients: recipients2
      },
      lang: lang2,
      effectiveLang: lang2,
      localDOM: localDOM_plural_gender_2
    }),
    s(lang2 + ' plural gender 3', 'plural gender 3', {
      assign: {
        lang: lang2,
        sender: sender1,
        recipients: recipients3
      },
      lang: lang2,
      effectiveLang: lang2,
      localDOM: localDOM_plural_gender_3
    }),
    s(lang2 + ' plural gender 4', 'plural gender 4', {
      assign: {
        lang: lang2,
        sender: sender1,
        recipients: recipients4
      },
      lang: lang2,
      effectiveLang: lang2,
      localDOM: localDOM_plural_gender_4
    }),
    s('simple attribute', 'simple text default', {
      fixture: 'simple-attribute-element-fixture', 
      fixtureModel: {
        observeHtmlLang: false,
        lang: lang0
      }, 
      assign: { lang: lang1 },
      observeHtmlLang: false,
      text: text_simple_attribute,
      model: model_simple_attribute,
      localDOM: localDOM_simple_attribute
    }),
    s(lang2 + ' simple attribute', 'simple attribute', {
      assign: { lang: lang2 },
      lang: lang2,
      effectiveLang: lang2,
      localDOM: localDOM_simple_attribute_fr
    }),
    s(lang4 + ' simple text default with fallback to ' + lang2, 'simple text default', {
      timeout: 60000,
      assign: { lang: lang4 },
      lang: lang2,
      effectiveLang: lang2
    }),
    s(lang4 + ' simple text with fallback to ' + lang2, 'simple text', {
      timeout: 60000,
      assign: { lang: lang4 },
      lang: lang2,
      effectiveLang: lang2
    }),
    s(lang5 + ' simple text with fallback to default', 'simple text', {
      timeout: 60000,
      assign: { lang: lang5 },
      lang: lang0,
      effectiveLang: lang0
    }),
    s(lang3 + ' simple text with fallback to default', 'simple text', {
      timeout: 60000,
      assign: { lang: lang3 },
      lang: lang0,
      effectiveLang: lang0
    }),
    s(lang4 + ' fallback text', 'simple text', {
      timeout: 60000,
      fixture: 'fallback-text-element-fixture', 
      assign: { lang: lang4 },
      lang: lang4,
      effectiveLang: lang4,
      rawText: true,
      text: text_fallback,
      localDOM: localDOM_fallback
    }),
    s('compound binding', 'simple text', {
      fixture: 'compound-binding-element-fixture',
      fixtureModel: {
        observeHtmlLang: false,
        lang: lang0,
        param1: param1,
        param2: param2
      },
      text: text_compound,
      localDOM: localDOM_compound
    }),
    s(lang2 + ' compound binding', 'compound binding', {
      fixtureModel: {
        observeHtmlLang: false,
        lang: lang0,
        param1: param1,
        param2: param2
      },
      assign: { lang: lang2 },
      lang: lang2,
      effectiveLang: lang2
    }),
    /*
    s('simple attribute dom bind', 'simple attribute', {
      fixture: 'simple-attribute-dom-bind', 
      fixtureModel: {
        observeHtmlLang: false,
        lang: lang0
      }, 
      assign: { lang: lang1 },
      event: 'local-dom-ready',
      text: text_simple_attribute,
      model: model_simple_attribute,
      localDOM: localDOM_simple_attribute
    }),
    s(lang2 + ' simple attribute dom bind', 'simple attribute dom bind', {
      fixtureModel: {
        observeHtmlLang: false,
        lang: lang0
      },
      assign: { lang: lang2 },
      lang: lang2,
      effectiveLang: lang2,
      localDOM: localDOM_simple_attribute_fr
    }),
    s('compound binding dom bind', 'compound binding', {
      fixture: 'compound-binding-dom-bind'
    }),
    s(lang2 + ' compound binding dom bind', 'compound binding dom bind', {
      assign: { lang: lang2 },
      lang: lang2,
      effectiveLang: lang2
    }),
    s(lang2 + ' default observeHtmlLang simple text dom bind', 'simple text', {
      fixture: 'simple-text-dom-bind',
      fixtureModel: {
        'html.lang': lang5
      },
      assign: { 'html.lang': lang2 },
      lang: lang2,
      effectiveLang: lang2,
      text: text_simple,
      model: undefined,
      localDOM: localDOM_simple,
      observeHtmlLang: true
    }),
    s('simple text dom bind', 'simple text', {
      fixture: 'simple-text-dom-bind',
      fixtureModel: {
        observeHtmlLang: false,
        lang: lang0
      },
      text: text_simple,
      localDOM: localDOM_simple
    }),
    s(lang2 + ' simple text dom bind', 'simple text dom bind', {
      assign: { lang: lang2 },
      lang: lang2,
      effectiveLang: lang2
    }),
    s('html.lang simple text dom bind', 'simple text dom bind', {
      fixtureModel: {
        observeHtmlLang: true,
        lang: lang0,
        'html.lang': lang0
      },
      assign: { 'html.lang': lang1 },
      observeHtmlLang: true
    }),
    s(lang2 + ' html.lang simple text dom bind', 'html.lang simple text dom bind', {
      assign: { 'html.lang': lang2 },
      lang: lang2,
      effectiveLang: lang2
    }),
    */
    s('observeHtmlLang default simple text', 'simple text null lang', {
      fixtureModel: {
        observeHtmlLang: true
      },
      assign: { 'html.lang': lang1 },
      lang: lang1,
      effectiveLang: lang1,
      observeHtmlLang: true
    })
  ];

  suitesRunner(suites);
});
</script>
</div></body></html>